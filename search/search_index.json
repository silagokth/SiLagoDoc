{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to SiLago Documentation","text":"<p>Abstract</p> <p>This website hosts all the documentation of SiLago project.</p>"},{"location":"#repos","title":"Repos","text":"<p>Warning</p> <p>Some repos are private for now!</p> <ul> <li>Fabric Repo</li> <li>Vesyla-suite Repo</li> </ul>"},{"location":"#quick-start-tutorials","title":"Quick Start Tutorials","text":"<ul> <li>MkDoc Tutorial</li> <li>Vesyla Tutorial for DRRA</li> <li>Vesyla Tutorial for RISC-V</li> <li>Vesyla programming guide</li> </ul>"},{"location":"#guidlines","title":"Guidlines","text":"<ul> <li>C++</li> <li>RTL</li> </ul>"},{"location":"About/About/","title":"About","text":""},{"location":"About/About/#silago-team-members","title":"SiLago Team Members","text":"Name Email Role Jordi Altayo Gonzalez jordiag@kth.se PhD student Bhavana Ballal bhavanab@kth.se PhD student Ahmed Hemani hemani@kth.se Professor Sofia Olsson sools@kth.se PhD student Maah Paara mapaar@kth.se PhD student Ritika Ratnu ratnu@kth.se PhD student Ivan Sraichuk sraichuk@kth.se PhD student Dimitrios Stathis stathis@kth.se Postdoc Yu Yang yuyang2@kth.se Postdoc Saba Yousefzadeh sabay@kth.se PhD student"},{"location":"About/License/","title":"License","text":"<p>This documentation is licensed under GNU Free Documentation License.</p> <p>A full legal document is listed below. You can also check the license contents from the official website: https://www.gnu.org/licenses/fdl.html</p> <pre><code>                GNU Free Documentation License\n                 Version 1.3, 3 November 2008\n\n\n Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.\n     &lt;https://fsf.org/&gt;\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n0. PREAMBLE\n\nThe purpose of this License is to make a manual, textbook, or other\nfunctional and useful document \"free\" in the sense of freedom: to\nassure everyone the effective freedom to copy and redistribute it,\nwith or without modifying it, either commercially or noncommercially.\nSecondarily, this License preserves for the author and publisher a way\nto get credit for their work, while not being considered responsible\nfor modifications made by others.\n\nThis License is a kind of \"copyleft\", which means that derivative\nworks of the document must themselves be free in the same sense.  It\ncomplements the GNU General Public License, which is a copyleft\nlicense designed for free software.\n\nWe have designed this License in order to use it for manuals for free\nsoftware, because free software needs free documentation: a free\nprogram should come with manuals providing the same freedoms that the\nsoftware does.  But this License is not limited to software manuals;\nit can be used for any textual work, regardless of subject matter or\nwhether it is published as a printed book.  We recommend this License\nprincipally for works whose purpose is instruction or reference.\n\n\n1. APPLICABILITY AND DEFINITIONS\n\nThis License applies to any manual or other work, in any medium, that\ncontains a notice placed by the copyright holder saying it can be\ndistributed under the terms of this License.  Such a notice grants a\nworld-wide, royalty-free license, unlimited in duration, to use that\nwork under the conditions stated herein.  The \"Document\", below,\nrefers to any such manual or work.  Any member of the public is a\nlicensee, and is addressed as \"you\".  You accept the license if you\ncopy, modify or distribute the work in a way requiring permission\nunder copyright law.\n\nA \"Modified Version\" of the Document means any work containing the\nDocument or a portion of it, either copied verbatim, or with\nmodifications and/or translated into another language.\n\nA \"Secondary Section\" is a named appendix or a front-matter section of\nthe Document that deals exclusively with the relationship of the\npublishers or authors of the Document to the Document's overall\nsubject (or to related matters) and contains nothing that could fall\ndirectly within that overall subject.  (Thus, if the Document is in\npart a textbook of mathematics, a Secondary Section may not explain\nany mathematics.)  The relationship could be a matter of historical\nconnection with the subject or with related matters, or of legal,\ncommercial, philosophical, ethical or political position regarding\nthem.\n\nThe \"Invariant Sections\" are certain Secondary Sections whose titles\nare designated, as being those of Invariant Sections, in the notice\nthat says that the Document is released under this License.  If a\nsection does not fit the above definition of Secondary then it is not\nallowed to be designated as Invariant.  The Document may contain zero\nInvariant Sections.  If the Document does not identify any Invariant\nSections then there are none.\n\nThe \"Cover Texts\" are certain short passages of text that are listed,\nas Front-Cover Texts or Back-Cover Texts, in the notice that says that\nthe Document is released under this License.  A Front-Cover Text may\nbe at most 5 words, and a Back-Cover Text may be at most 25 words.\n\nA \"Transparent\" copy of the Document means a machine-readable copy,\nrepresented in a format whose specification is available to the\ngeneral public, that is suitable for revising the document\nstraightforwardly with generic text editors or (for images composed of\npixels) generic paint programs or (for drawings) some widely available\ndrawing editor, and that is suitable for input to text formatters or\nfor automatic translation to a variety of formats suitable for input\nto text formatters.  A copy made in an otherwise Transparent file\nformat whose markup, or absence of markup, has been arranged to thwart\nor discourage subsequent modification by readers is not Transparent.\nAn image format is not Transparent if used for any substantial amount\nof text.  A copy that is not \"Transparent\" is called \"Opaque\".\n\nExamples of suitable formats for Transparent copies include plain\nASCII without markup, Texinfo input format, LaTeX input format, SGML\nor XML using a publicly available DTD, and standard-conforming simple\nHTML, PostScript or PDF designed for human modification.  Examples of\ntransparent image formats include PNG, XCF and JPG.  Opaque formats\ninclude proprietary formats that can be read and edited only by\nproprietary word processors, SGML or XML for which the DTD and/or\nprocessing tools are not generally available, and the\nmachine-generated HTML, PostScript or PDF produced by some word\nprocessors for output purposes only.\n\nThe \"Title Page\" means, for a printed book, the title page itself,\nplus such following pages as are needed to hold, legibly, the material\nthis License requires to appear in the title page.  For works in\nformats which do not have any title page as such, \"Title Page\" means\nthe text near the most prominent appearance of the work's title,\npreceding the beginning of the body of the text.\n\nThe \"publisher\" means any person or entity that distributes copies of\nthe Document to the public.\n\nA section \"Entitled XYZ\" means a named subunit of the Document whose\ntitle either is precisely XYZ or contains XYZ in parentheses following\ntext that translates XYZ in another language.  (Here XYZ stands for a\nspecific section name mentioned below, such as \"Acknowledgements\",\n\"Dedications\", \"Endorsements\", or \"History\".)  To \"Preserve the Title\"\nof such a section when you modify the Document means that it remains a\nsection \"Entitled XYZ\" according to this definition.\n\nThe Document may include Warranty Disclaimers next to the notice which\nstates that this License applies to the Document.  These Warranty\nDisclaimers are considered to be included by reference in this\nLicense, but only as regards disclaiming warranties: any other\nimplication that these Warranty Disclaimers may have is void and has\nno effect on the meaning of this License.\n\n2. VERBATIM COPYING\n\nYou may copy and distribute the Document in any medium, either\ncommercially or noncommercially, provided that this License, the\ncopyright notices, and the license notice saying this License applies\nto the Document are reproduced in all copies, and that you add no\nother conditions whatsoever to those of this License.  You may not use\ntechnical measures to obstruct or control the reading or further\ncopying of the copies you make or distribute.  However, you may accept\ncompensation in exchange for copies.  If you distribute a large enough\nnumber of copies you must also follow the conditions in section 3.\n\nYou may also lend copies, under the same conditions stated above, and\nyou may publicly display copies.\n\n\n3. COPYING IN QUANTITY\n\nIf you publish printed copies (or copies in media that commonly have\nprinted covers) of the Document, numbering more than 100, and the\nDocument's license notice requires Cover Texts, you must enclose the\ncopies in covers that carry, clearly and legibly, all these Cover\nTexts: Front-Cover Texts on the front cover, and Back-Cover Texts on\nthe back cover.  Both covers must also clearly and legibly identify\nyou as the publisher of these copies.  The front cover must present\nthe full title with all words of the title equally prominent and\nvisible.  You may add other material on the covers in addition.\nCopying with changes limited to the covers, as long as they preserve\nthe title of the Document and satisfy these conditions, can be treated\nas verbatim copying in other respects.\n\nIf the required texts for either cover are too voluminous to fit\nlegibly, you should put the first ones listed (as many as fit\nreasonably) on the actual cover, and continue the rest onto adjacent\npages.\n\nIf you publish or distribute Opaque copies of the Document numbering\nmore than 100, you must either include a machine-readable Transparent\ncopy along with each Opaque copy, or state in or with each Opaque copy\na computer-network location from which the general network-using\npublic has access to download using public-standard network protocols\na complete Transparent copy of the Document, free of added material.\nIf you use the latter option, you must take reasonably prudent steps,\nwhen you begin distribution of Opaque copies in quantity, to ensure\nthat this Transparent copy will remain thus accessible at the stated\nlocation until at least one year after the last time you distribute an\nOpaque copy (directly or through your agents or retailers) of that\nedition to the public.\n\nIt is requested, but not required, that you contact the authors of the\nDocument well before redistributing any large number of copies, to\ngive them a chance to provide you with an updated version of the\nDocument.\n\n\n4. MODIFICATIONS\n\nYou may copy and distribute a Modified Version of the Document under\nthe conditions of sections 2 and 3 above, provided that you release\nthe Modified Version under precisely this License, with the Modified\nVersion filling the role of the Document, thus licensing distribution\nand modification of the Modified Version to whoever possesses a copy\nof it.  In addition, you must do these things in the Modified Version:\n\nA. Use in the Title Page (and on the covers, if any) a title distinct\n   from that of the Document, and from those of previous versions\n   (which should, if there were any, be listed in the History section\n   of the Document).  You may use the same title as a previous version\n   if the original publisher of that version gives permission.\nB. List on the Title Page, as authors, one or more persons or entities\n   responsible for authorship of the modifications in the Modified\n   Version, together with at least five of the principal authors of the\n   Document (all of its principal authors, if it has fewer than five),\n   unless they release you from this requirement.\nC. State on the Title page the name of the publisher of the\n   Modified Version, as the publisher.\nD. Preserve all the copyright notices of the Document.\nE. Add an appropriate copyright notice for your modifications\n   adjacent to the other copyright notices.\nF. Include, immediately after the copyright notices, a license notice\n   giving the public permission to use the Modified Version under the\n   terms of this License, in the form shown in the Addendum below.\nG. Preserve in that license notice the full lists of Invariant Sections\n   and required Cover Texts given in the Document's license notice.\nH. Include an unaltered copy of this License.\nI. Preserve the section Entitled \"History\", Preserve its Title, and add\n   to it an item stating at least the title, year, new authors, and\n   publisher of the Modified Version as given on the Title Page.  If\n   there is no section Entitled \"History\" in the Document, create one\n   stating the title, year, authors, and publisher of the Document as\n   given on its Title Page, then add an item describing the Modified\n   Version as stated in the previous sentence.\nJ. Preserve the network location, if any, given in the Document for\n   public access to a Transparent copy of the Document, and likewise\n   the network locations given in the Document for previous versions\n   it was based on.  These may be placed in the \"History\" section.\n   You may omit a network location for a work that was published at\n   least four years before the Document itself, or if the original\n   publisher of the version it refers to gives permission.\nK. For any section Entitled \"Acknowledgements\" or \"Dedications\",\n   Preserve the Title of the section, and preserve in the section all\n   the substance and tone of each of the contributor acknowledgements\n   and/or dedications given therein.\nL. Preserve all the Invariant Sections of the Document,\n   unaltered in their text and in their titles.  Section numbers\n   or the equivalent are not considered part of the section titles.\nM. Delete any section Entitled \"Endorsements\".  Such a section\n   may not be included in the Modified Version.\nN. Do not retitle any existing section to be Entitled \"Endorsements\"\n   or to conflict in title with any Invariant Section.\nO. Preserve any Warranty Disclaimers.\n\nIf the Modified Version includes new front-matter sections or\nappendices that qualify as Secondary Sections and contain no material\ncopied from the Document, you may at your option designate some or all\nof these sections as invariant.  To do this, add their titles to the\nlist of Invariant Sections in the Modified Version's license notice.\nThese titles must be distinct from any other section titles.\n\nYou may add a section Entitled \"Endorsements\", provided it contains\nnothing but endorsements of your Modified Version by various\nparties--for example, statements of peer review or that the text has\nbeen approved by an organization as the authoritative definition of a\nstandard.\n\nYou may add a passage of up to five words as a Front-Cover Text, and a\npassage of up to 25 words as a Back-Cover Text, to the end of the list\nof Cover Texts in the Modified Version.  Only one passage of\nFront-Cover Text and one of Back-Cover Text may be added by (or\nthrough arrangements made by) any one entity.  If the Document already\nincludes a cover text for the same cover, previously added by you or\nby arrangement made by the same entity you are acting on behalf of,\nyou may not add another; but you may replace the old one, on explicit\npermission from the previous publisher that added the old one.\n\nThe author(s) and publisher(s) of the Document do not by this License\ngive permission to use their names for publicity for or to assert or\nimply endorsement of any Modified Version.\n\n\n5. COMBINING DOCUMENTS\n\nYou may combine the Document with other documents released under this\nLicense, under the terms defined in section 4 above for modified\nversions, provided that you include in the combination all of the\nInvariant Sections of all of the original documents, unmodified, and\nlist them all as Invariant Sections of your combined work in its\nlicense notice, and that you preserve all their Warranty Disclaimers.\n\nThe combined work need only contain one copy of this License, and\nmultiple identical Invariant Sections may be replaced with a single\ncopy.  If there are multiple Invariant Sections with the same name but\ndifferent contents, make the title of each such section unique by\nadding at the end of it, in parentheses, the name of the original\nauthor or publisher of that section if known, or else a unique number.\nMake the same adjustment to the section titles in the list of\nInvariant Sections in the license notice of the combined work.\n\nIn the combination, you must combine any sections Entitled \"History\"\nin the various original documents, forming one section Entitled\n\"History\"; likewise combine any sections Entitled \"Acknowledgements\",\nand any sections Entitled \"Dedications\".  You must delete all sections\nEntitled \"Endorsements\".\n\n\n6. COLLECTIONS OF DOCUMENTS\n\nYou may make a collection consisting of the Document and other\ndocuments released under this License, and replace the individual\ncopies of this License in the various documents with a single copy\nthat is included in the collection, provided that you follow the rules\nof this License for verbatim copying of each of the documents in all\nother respects.\n\nYou may extract a single document from such a collection, and\ndistribute it individually under this License, provided you insert a\ncopy of this License into the extracted document, and follow this\nLicense in all other respects regarding verbatim copying of that\ndocument.\n\n\n7. AGGREGATION WITH INDEPENDENT WORKS\n\nA compilation of the Document or its derivatives with other separate\nand independent documents or works, in or on a volume of a storage or\ndistribution medium, is called an \"aggregate\" if the copyright\nresulting from the compilation is not used to limit the legal rights\nof the compilation's users beyond what the individual works permit.\nWhen the Document is included in an aggregate, this License does not\napply to the other works in the aggregate which are not themselves\nderivative works of the Document.\n\nIf the Cover Text requirement of section 3 is applicable to these\ncopies of the Document, then if the Document is less than one half of\nthe entire aggregate, the Document's Cover Texts may be placed on\ncovers that bracket the Document within the aggregate, or the\nelectronic equivalent of covers if the Document is in electronic form.\nOtherwise they must appear on printed covers that bracket the whole\naggregate.\n\n\n8. TRANSLATION\n\nTranslation is considered a kind of modification, so you may\ndistribute translations of the Document under the terms of section 4.\nReplacing Invariant Sections with translations requires special\npermission from their copyright holders, but you may include\ntranslations of some or all Invariant Sections in addition to the\noriginal versions of these Invariant Sections.  You may include a\ntranslation of this License, and all the license notices in the\nDocument, and any Warranty Disclaimers, provided that you also include\nthe original English version of this License and the original versions\nof those notices and disclaimers.  In case of a disagreement between\nthe translation and the original version of this License or a notice\nor disclaimer, the original version will prevail.\n\nIf a section in the Document is Entitled \"Acknowledgements\",\n\"Dedications\", or \"History\", the requirement (section 4) to Preserve\nits Title (section 1) will typically require changing the actual\ntitle.\n\n\n9. TERMINATION\n\nYou may not copy, modify, sublicense, or distribute the Document\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense, or distribute it is void, and\nwill automatically terminate your rights under this License.\n\nHowever, if you cease all violation of this License, then your license\nfrom a particular copyright holder is reinstated (a) provisionally,\nunless and until the copyright holder explicitly and finally\nterminates your license, and (b) permanently, if the copyright holder\nfails to notify you of the violation by some reasonable means prior to\n60 days after the cessation.\n\nMoreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\nTermination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, receipt of a copy of some or all of the same material does\nnot give you any rights to use it.\n\n\n10. FUTURE REVISIONS OF THIS LICENSE\n\nThe Free Software Foundation may publish new, revised versions of the\nGNU Free Documentation License from time to time.  Such new versions\nwill be similar in spirit to the present version, but may differ in\ndetail to address new problems or concerns.  See\nhttps://www.gnu.org/licenses/.\n\nEach version of the License is given a distinguishing version number.\nIf the Document specifies that a particular numbered version of this\nLicense \"or any later version\" applies to it, you have the option of\nfollowing the terms and conditions either of that specified version or\nof any later version that has been published (not as a draft) by the\nFree Software Foundation.  If the Document does not specify a version\nnumber of this License, you may choose any version ever published (not\nas a draft) by the Free Software Foundation.  If the Document\nspecifies that a proxy can decide which future versions of this\nLicense can be used, that proxy's public statement of acceptance of a\nversion permanently authorizes you to choose that version for the\nDocument.\n\n11. RELICENSING\n\n\"Massive Multiauthor Collaboration Site\" (or \"MMC Site\") means any\nWorld Wide Web server that publishes copyrightable works and also\nprovides prominent facilities for anybody to edit those works.  A\npublic wiki that anybody can edit is an example of such a server.  A\n\"Massive Multiauthor Collaboration\" (or \"MMC\") contained in the site\nmeans any set of copyrightable works thus published on the MMC site.\n\n\"CC-BY-SA\" means the Creative Commons Attribution-Share Alike 3.0 \nlicense published by Creative Commons Corporation, a not-for-profit \ncorporation with a principal place of business in San Francisco, \nCalifornia, as well as future copyleft versions of that license \npublished by that same organization.\n\n\"Incorporate\" means to publish or republish a Document, in whole or in \npart, as part of another Document.\n\nAn MMC is \"eligible for relicensing\" if it is licensed under this \nLicense, and if all works that were first published under this License \nsomewhere other than this MMC, and subsequently incorporated in whole or \nin part into the MMC, (1) had no cover texts or invariant sections, and \n(2) were thus incorporated prior to November 1, 2008.\n\nThe operator of an MMC Site may republish an MMC contained in the site\nunder CC-BY-SA on the same site at any time before August 1, 2009,\nprovided the MMC is eligible for relicensing.\n\n\nADDENDUM: How to use this License for your documents\n\nTo use this License in a document you have written, include a copy of\nthe License in the document and put the following copyright and\nlicense notices just after the title page:\n\n    Copyright (c)  YEAR  YOUR NAME.\n    Permission is granted to copy, distribute and/or modify this document\n    under the terms of the GNU Free Documentation License, Version 1.3\n    or any later version published by the Free Software Foundation;\n    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.\n    A copy of the license is included in the section entitled \"GNU\n    Free Documentation License\".\n\nIf you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,\nreplace the \"with...Texts.\" line with this:\n\n    with the Invariant Sections being LIST THEIR TITLES, with the\n    Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.\n\nIf you have Invariant Sections without Cover Texts, or some other\ncombination of the three, merge those two alternatives to suit the\nsituation.\n\nIf your document contains nontrivial examples of program code, we\nrecommend releasing these examples in parallel under your choice of\nfree software license, such as the GNU General Public License,\nto permit their use in free software.\n</code></pre>"},{"location":"Docs/Application/Overview/","title":"Overview","text":"<p>Warning</p> <p>Documentation is not complete!</p>"},{"location":"Docs/Application/SiLagoDSP/Fast-Fourier-Projection/","title":"Fast Fourier Projection","text":"<p>Warning</p> <p>Documentation is not complete!</p>"},{"location":"Docs/Fabric/Overview/","title":"Overview","text":"<p>Please check the specification of DRRA: DRRA Specification</p>"},{"location":"Docs/Fabric/Style-guide/","title":"Style Guide","text":""},{"location":"Docs/Fabric/Style-guide/#vhdl-style","title":"VHDL Style","text":""},{"location":"Docs/Fabric/DRRA/RACCU/","title":"Run-time Address Constraint Computing Unit","text":""},{"location":"Docs/Fabric/DRRA/RACCU/#function","title":"Function","text":"<p>Run-time Address Constraint Computing Unit (RACCU) is used for computing address constraint for Address Generation Unit (AGU). AGU can deal with maximum 2-level affine address function. Affine address function is a function that can be expressed by equation below:</p>  \\begin{align} y = ax+b \\end{align}   <p>where <code>a</code> and <code>b</code> are constraints.</p> <p>2-level affine address function can then be expressed as:</p>  \\begin{align} y = c(ax+b)+d \\end{align}   <p>where <code>a</code> ,<code>b</code>, <code>c</code> and <code>d</code> are constraints.</p> <p>Address constraint can be immediate value or a number generated at run-time according to a given function. The resources which deal with the constraint generation is the RACCU.</p>"},{"location":"Docs/Fabric/DRRA/RACCU/#specification","title":"Specification","text":"<p>Info</p> <p>Old RACCU implementation.</p> <p>RACCU is a unit inside Sequencer.</p> <p>It has a register file of default depth <code>N=8</code>. Contraints and temporary variables will be stored inside this register file. The data register is always exposed to Sequencer to read. Another register file in RACCU is used to manage the loops. The depth depends on maximum nested loop RACCU can handle, by default it's <code>4</code>. Each entry in loop management register file has 3 fields:</p> <ol> <li>Loop id</li> <li>Loop counter</li> <li>Loop end flag</li> </ol> <p>The loop id will be identify the entry location in the loop management register file. Loop counter will be initialized by the first LOOP_HEADER instruction and be changed periodically by LOOP_TAIL instruction. The comparison between the loop conter and loop bound is carried out by LOOP_HEADER instruction. If they are equal, loop end flag will be set to <code>true</code> and exits the loop.</p> <p>RACCU has a computation unit which is similar to a mini-DPU. It has 5 working modes. All of them are binary operations. They are:</p> <ul> <li>(0) RACCU_MODE_IDLE</li> <li>(1) RACCU_MODE_LOOP_H</li> <li>(2) RACCU_MODE_LOOP_T</li> <li>(3) RACCU_MODE_ADD</li> <li>(4) RACCU_MODE_SUB</li> <li>(5) RACCU_MODE_SHIFT_L</li> <li>(6) RACCU_MODE_SHIFT_R</li> <li>(7) RACCU_MODE_ADD_WITH_LOOP_INDEX</li> </ul> <p>Operands of each mode can be either immediate value from instruction or data from RACCU register whoes address is specified by the instruction. A bit is used to distinguish the operand origin.</p> <p>Info</p> <p>New RACCU implementation.</p> <p>RACCU is a unit inside Sequencer.</p> <p>It has a register file of default depth <code>N=8</code>. Contraints, temporary variables and loop iterators will be stored inside this register file. The data register is always exposed to Sequencer to read. Loop iterator will be assigned from the beginning of the register file according to the order of loop while RACCU variables will be assigned from the end of register file. Once the loop iterators or the RACCU variables are not needed, they can be freed by moving the stack/heap pointer 1 position back. The assignment of register location is managed by the Vesyla compiler.</p> <p>RACCU has a computation unit which is similar to a mini-DPU. It has 8 working modes. All of them are binary operations. They are:</p> <ul> <li>(0) RACCU_MODE_IDLE</li> <li>(1) RACCU_MODE_LOOP_H</li> <li>(2) RACCU_MODE_LOOP_T</li> <li>(3) RACCU_MODE_ADD</li> <li>(4) RACCU_MODE_SUB</li> <li>(5) RACCU_MODE_SHIFT_L</li> <li>(6) RACCU_MODE_SHIFT_R</li> <li>(7) RACCU_MODE_LOG2</li> </ul> <p>Operands of each mode can be either immediate value from instruction or data from RACCU register whoes address is specified by the instruction. A bit is used to distinguish the operand origin.</p>"},{"location":"Docs/Fabric/DRRA/RACCU/#related-instructions","title":"Related Instructions","text":""},{"location":"Docs/Fabric/DRRA/RACCU/#raccu-instruction","title":"RACCU instruction","text":""},{"location":"Docs/Fabric/DRRA/RACCU/#loop_header-instruction","title":"LOOP_HEADER instruction","text":""},{"location":"Docs/Fabric/DRRA/RACCU/#loop_tail-instruction","title":"LOOP_TAIL instruction","text":""},{"location":"Docs/Fabric/DRRA/RACCU/#interface","title":"Interface","text":"<p>Info</p> <p>Old RACCU implementation.</p> Signal I/O Type Description clk in std_logic Clock rst in std_logic Reset, active low op1_sd in std_logic Type of operand 1, 0-immediate, 1-reference op1 in std_logic_vector 8bits Operand 1 value / Operand 1 address op2_sd in std_logic Type of operand 2, 0-immediate, 1-reference op2 in std_logic_vector 8bits Operand 2 value / Operand 2 address cfg_mode in std_logic_vector 3bits Mode of RACCU computation unit result_addr in std_logic_vector 3bits Result address in data_reg data_reg out raccu_reg_out_ty Data register output loop_reg out raccu_loop_array_ty Loop register output <p>Info</p> <p>New RACCU implementation.</p> Signal I/O Type Description clk in std_logic Clock rst in std_logic Reset, active low op1_sd in std_logic Type of operand 1, 0-immediate, 1-reference op1 in std_logic_vector 8bits Operand 1 value / Operand 1 address op2_sd in std_logic Type of operand 2, 0-immediate, 1-reference op2 in std_logic_vector 8bits Operand 2 value / Operand 2 address cfg_mode in std_logic_vector 3bits Mode of RACCU computation unit result_addr in std_logic_vector 3bits Result address in data_reg data_reg out raccu_reg_out_ty Data register output"},{"location":"Docs/Fabric/RISCV/Overview/","title":"Overview","text":"<p>Warning</p> <p>Documentation is not complete!</p>"},{"location":"Docs/Library/Overview/","title":"Overview","text":"<p>Warning</p> <p>Documentation is not complete!</p>"},{"location":"Docs/Library/BLAS/Overview/","title":"Overview","text":"<p>Warning</p> <p>Documentation is not complete!</p>"},{"location":"Docs/Library/BLAS/L3/gemm/","title":"GEMM","text":""},{"location":"Docs/Library/BLAS/L3/gemm/#function","title":"Function","text":"<p><code>gemm</code> computes a matrix-matrix product with general matrices.</p> <p>The <code>gemm</code> routines compute a scalar-matrix-matrix product and add the result to a scalar-matrix product, with general matrices. The operation is defined as</p>  C \\leftarrow \\alpha *A*B + \\beta *C  <p>where:</p> <ul> <li>\\alpha and \\beta are scalars,</li> <li>A, B and C are matrices:<ul> <li>A is an m-by-k matrix,</li> <li>B is a k-by-n matrix,</li> <li>C is an m-by-n matrix.</li> </ul> </li> </ul>"},{"location":"Docs/Library/BLAS/L3/gemm/#parameters","title":"Parameters","text":"<p>m: The number of rows in A and C.</p> <p>k: The number of columns in A and the number of rows in B.</p> <p>n: The number of columns in C.</p>"},{"location":"Docs/Library/BLAS/L3/gemm/#mapping","title":"Mapping","text":""},{"location":"Docs/Library/BLAS/L3/gemm/#one-column-mapping","title":"One-Column Mapping","text":""},{"location":"Docs/Library/BLAS/L3/gemm/#memory-mapping","title":"Memory Mapping","text":"<p>m, k and n are multiple of DiMArch row width (16). A and C stored in DiMArch in row-major fashion and B stored in DiMArch in col-major fashion.</p> <p>The first 16 words in register file in DRRA cell <code>[0,0]</code> is reserved for elements in A. The second half register file (16 words) is reserved for elements in B. The first 16 words in register file in DRRA cell <code>[1,0]</code> is for elements in C.</p> <p>The register space for A is also used temporarily for storing \\alpha and \\beta.</p> <p>One of the internal register in DRRA cell <code>[0,0]</code> is also used for holding \\alpha in order to perform the <code>axpy()</code> function.</p>"},{"location":"Docs/Library/BLAS/L3/gemm/#function-mapping","title":"Function Mapping","text":""},{"location":"Docs/Library/BLAS/L3/gemm/#scaling","title":"Scaling","text":""},{"location":"Docs/Library/BLAS/L3/gemm/#cost-metrics","title":"Cost Metrics","text":""},{"location":"Docs/Library/FFT/Overview/","title":"Overview","text":"<p>Warning</p> <p>Documentation is not complete!</p>"},{"location":"Docs/Library/Interleaver/Overview/","title":"Overview","text":"<p>Warning</p> <p>Documentation is not complete!</p>"},{"location":"Docs/Library/NN/Overview/","title":"Overview","text":"<p>Warning</p> <p>Documentation is not complete!</p>"},{"location":"Docs/ToolChain/Overview/","title":"Toolchain for SiLago Platform","text":""},{"location":"Docs/ToolChain/Overview/#application-level-synthesis-als","title":"Application-Level Synthesis (ALS)","text":"<p>Sylva is the ALS tool for SiLago platform.</p>"},{"location":"Docs/ToolChain/Overview/#high-level-synthesis-hls","title":"High-Level Synthesis (HLS)","text":"<p>Vesyla-suite is the HLS tool for DRRA-based SiLago platform. It contains multiple tools, such as <code>vs-vesyla</code>, <code>vs-manas</code>, <code>vs-alimpsim</code>, etc. It also contains a compiler for IMEC architecture called <code>vs-imecc</code>.</p>"},{"location":"Docs/ToolChain/Manas/Tutorial/","title":"Manas Tutorial","text":"<p>Warning</p> <p>Documentation is not complete!</p>"},{"location":"Docs/ToolChain/Sylva/Overview/","title":"Sylva","text":"<p>New version of Sylva documentation: Sylva documentation</p>"},{"location":"Docs/ToolChain/Vesyla/Cadfg/","title":"CADFG - Control Address Data-Flow Graph","text":"<p>CADFG is a DAG(directed acyclic graph)-based data structure used as an intermediate representation (IR) by Vesyla. Conventional High-level synthesis (HLS) tools typically model high-level program as control and dataflow graph (CDFG) as the intermediate representation (IR). This representation was appropriate because HLS tools synthesize an FSMD (FSM+Datapath) as the target architecture, deal with scalars and do not differentiate between functional, address and address constraints computation. Vesyla-II, in contrast generates distributed two-level FSM control scheme, deals with vectors and differentiates between the three categories of computation. These differences are reflected in the the IR used by Vesyla-II called Control, Address and Dataflow Graph (CADFG). CADFG is derived from the abstract syntax tree (AST). By a series of refinement, it transforms to Instruction Dependent Graph (IDG) as the back-end IR. In this section, we focus on elaborating some of the critical vertices of CADFG.</p>"},{"location":"Docs/ToolChain/Vesyla/Cadfg/#vertices","title":"Vertices","text":"<p>There are several broad categories of vertices in CADFG:</p> <ol> <li>Source and Sink vertices: create and terminate data flow.</li> <li>Read and Write vertices: slice vector to scalar and pack scalar to vector.</li> <li>Address and Address Constraint vertices: generates the address sequence for slicing and packing and address constraints.</li> <li>Function vertex: does general data computation.</li> <li>Control vertices: handle branches and loops.</li> </ol>"},{"location":"Docs/ToolChain/Vesyla/Cadfg/#source-and-sink-vertices","title":"Source and Sink Vertices","text":"<p>Source vertices doesn't have any input port and sink vertices doesn't have any output port. Both types of vertices support both vector and scalar data type. In figure ??, <code>p1</code> to <code>p5</code> and <code>X</code> are all source vertices, while <code>y</code> is sink vertex.</p>"},{"location":"Docs/ToolChain/Vesyla/Cadfg/#read-and-write-vertices","title":"Read and Write Vertices","text":"<p>Read vertex slices the vector variable to its each individual element and sending out them one at a time. On the contrary, write vertex packs the time distributed scalar data sequence to vector variable. Both vertices need an address vertex attach to them in order to decide the address sequence. In figure ??, vertex <code>R</code> is an example of read vertex.</p>"},{"location":"Docs/ToolChain/Vesyla/Cadfg/#address-and-address-constraint-vertices","title":"Address and Address Constraint Vertices","text":"<p>Address and Address Constraint Vertices are the key differentiator compared to conventional CDFGs. These vertices embody the policy of differentiating address and address constraints as separate computation category and mapping them to dedicated spatially distributed resources. This manifests in the read vertex getting its addresses from a function that models the address computation as a two-level affine function with five operands as shown and explained with an example in Figure ??. An implication of such an address function is that read vertex does not read a scalar but a vector. The address constraints are also explicitly identified to enable their computation to be also mapped to custom spatially distributed computation resource.</p> <p>In following figure, vertex <code>A</code> is an address vertex.</p> <p></p> <p>When Vesyla encounters higher order address functions beyond two levels affine function, it repeatedly computes the constraints of the inner two-level loops in a pipelined fashion. Computation in pipelined fashion deserves some explanation. Let us call one instance of innermost two loops as an epoch. While the functional computation and address computation of the innermost two loops are working on epoch i, the address constraints for the next epoch, i+1, are computed in parallel on an independent machine as shown in the following figure.</p> <p></p>"},{"location":"Docs/ToolChain/Vesyla/Cadfg/#function-vertex","title":"Function Vertex","text":"<p>Function vertices are responsible for the actual computation on input data. They are usually bind to arithmetic units inside DRRA cells. Function vertices only accept scalar inputs and generate scalar outputs. That's why we have the read and write nodes to break down the vector variables.</p> <p>Function vertex can be chained together to form more complex arithmetic operation.</p>"},{"location":"Docs/ToolChain/Vesyla/Cadfg/#control-vertex","title":"Control Vertex","text":"<p>Control vertices model the control hierarchy and in this respective they are similar to the control vertices in typical CDFGs. These vertices model the main algorithmic level control and not the control for fine grained address and address constraints computation. In CADFG, we do not have explicit control edges to model control dependencies. This is implicitly represented by the hierarchy of the control blocks. All nodes inside a control block are implicitly triggered if the control condition and the data dependency condition of the control block is fulfilled. When an algorithm is parallelized, parts of control hierarchy are replicated to represent the parallelism. Loops in Vesyla are not dynamic, they are either compile time or parametrically static. The latter implies that once the parameter for the loop bounds and increment are decided, these parameters remain static until the loop is complete. The dedicated resources for address constraints computation also serve to manage the loop parameters or constraints. For this reason, CADFG loop vertices are composite, i.e., they do not have any separate datapath vertex for loop condition comparison. Typical HLS tools, on the other hand, instantiate comparators and incrementors/adders to implement loop control verteices.</p> <p>Control Vertices include branch vertex, loop vertex, merge vertex, etc.</p>"},{"location":"Docs/ToolChain/Vesyla/Cadfg/#edges","title":"Edges","text":"<p>There are two broad categories of edges in CADFG:</p> <ol> <li>Dataflow edge: represents the flow of data, either scalar or vector.</li> <li>Dependency edge: represents the dependency relation between the predicessor and successor.</li> </ol>"},{"location":"Docs/ToolChain/Vesyla/Cadfg/#dataflow-edge","title":"Dataflow Edge","text":"<p>Like in conventional CDFG, dataflow edge shows the flow of data. It's a directed edge with predicessor and successor. Data flows from predicessor to successor. Dataflow edge can be either scalar or vector.</p> <p>Dataflow edge automatically embeds the information of dependency. The successor cannot be scheduled earlier than the predicessor.</p>"},{"location":"Docs/ToolChain/Vesyla/Cadfg/#dependency-edge","title":"Dependency Edge","text":"<p>Dependency edge is a more sophiscated way to describe dependencies among vertices. Vesyla uses dependency edges because in order to solve some hazzards such as \"WAR\" and \"WAW\",  extra dependency information is needed and these information can't be provided by normal dataflow edges.</p> <p>A dependency edge is also a directed edge. A timing period is associated with each dependency edge to indicate that the successor should start after the predicessor after some time t and t should be bounded by the timing period associated with the dependency edge.</p> <p>Each terminal of the edge also has a property indicating the moment the dependency edge will start to apply. The property can be PROCESS BEGIN or PROCESS END. Thus, a dependency edge a \\rightarrow{} b can express 4 different types of dependencies.</p> <ol> <li>b starts after a starts.</li> <li>b starts after a ends.</li> <li>b ends after a starts.</li> <li>b ends after a ends.</li> </ol>"},{"location":"Docs/ToolChain/Vesyla/Cadfg/#example","title":"Example","text":"<ol> <li>Lines 1 to 4 are the symbolic parameters that control the dimension of the algorithm and also the allocation and binding. These parameters influence the dimension of the CADFG. For instance, the parameter Col decides the degree of parallelism. The CADFG shown in figure corresponds to Col=1 case. If Col &gt; 1, Vesyla would replicate the CADFG Col times to represent the parallelism.</li> <li>Lines 5 to 8 define the allocation and binding for the storage. This information is stored as attributes in the source and destination nodes of the read/write nodes in the CADFG.</li> <li>Lines 9 to 16 decide the dimension and structure of the CADFG. The control hierarchy is represented by hierarchy of control blocks that serves as containers. In CADFG, there are no explicit control arcs but being inside a control block implies having a control arc from the parent control block. </li> <li>Line 9 refers to spatial iteration, i.e., parallelism and as stated above, decides the number of replications of CADFG. Line 10 is the highest control node that will be executed in each thread; CADFG in figure has a single thread with Col=1. Inside this control block, there are three sub-control blocks, each representing a vector operation on lines 11, 12 and 14. Two of these control blocks enclose read nodes and one write node. Besides these three read/write nodes, there is a functional computation node to represent the functionality on line 13.</li> <li>The read/write nodes that model the vector movement in lines 11, 12 and 14 all have the address and address constraints computation nodes for both LHS and RHS. Potentially, all three nodes could involve three sets of spatially distributed FSMs for address and address computations. Later, factoring in the allocation, binding and the data dependenncies, Vesyla synthesizes strucutures and details for scheduling and synchronizing these FSMs, some of them could be mapped to the same FSM.</li> <li>A simplification process in Vesyla transforms the symbolic expressions in Matlab to numerical values for loop and address constraints. A boxed note in figure explains one such example for address constraints for LHS of line 11.</li> <li>In the example under consideration, there is only one functional computation node on line 13 and as can be seen its inputs and outputs are also vectorizing read/write nodes. Also, the functional computational node is also associated with an allocation and binding pragmas that is duly recorded as part of building the CADFG.</li> <li>While building the CADFG, Vesyla, like other HLS tools also creates explicit data dependencies that crosses control block boundaries. Vesyla also detect hazards and records them with additional dependency arcs. This is explained next.</li> </ol>"},{"location":"Docs/ToolChain/Vesyla/DependencyAnalysis/","title":"Dependency Analysis","text":"<p>Dependencies created in CADFG don't take the address range of vector variable read/write operations into account. To add such information and fine tune the dependencies, we need to have this dependency analysis process. Here, dependency analysis only refers to the dependency checking for vector operations.</p> <p>Data dependencies between vector variables are more complex than scalar variables because it not only involves the variables but also their read and write access patterns. There are many sophisticated techniques to analyse dependencies among vector operations. Many great works have been done in this research field. However, Vesyla, as a proof-of-concept tool, doesn\u2019t explore all those advanced methods for optimization purpose. It broadly categorizes data dependency among vector variables as strong dependency, weak dependency and fake dependency. Strong dependency requires the successor starts no earlier than the end of its predecessor. Weak dependency only requires the successor starts no earlier than the start of its predecessor. Fake dependency indicates there is no actual data hazard between predecessor and successor, the dependency edge can be removed.</p> <p>As shown in the following figure, If the predecessor and successor of a dependency edge has non-overlapping access patterns the dependency edge is fake because the two nodes will never access the same location. If the predecessor and successor have the same pattern or the successor has a pattern that is a simple shift of the predecessor pattern, the dependency is weak because the predecessor will always access the location before the successor, thus the successor can start one cycle later than the starting of predecessor. For all other cases, Vesyla-II considers the dependency edge strong since this is the most conservative assumption.</p> <p></p>"},{"location":"Docs/ToolChain/Vesyla/DiMArch/","title":"DiMArch Reading and Writing","text":"<p>To read from DiMArch cell or write to DiMArch cell, we need several collaborating instructions. They are <code>ROUTE</code> instruction, <code>REFI</code> instruction and <code>SRAM_R</code>/<code>SRAM_W</code> instruction.</p>"},{"location":"Docs/ToolChain/Vesyla/DiMArch/#read-dimarch-register-file","title":"Read (DiMArch -&gt; Register file)","text":"<p>When reading from DiMArch to Register file, a path should be routed first by <code>ROUTE</code> instruction. <code>ROUTE</code> instruction has 2 critical timestamps: issue and end. <code>ROUTE</code> instruction will occupy the DiMArch NoC resource of all cells on the routed path until it's end timestamp reached.</p> <p>During the time when the DiMArch NoC path is guaranteed by <code>ROUTE</code> instruction, a <code>SRAM_R</code> instruction is applied to configure the AGU on DiMArch side. <code>SRAM_R</code> instruction has 4 critical timestamps: issue, arrive, active and end. Issue time represents the cycle when sequencer issue the instruction, arrive time represents the instruction reaches the destination DiMArch cell, active time represents the time point when the instruction starts outputing readed data, and end time indicates the instruction stops reading data.</p> <p>At the same time, a <code>REFI</code> instruction should be activated in order to store the data from DiMArch to register file entries. <code>REFI</code> instruction has 3 critical timestamps: issue, active and end.</p> <p>The timing relationship of those 3 instructions are shown in figure below:</p> <p>{% dot sram_read_dep.svg     digraph G {         subgraph cluster_route{           label=\"ROUTE\"           route_issue [label=\"issue\"];           route_end [label=\"end\"];           route_issue -&gt; route_end [label=\"&gt;0\"]         }         subgraph cluster_sram{           label=\"SRAM_R\"           sram_issue [label=\"issue\"];           sram_arrive [label=\"arrive\"];           sram_active [label=\"active\"];           sram_end [label=\"end\"];           sram_issue -&gt; sram_arrive [label=\"=(#hop+1)\"];           sram_arrive -&gt; sram_active [label=\"=0\"];           sram_active -&gt; sram_end [label=\"=#element\"];         }         subgraph cluster_refi{           label=\"REFI\"           refi_issue [label=\"issue\"];           refi_active [label=\"active\"];           refi_end [label=\"end\"];           refi_issue -&gt; refi_active [label=\"&gt;=0\"];           refi_active -&gt; refi_end [label=\"=#element\"];         }         route_issue -&gt; sram_issue [label=\"&gt;0\"];         route_issue -&gt; refi_issue [label=\"&gt;0\"];         sram_end -&gt; route_end [label=\"&gt;=0\"];         refi_end -&gt; route_end [label=\"&gt;=0\"];         sram_active -&gt; refi_active[label=\"=#hop\"]     } %}</p>"},{"location":"Docs/ToolChain/Vesyla/DiMArch/#write-register-file-dimarch","title":"Write (Register file -&gt; DiMArch)","text":"<p>Writing data from Register file to DiMArch share the same set of instruction with the same timestamps as reading operation. The only difference comes from the dependency arrows.</p> <p>The timing relationship of those 3 instructions are shown in figure below:</p> <p>{% dot sram_write_dep.svg     digraph G {         subgraph cluster_route{           label=\"ROUTE\"           route_issue [label=\"issue\"];           route_end [label=\"end\"];           route_issue -&gt; route_end [label=\"&gt;0\"]         }         subgraph cluster_sram{           label=\"SRAM_R\"           sram_issue [label=\"issue\"];           sram_arrive [label=\"arrive\"];           sram_active [label=\"active\"];           sram_end [label=\"end\"];           sram_issue -&gt; sram_arrive [label=\"=(#hop+1)\"];           sram_arrive -&gt; sram_active [label=\"=0\"];           sram_active -&gt; sram_end [label=\"=#element\"];         }         subgraph cluster_refi{           label=\"REFI\"           refi_issue [label=\"issue\"];           refi_active [label=\"active\"];           refi_end [label=\"end\"];           refi_issue -&gt; refi_active [label=\"&gt;=0\"];           refi_active -&gt; refi_end [label=\"=#element\"];         }         route_issue -&gt; sram_issue [label=\"&gt;0\"];         route_issue -&gt; refi_issue [label=\"&gt;0\"];         sram_end -&gt; route_end [label=\"&gt;=0\"];         refi_end -&gt; route_end [label=\"&gt;=0\"];         refi_active -&gt; sram_active[label=\"=#hop\"]     } %}</p>"},{"location":"Docs/ToolChain/Vesyla/ExpressionSimplification/","title":"Expression Simplification","text":""},{"location":"Docs/ToolChain/Vesyla/ExpressionSimplification/#algorithm","title":"Algorithm","text":""},{"location":"Docs/ToolChain/Vesyla/ExpressionSimplification/#perserving-dependency-edges","title":"Perserving Dependency Edges","text":""},{"location":"Docs/ToolChain/Vesyla/Hazzard/","title":"Hazard","text":"<p>Here we only talk about data hazards.</p>"},{"location":"Docs/ToolChain/Vesyla/Hazzard/#standard-hazards","title":"Standard Hazards","text":"<p>A data hazard is created whenever there is a dependence between data read and/or write operations. Without such dependency information perserved by some proper format, the data access order might be different from the intended order expressed by the programmer in source code thus might lead to unintended output. The goal of harzard detection is to exploit parallesism by perserving data access order only where it affects the outcome of the program. Data hazard can be categorized as Read-After-Write (RAW), Write-After-Write (WAW) and Write-After-Read (WAR). For out-of-order issue hardware or compiler that exploits instruction execution order all three types of hazard can happen. Therefore, we need to preserve the dependency information in order to avoid those hazards.</p>"},{"location":"Docs/ToolChain/Vesyla/Hazzard/#hazards-in-vector-machine-and-vesyla","title":"Hazards in Vector Machine and Vesyla","text":"<p>In vesyla, the case for RAW is simple. It will be directly absorbed by the data dependency edge that is anyway created. WAR and WAW, requires creation of additional special edges to indicate that there are data dependencies. Data hazards for vector variables are different from those for scalar variables. For example, in the following figure, a WAW dependency is not necessary for scalar variables because the first \u201cWrite\u201d operation can\u2019t affect the final result of that scalar variable hence can be directly removed. While for vector variables, WAW dependency is absolutely necessary, because those two \u201cWrite\u201d operations might write to different part of the vector therefore both will influence the final result of the vector variable.</p> <p></p> <p>Different from scalar machine, vector machine need extra information to create dependencies. Vector operations usually last for some time period. The dependencies between vector operations need to specify which timing point they are referring to. Specifically, the start and end time of a vector operation are important. Regarding just start and end time of vector operations, we can create 4 types of dependencies:</p> <ol> <li>Dependency between the start of predicessor and the start of successor.</li> <li>Dependency between the start of predicessor and the end of successor.</li> <li>Dependency between the end of predicessor and the start of successor.</li> <li>Dependency between the end of predicessor and the end of successor.</li> </ol> <p>Data dependency analysis technique can be found in section Dependency Analysis.</p>"},{"location":"Docs/ToolChain/Vesyla/Idg/","title":"IDG - Instruction Dependency Graph","text":""},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/","title":"Instruction Set","text":""},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#instructions","title":"Instructions","text":""},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#0000-halt","title":"0000 HALT","text":"<pre><code>26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n</code></pre> Field Position Width Range/Value Description instr_code [26, 23] 4 b'0000 HALT instruction code unused [22, 0] 23 0 Unused"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#0001-refi","title":"0001 - REFI","text":"<pre><code>26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n0  0  0  1  A  A  B  B  C  D  D  D  D  D  D  E  F  F  F  F  F  F  G  H  H  H  H\n0  0  1  0  I  J  J  J  J  J  J  K  L  M  M  M  M  M  N  N  N  N  N  O  O  O  O\n0  0  1  1  P  Q  Q  Q  Q  Q  Q  0  0  0  0  0  0  R  R  S  T  T  0  0  0  U  V\n</code></pre> Field Position Width Range/Value Description instr_code [26, 23] 4 b'0001 REFI1 instruction code port_no [22, 21] 2 [0, 3] Selects one of the RFile ports extra [20, 19] 2 [0, 3] How many following instructions. init_addr_sd 18 1 [0, 1] [0] init_addr is static; [1] init_addr is from RACCU. init_addr [17, 12] 6 [0, 63] Static init address or RACCU register. l1_iter_sd 11 1 [0, 1] [0] Level 1 iteration is static; [1] L1 iteration is from RACCU. l1_iter [10, 5] 6 [0, 63] Static L1 iteration or RACCU register. init_delay_sd 4 1 [0, 1] [0] init_delay is static; [1] init_delay is from RACCU. init_delay [3, 0] 4 [0, 15] Static init delay or RACCU register. unused [26, 23] 4 b'0010 Deprecated l1_step_sd [22] 1 [0, 1] [0] l1_step is static; [1] l1_step is from RACCU l1_step [21, 16] 6 [0, 63] Static level 1 step value or RACCU register l1_step_sign [15] 1 [0, 1] Sign bit of l1_step l1_delay_sd [14] 1 [0, 1] [0] l1_delay is static; [1] l1_delay is from RACCU l1_delay [13, 10] 4 [0, 15] Static level 1 delay or RACCU register l2_iter_sd [9] 1 [0, 1] [0] l2_iter is static; [1] l2_iter is from RACCU l2_iter [8, 4] 5 [0, 31] Static level 2 iteration or RACCU register l2_step [3, 0] 4 [0, 15] Level 2 step value unused [26, 23] 4 b'0011 Deprecated l2_delay_sd [22] 1 [0, 1] [0] l2_delay is static; [1] l2_delay is from RACCU. l2_delay [21, 16] 6 [0, 63] Static level 2 delay or RACCU register. unused [15, 10] 6 0 Deprecated l1_delay_ext [9, 8] 2 [0, 3] Extended bits for l1_delay l2_iter_ext [7] 1 [0, 1] Extended bits for l2_iter l2_step_ext [6, 5] 2 [0, 3] Extended bits for l2_step unused [4, 2] 3 0 Deprecated dimarch [1] 1 [0, 1] [0] Not DiMArch; [1] DiMArch mode compress [0] 1 [0, 1] [0] Not compressed; [1] Compressed"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#0100-dpu","title":"0100 - DPU","text":"<pre><code>26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n0  1  0  0  A  A  A  A  A  B  B  C  C  D  D  E  F  G  G  G  G  G  G  G  G  H  H\n</code></pre> Field Position Width Range/Value Description instr_code [26, 23] 4 b'0100 DPU instruction code mode [22, 18] 5 [0, 12] Configures the valid dpu mode control [17, 16] 2 [0, 3] [00] no saturation, integer; [01] no saturation, fixed-point; [10] saturation, integer; [11] saturation, fixed-point. not_used [15, 10] 6 b'000010 Deprecated acc_clear [9, 2] 8 [0, 255] The DPU accumulator register clear threshold. io_change [1, 0] 2 [0, 3] [00] no change; [01]negate in1; [10] negate in2; [11] return abosolute value of output."},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#0101-swb","title":"0101 SWB","text":"<pre><code>26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n0  1  0  1  1  A  B  C  D  D  D  E  F  F  F  0  0  0  0  0  0  0  0  0  0  0  0\n</code></pre> Field Position Width Range/Value Description instr_code [26, 23] 4 b'0110 SWB instruction code active [22] 1 1 Deprecated, always 1 src_row [21] 1 [0, 1] The source DRRA row src_block [20] 1 [0, 1] [0] RF; [1] DPU src_port [19] 1 [0, 1] Source port number hb_index [18, 16] 3 [0, 6] Index of horizontal bus send_to_other_row [15] 1 [0, 1] Flag of whether src and dest row are equal v_index [14, 12] 3 [0, 5] Index of vertical bus unused [11, 0] 12 0 Deprecated"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#0110-jump","title":"0110 JUMP","text":"<pre><code>26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n0  1  1  0  A  A  A  A  A  A  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n</code></pre> Field Position Width Range/Value Description instr_code [26, 23] 4 b'0110 JUMP instruction code pc [22, 17] 6 [0, 63] The target address unused [16, 0] 17 0 Deprecated"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#0111-wait","title":"0111 WAIT","text":"<pre><code>26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n0  1  1  1  A  B  B  B  B  B  B  B  B  B  B  B  B  B  B  B  0  0  0  0  0  0  0\n</code></pre> Field Position Width Range/Value Description instr_code [26, 23] 4 b'0111 DELAY instruction code cycle_sd [22] 1 [0, 1] [0] cycle is static; [1] cycle is from RACCU cycle [21, 7] 15 [0, 32767] Static cycle or RACCU register unused [6, 0] 7 0 0"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#1000-loop","title":"1000 LOOP","text":"<pre><code>26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n1  0  0  0  A  B  B  C  C  C  C  C  C  D  E  E  E  E  E  E  F  G  G  G  G  G  G\nH  I  I  I  I  I  I  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n</code></pre> Field Position Width Range/Value Description instr_code [53, 50] 4 b'1000 LOOPH instruction code extend [49] 1 [0, 15] 0:No extension; 1:Extended loopid [48, 47] 2 [0, 3] The id of nested loops endpc [46, 41] 6 [0, 63] The PC where loop ends start_sd [40] 1 [0, 1] 0:start is static; 1: start is from RACCU start [39, 34] 6 [-32, 31] Start address, either static or from RACCU iter_sd [33] 1 [0, 1] 0:iter is static; 1: iter is from RACCU iter [32, 27] 6 [0, 63] Iteration, either static or from RACCU step_sd [26] 1 [0, 1] / 0 0:step is static; 1: step is from RACCU step [25, 20] 6 [0, 63] / 1 Step, either static or from RACCU unused [19, 0] 20 0 Unused"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#1010-raccu","title":"1010 RACCU","text":"<pre><code>26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n0  1  1  1  A  A  A  B  C  C  C  C  C  C  C  D  E  E  E  E  E  E  E  F  F  F  F\n</code></pre> Field Position Width Range/Value Description instr_code [26, 23] 4 b'1010 RACCU instruction code mode [22, 20] 3 [0, 7] Operation mode operand1_sd [19, 19] 1 [0, 1] [0] operand1 is static; [1] operand1 is from RACCU register operand1 [18, 12] 7 [-64, 63] Operand 1 operand2_sd [11, 11] 1 [0, 1] [0] operand2 is static; [1] operand2 is from RACCU register operand2 [10, 4] 7 [-64, 63] Operand 2 result [4, 0] 4 [0, 15] Result register address"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#1011-branch","title":"1011 BRANCH","text":"<pre><code>26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n0  1  1  1  A  A  B  B  B  B  B  B  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n</code></pre> Field Position Width Range/Value Description instr_code [26, 23] 4 b'1011 BRANCH instruction code mode [22, 21] 2 [0, 4] The conditional branch mode false_pc [20, 15] 6 [0, 63] Configures the false address unused [14, 0] 15 0 Deprecated"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#1100-route","title":"1100 ROUTE","text":"<pre><code>26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n0  1  1  1  A  B  B  B  C  D  D  D  0  0  0  0  0  0  E  0  0  0  0  0  0  0  0\n</code></pre> Field Position Width Range/Value Description instr_code [26, 23] 4 b'1100 ROUTE instruction code src_row [22] 1 [0, 1] Source DiMArch row src_col [21, 19] 3 [0, 7] Source DiMArch column dest_row [18] 1 [0, 1] Destination DiMArch row dest_col [17, 15] 3 [0, 7] Destination DiMArch column unused [14, 9] 6 0 Deprecated select_drra_row [8] 1 [0, 1] [0] source is origin; [1] destination is origin unused [7, 0] 8 0 Deprecated"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#1101-sram","title":"1101 SRAM","text":"<pre><code>26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n1  1  0  1  A  B  B  B  B  B  B  B  C  C  C  C  D  D  D  D  D  D  D  E  E  E  E\nE  E  E  E  F  F  F  F  F  F  G  G  G  G  G  G  G  H  H  H  H  H  H  H  H  I  I\nI  I  I  I  J  K  L  M  N  O  P  Q  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n</code></pre> Field Position Width Range/Value Description instr_code [80, 77] 4 b'1101 SRAMR instruction code rw [76] 1 [0, 1] Read or Write init_addr [75, 69] 7<sup>*</sup> [0, 127] Initial address init_delay [68, 65] 4 [0, 15] Initial delay l1_iter [64, 58] 7<sup>*</sup> [0, 127] Level 1 iteration l1_step [57, 50] 8<sup>*</sup> [-128, 127] Level 1 step l1_delay [49, 44] 6 [0, 63] Level 1 delay l2_iter [43, 37] 7<sup>*</sup> [0, 127] Level 2 iteration l2_step [36, 29] 8<sup>*</sup> [-128, 127] Level 2 step l2_delay [28, 23] 6 [0, 63] Level 2 delay init_addr_sd [22] 1 [0, 1] Static or from RACCU l1_iter_sd [21] 1 [0, 1] Static or from RACCU l2_iter_sd [20] 1 [0, 1] Static or from RACCU init_delay_sd [19] 1 [0, 1] Static or from RACCU l1_delay_sd [18] 1 [0, 1] Static or from RACCU l2_delay_sd [17] 1 [0, 1] Static or from RACCU l1_step_sd [16] 1 [0, 1] Static or from RACCU l2_step_sd [15] 1 [0, 1] Static or from RACCU unused [14, 0] 15 0 Unused <p><sup>*</sup> The number of bits of the marked fields depends on the size of the SRAM. The current number are set according to a 128 row SRAM, each row is of 256 bits.</p>"},{"location":"Docs/ToolChain/Vesyla/Overview/","title":"Overview","text":"<p>Warning</p> <p>Documentation is not complete!</p>"},{"location":"Docs/ToolChain/Vesyla/Scheduling/","title":"Scheduling","text":""},{"location":"Docs/ToolChain/Vesyla/Scheduling/#problem-defination","title":"Problem Defination","text":"<p>In Vesyla, the generated instructions have fairly long life-time and are highly cooperative. Which means they are not just single-cycle actors with simple precedency relation that fight for resources. Instructions running in DRRA microthreads might actively coordinate themselves with other instructions executing in some other microthreads. Cooperation with other instructions can happen at any time when an instruction is alive and it can happen multiple times with multiple different other instructions. Further more, the life-time of an instruction in Vesyla can be undetermined and depend on other instructions in terms of both precedency relation and resource availability.</p> <p>To simplify the scenario a little bit, we consider the critical points of those instructions as the atomic unit objects (jobs/actors/operations) that need to be scheduled in the cooperative instruction scheduling problem which will be defined later. What are the critical points? They can be starting and ending point of instructions. They can be the time points when a instruction change its resource usage. They can be the time points when a instruction need to coordinate with other instructions. In short, whenever an instruction changes anything, it's a critical point. Critical points don't have execution duration, it just represents a timestamp. However, critical points can have resoure usage attached to it. Resource usage requires time duration.</p> <p>With the usage of critical points, a new phenominal appears. Some instructions can have undetermined life-time before scheduling. When those instructions are broken down into critical points, the resource usage of those critical points need special treatment since their usage duration are undetermined. We need to assign a LOCK resource usage frame to the critical point starting to use the resource and a KEY resource usage frame to the critical point finishing to use the resource. The resource between LOCK and KEY frame during scheding should be marked unavailable to other critical points.</p> <p>Cooperative instruction scheduling problem thus is very different from the classic instruction scheduling problem. In classic instruction scheduling problem, either positive or negative time-lag exists between a pair of instructions. While between a cooperative critical points pair, both minimal and maximum time-lag may exist, which constrants the precedence relation to a possibly closed time frame. A special case is when minimal and maximum time-lag are equal, representing the two critical points will have an exact time difference. The introduce of LOCK and KEY frame for resource usage is also very different from conventional instruction scheduling problem.</p> <p>Now, we formally define the scheduling model and the scheduling problem.</p> <p>Warning</p> <p>MODEL AND PROBLEM DEFINATION</p>"},{"location":"Docs/ToolChain/Vesyla/Scheduling/#problem-simplification","title":"Problem Simplification","text":"<p>The scheduling model defined above can not be used directly because it's high complexity creates a vast solution space and scheduling algorithm will have hard time to navigate to the correct direction.</p> <p>Therefore, we propose one assumption and four simplification step to simplify the model. The simplification processes transform the model to equivalent but simpler model hence shrink the solution space.</p>"},{"location":"Docs/ToolChain/Vesyla/Scheduling/#delay-bound-assumption","title":"Delay bound assumption","text":"<p>Delay bounds of an edge in depenency graph can be either negative or positive as long as the higher bound d_h is not less than lower bound d_l. An edge with d_l=-\\infty or with d_l\\le d_h \\lt 0 can be easily converted to an edge with d_l\\neq -\\infty and d_h\\ge 0. Therefore, we assume that: every edge in dependency graph will have a delay bounds satisfying d_l\\neq -\\infty, d_h\\ge 0 and d_l\\le d_h.</p>"},{"location":"Docs/ToolChain/Vesyla/Scheduling/#parking-hard-links","title":"Parking Hard-links","text":"<p>Hard-links are edges with constant delay (d_l=d_h). For example, A\\xrightarrow[]{\\text{[w,w]}}B is a hard-link, it describs the constraint that the schedule time of B is exactly w cycles after the schedule time of A.</p> <p>All vertices linked by hard-links should be scheduled together, because if any vertex has been scheduled, the schedule time of other vertices which directly or indirectly linked to the scheduled vertex can be determined immediately. Therefore, packing hard-linked vertices together can reduce the size of graph and accelerate the scheduling process.</p> <p>Pseudo Algorithm is shown below:</p> <pre><code>Graph packing_hard_links(Graph g){\n    Graph g1 = remove_soft_links(g);\n    Component C = find_connected_components(g1);\n    Graph g2;\n    for(auto c : C){\n        vector&lt;Vertex, int&gt; offset_map = find_offset_for_each_vertex(c);\n        Vertex vc;\n        Graph g3;\n        for(auto v : c.vertices()){\n            v.schedule_time = offset_map(v);\n            g3.add_vertex(v);\n        }\n        vc.add_child(g3)\n        g2.add_vertex(vc);\n    }\n    for(auto e: edges(g)){\n        if(is_soft_link(e) &amp;&amp; in_different_component(e.src, e.dest)){\n            Edge e1 = reshape_edge_accroding_to_g2(e);\n            g2.add_edge(e1);\n        }\n    }\n    return g2;\n}\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla/Scheduling/#remove-redundant-edges","title":"Remove Redundant Edges","text":"<p>When analyzing the weighted edges in dependency graph (DG), it's easy to discover that there are some edges that have very relatexed constraints which can be removed completely without loosing any synchronization constraint information of the original DG. Example below illustrate such scenario.</p> <p>{% dot schedule_remove_redundant_edges.svg     digraph G {           rankdir=\"LR\";           u -&gt; v [label=\"[1, 5]\"];           u -&gt; w [label=\"[1, 2]\"];           w -&gt; v [label=\"[0, 1]\"];     } %}</p> <p>From the path u \\rightarrow v, assuming u starts at t_0, v should start at the time period [t_0+1,t_0+5]. While from the path u \\rightarrow w \\rightarrow v, v should start at the time period [t_0+1,t_0+3]. It's obvious that period [t_0+1,t_0+5] is more relaxed thatn period [t_0+1,t_0+3]. The path u \\rightarrow v doesn't add any addtition information, hence, can be removed.</p>"},{"location":"Docs/ToolChain/Vesyla/Scheduling/#negative-edge-weight-adjustment","title":"Negative Edge Weight Adjustment","text":"<p>In DG, weight can be period with negative integers. Therefore, if there is an edge u \\xrightarrow[]{\\text[-2,2]} v, though graphically the edge point from u to v, it doesn't necessarily mean that after scheduling, v is scheduled after u. The inconsistancy between graph representation and the actual meaning of the weighted edge cause some troubles during later process. It would be much better if we can find a way to make them consistant.To adjust the weight of edges, the goal is to guarantee the weight period are strictly positive numbers.</p> <p>Reader should keep in mind  what are the vertices in DG. They are just timestamp marking the critical time of each operation. There may be resource occupation table (ROT) attach to them. Suppose we have an edge like as following:</p> <p>{% dot schedule_edge_weight_adjustment_0.svg     digraph G {           rankdir=\"LR\";           u [label=\"u\"];           v [label=\"v\"];           u -&gt; v [label=\"[-2, 2]\"];     } %}</p> <p>We can insert a dummy vertex d with no ROT attach to it before u with exactly 3 cycles ahead.</p> <p>{% dot schedule_remove_edge_weight_adjustment_1.svg     digraph G {           rankdir=\"LR\";           d [label=\"d\"];           u [label=\"u\"];           v [label=\"v\"];           d -&gt; u [label=\"[3,3]\"];           u -&gt; v [label=\"[-2, 2]\"];     } %}</p> <p>The edge u \\rightarrow v can be replaced by a new edge d \\rightarrow v.</p> <p>{% dot schedule_remove_edge_weight_adjustment_2.svg     digraph G {           rankdir=\"LR\";           d [label=\"d\"];           u [label=\"u\"];           v [label=\"v\"];           d -&gt; u [label=\"[3,3]\"];           d -&gt; v [label=\"[1, 5]\"];     } %}</p> <p>Edge d \\rightarrow u is always a hard edge, we can merge vertex d and u to a new vertex u' with shifted ROT_u as its attached ROT.</p> <p>{% dot schedule_edge_weight_adjustment_3.svg     digraph G {           rankdir=\"LR\";           u [label=\"u'\"];           v [label=\"v\"];           u -&gt; v [label=\"[1, 5]\"];     } %}</p> <p>In this way, every negative numbered weight can be converted to positive weight in DG.</p>"},{"location":"Docs/ToolChain/Vesyla/Scheduling/#resource-hazard-prediction","title":"Resource Hazard Prediction","text":"<p>A well defined program will always have LOCK/KEY frame pair for any resource. A resource should never been locked and there is no KEY frame to unlock it, or vice versa. Different LOCK/KEY pair targeting the same resource will conflict with each other due to the resource occupation. The resource harzard should be resolved by scheduling via time multiplexing. However, in some scenario, if the scheduler don't schedule the vertices in a specific order, the scheduling might lead to unschduable situation due to resource occupation deadlock. Some exploration algorithms such as LIST scheduling engine might fail. While other scheduling engine such as Branch-and-Bound might stack to some corner space exploring for a very long time in order to find a valid suliton. The following example clearly shows such scenario.</p> <p>{% dot schedule_resource_hazard_0.svg     digraph G {           rankdir=\"LR\";           a [label=\"a / LOCK\u00ae\"];           b [label=\"b / KEY\u00ae\"];           c [label=\"c / LOCK\u00ae\"];           d [label=\"d / KEY\u00ae\"];           e [label=\"e\"];           f [label=\"f\"];           g [label=\"g\"];           h [label=\"h\"];           a -&gt; b;           c -&gt; f -&gt; g -&gt; h -&gt; d;           b -&gt; e -&gt; d;     } %}</p> <p>Vertex c can be chosen by the scheduler to schedule first because it don't have any dependency from other vertices. The naturally, f, g, h can be scheduled. But d can not be scheduled because e is not scheduled. e can not be scheduled because a can't be scheduled due to resource r is locked by c. And r is not can't be freed because d can't be scheduled. This is a deadlock and will make this scheduling unfeasible. In order to correct the mistake, the scheduler (for example Branch-and-Bound) will try to trace back and to the step of scheduling h, then trace back again to g. Until it back-tracks to c, the very first scheduling step, the scheduler can't correct the mistake.</p> <p>To solve such problem, we need to predict the scheduling order. By analyzing the graph structure, we should be able to conclude that c should be scheduled after than b. We then force a constraint edge to explictly represent such scheduling order in order to help the later exploring phase. The dependency graph after hazard prediction will be look like this:</p> <p>{% dot schedule_resource_hazard_0.svg     digraph G {           rankdir=\"LR\";           a [label=\"a / LOCK\u00ae\"];           b [label=\"b / KEY\u00ae\"];           c [label=\"c / LOCK\u00ae\"];           d [label=\"d / KEY\u00ae\"];           e [label=\"e\"];           f [label=\"f\"];           g [label=\"g\"];           h [label=\"h\"];           a -&gt; b;           c -&gt; f -&gt; g -&gt; h -&gt; d;           b -&gt; e -&gt; d;           b -&gt; c;     } %}</p>"},{"location":"Docs/ToolChain/Vesyla/Scheduling/#solution-space-exploration","title":"Solution Space Exploration","text":"<p>Scheduling is an NP-Complete problem. To find a valid solution for dependency graph, we need some solution searching engine or hierustic scheduling algorithm. Branch-and-Bound, Constriant Programming, LIST algorithm, Simulated Annening, etc are such searching engines. In this section, we introduce two searching engine as an example to demonstrate how does the solution space exploration works.</p>"},{"location":"Docs/ToolChain/Vesyla/Scheduling/#list-scheduling-algorithm","title":"LIST Scheduling Algorithm","text":""},{"location":"Docs/ToolChain/Vesyla-suite/Overview/","title":"Vesyla-suite Overview","text":""},{"location":"Docs/ToolChain/Vesyla-suite/Overview/#version-4-current","title":"Version 4 (Current)","text":""},{"location":"Docs/ToolChain/Vesyla-suite/Overview/#tool-collection","title":"Tool collection","text":"<ul> <li>vs-manas</li> <li>vs-alimpsim</li> <li>vs-init</li> <li>vs-testcase</li> </ul>"},{"location":"Docs/ToolChain/Vesyla-suite/Overview/#installation-and-usage","title":"Installation and Usage","text":""},{"location":"Docs/ToolChain/Vesyla-suite/Overview/#installation-on-mozzarella-and-cheddar","title":"Installation on Mozzarella and Cheddar","text":"<p>Vesyla-suite version 4 has already been installed on both Mozzarella and Cheddar.</p> <p>To access vesyla-suite commands, you need to first load the vesyla-suite module by command:</p> <pre><code>module load vesyla-suite/4\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/Overview/#tutorial","title":"Tutorial","text":"<p>See DRRA-based AlImp Design Tutorial.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/Overview/#version-3-deprecated","title":"Version 3 (Deprecated)","text":""},{"location":"Docs/ToolChain/Vesyla-suite/Overview/#tool-collection_1","title":"Tool collection","text":"<ul> <li>vs-vesyla</li> <li>vs-manas</li> <li>vs-alimpsim</li> <li>vs-init</li> <li>vs-expand</li> <li>vs-imecc</li> <li>vs-testcase</li> </ul>"},{"location":"Docs/ToolChain/Vesyla-suite/Overview/#installation-and-usage_1","title":"Installation and Usage","text":""},{"location":"Docs/ToolChain/Vesyla-suite/Overview/#installation-on-mozzarella","title":"Installation on Mozzarella","text":"<p>Vesyla-suite version 3 has already been installed on Mozzarella.</p> <p>To access vesyla-suite commands, you need to first load the vesyla-suite module by command:</p> <pre><code>module load vesyla-suite/3\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/Overview/#docker","title":"Docker","text":"<p>See Installation</p>"},{"location":"Docs/ToolChain/Vesyla-suite/Overview/#compile-from-source","title":"Compile from Source","text":"<p>See Installation</p>"},{"location":"Docs/ToolChain/Vesyla-suite/Overview/#tutorial_1","title":"Tutorial","text":"<p>See DRRA-based AlImp Design Tutorial and RISCV-based AlImp Design Tutorial.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/Overview/#programming-guide","title":"Programming Guide","text":"<p>See Vesyla Programming Guide</p>"},{"location":"Docs/ToolChain/Vesyla-suite/Overview/#version-2-deprecated","title":"Version 2 (Deprecated)","text":"<p>Vesyla-suite version 2 is used for compiling Matlab code to DRRA and DiMArch based SiLago fabric. It does not support general input and output buffer for application-level synthesis. This version is deprecated and will be removed soon. You should only use it for old project such as DRRA characterization.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/Overview/#tool-collection_2","title":"Tool collection","text":"<ul> <li>vesyla</li> <li>manas</li> </ul>"},{"location":"Docs/ToolChain/Vesyla-suite/Overview/#usage","title":"Usage","text":""},{"location":"Docs/ToolChain/Vesyla-suite/Overview/#installation-on-mozzarella_1","title":"Installation on Mozzarella","text":"<p>Vesyla-suite version 2 has already been installed on Mozzarella. Since it's a deprecated version, you shouldn't try to compile it by yourself. Just use the installed instance on Mozzarella.</p> <p>To access vesyla-suite commands, you need to first load the vesyla-suite module by command:</p> <pre><code>module load vesyla-suite/2\n</code></pre> <p>Now you should be able to access <code>vesyla</code> and <code>manas</code> command.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/Overview/#tutorial_2","title":"Tutorial","text":"<p>See Turorial v2 for vesyla and manas version 2.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/Overview/#programming-guide_1","title":"Programming Guide","text":"<p>See Vesyla Programming Guide v2</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/","title":"Instruction Set (v2)","text":"<p>Warning</p> <p>This is an old version of the instruction set. Please refer to Instruction Set (v3) for the latest version.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/#instructions","title":"Instructions","text":"<p>Note</p> <p>Instruction fields marked by bold font are controllable and observable. Users can modify these fields in Manas input file.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/#halt","title":"HALT","text":"Field Position Width Default Value Description instr_code [26, 23] 4 0 Instruction code for HALT"},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/#refi","title":"REFI","text":"Field Position Width Default Value Description instr_code [80, 77] 4 1 Instruction code for REFI port_no [76, 75] 2 0 Selects one of the RFile port. [0]:w0; [1]:w1; [2]:r0; [3]:r1; extra [74, 73] 2 0 How many following chunks? init_addr_sd [72, 72] 1 0 Is init_addr static or dymamic? [0]:s; [1]:d; init_addr [71, 66] 6 0 Initial address. l1_iter [65, 60] 6 0 Level-1 iteration - 1. init_delay [59, 54] 6 0 Initial delay. l1_iter_sd [53, 53] 1 0 Is level-1 iteration static or dymamic? [0]:s; [1]:d; init_delay_sd [52, 52] 1 0 Is initial delay static or dynamic? [0]:s; [1]:d; unused_0 [51, 50] 2 2 Deprecated. l1_step_sd [49, 49] 1 0 Is level-1 step static or dynamic? [0]:s; [1]:d; l1_step [48, 43] 6 1 Level-1 step l1_step_sign [42, 42] 1 0 The sign of level-1 step. [0]:+; [1]:-; l1_delay_sd [41, 41] 1 0 Is the level-1 delay static or dynamic? [0]:s; [1]:d; l1_delay [40, 37] 4 0 The level-1 delay, middle delay l2_iter_sd [36, 36] 1 0 Is level-2 iteration static or dymamic? [0]:s; [1]:d; l2_iter [35, 31] 5 0 The level-2 iteration - 1. l2_step [30, 27] 4 1 The level-2 step. unused_1 [26, 23] 4 3 Deprecated. l2_delay_sd [22, 22] 1 0 Is the level-2 delay static or dynamic? [0]:s; [1]:d; l2_delay [21, 16] 6 0 The level-2 delay, repetition delay. unused_2 [15, 10] 6 0 Deprecated. l1_delay_ext [9, 8] 2 0 The extened bits near MSB of l1_delay. l2_iter_ext [7, 7] 1 0 The extened bits near MSB of l2_iter. l2_step_ext [6, 5] 2 0 The extened bits near MSB of l2_step. unused_3 [4, 2] 3 0 Deprecated. dimarch [1, 1] 1 0 Is reading/writing from/to DiMArch? [0]:n; [1]:y; compress [0, 0] 1 0 Is the data compressed? [0]:n; [1]:y;"},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/#dpu","title":"DPU","text":"Field Position Width Default Value Description instr_code [26, 23] 4 4 Instruction code for DPU mode [22, 18] 5 0 The DPU mode. [0]:idle; [1]:add; [2]:sum_acc; [3]:add_const; [4]:subt; [5]:subt_abs; [6]:mode_6; [7]:mult; [8]:mult_add; [9]:mult_const; [10]:mac; [11]:ld_ir; [12]:axpy; [13]:max_min_acc; [14]:max_min_const; [15]:mode_15; [16]:max_min; [17]:shift_l; [18]:shift_r; [19]:sigm; [20]:tanhyp; [21]:expon; [22]:lk_relu; [23]:relu; [24]:div; [25]:acc_softmax; [26]:div_softmax; [27]:ld_acc; [28]:scale_dw; [29]:scale_up; [30]:mac_inter; [31]:mode_31; control [17, 16] 2 2 The controll mode: saturation and operator type. [0]:nosat_int; [1]:nosat_fx; [2]:sat_int; [3]:sat_fx; unused_0 [15, 10] 6 2 Deprecated. acc_clear [9, 2] 8 0 The accumulator clear signal will be triggered if the accumulation reaches this number. It also serves as immediate value for some DPU mode. io_change [1, 0] 2 0 The IO mode: negate input and absolute output. [0]:no_change; [1]:negate_in0; [2]:negate_in1; [3]:abs_out;"},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/#swb","title":"SWB","text":"Field Position Width Default Value Description instr_code [26, 23] 4 5 Instruction code for SWB unused0 [22, 22] 1 1 Deprecated. src_row [21, 21] 1 0 Source row. src_block [20, 20] 1 0 Source block, RF or DPU. [0]:rf; [1]:dpu; src_port [19, 19] 1 0 source port. hb_index [18, 16] 3 0 Index of horizontal bus. This is the column difference of the src and dest cell shifting by 2. For example if the path is from [0,0] to [1,2], the column difference is -2, so the hb_index = -2+2=0. send_to_other_row [15, 15] 1 0 Flag of whether src and dest row are equal. [0]:n; [1]:y; v_index [14, 12] 3 0 Index of vertical bus. This is the dest port. If destination is RF, the v_index is the port number, if the dest is DPU, the v_index is port number + 2."},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/#jump","title":"JUMP","text":"Field Position Width Default Value Description instr_code [26, 23] 4 6 Instruction code for JUMP pc [22, 17] 6 0 The PC to jump to"},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/#wait","title":"WAIT","text":"Field Position Width Default Value Description instr_code [26, 23] 4 7 Instruction code for WAIT cycle_sd [22, 22] 1 0 Is the cycle static or dynamic? [0]:s; [1]:d; cycle [21, 7] 15 0 Number of cycles - 1"},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/#loop","title":"LOOP","text":"Field Position Width Default Value Description instr_code [53, 50] 4 8 Instruction code for LOOP extra [49, 49] 1 0 How many following chunks? loopid [48, 47] 2 0 The id of the loop manager slot. endpc [46, 41] 6 0 The PC where loop ends. start_sd [40, 40] 1 0 Is the start static or dynamic? [0]:s; [1]:d; start [39, 34] 6 0 The start of iterator. iter_sd [33, 33] 1 0 Is the iteration count static or dynamic? [0]:s; [1]:d; iter [32, 27] 6 0 The number of iteration. step_sd [26, 26] 1 0 Is the step static or dynamic? [0]:s; [1]:d; step [25, 20] 6 1 The iteration step. link [19, 16] 4 0 The loops that have the same endpc will be linked together. This field is 1-hot encoded."},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/#bw","title":"BW","text":"Field Position Width Default Value Description instr_code [26, 23] 4 9 Instruction code for BW config [22, 21] 2 0 Bitwidth configuration for DPU: 4-bit, 8-bit, 16-bit"},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/#raccu","title":"RACCU","text":"Field Position Width Default Value Description instr_code [26, 23] 4 10 Instruction code for RACCU mode [22, 20] 3 0 RACCU mode [0]:idle; [1]:add; [2]:sub; [3]:shift_r; [4]:shift_l; [5]:mult; [6]:mult_add; [7]:mult_sub; operand1_sd [19, 19] 1 0 Is the first operand static or dynamic? [0]:s; [1]:d; operand1 [18, 12] 7 0 First operand. operand2_sd [11, 11] 1 0 Is the second operand static or dynamic? [0]:s; [1]:d; operand2 [10, 4] 7 0 Second operand. result [3, 0] 4 0 The RACCU register to store the result."},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/#branch","title":"BRANCH","text":"Field Position Width Default Value Description instr_code [26, 23] 4 11 Instruction code for BRANCH mode [22, 21] 2 0 The branch mode false_pc [20, 15] 6 0 The PC to jump to in case the condition is false."},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/#route","title":"ROUTE","text":"Field Position Width Default Value Description instr_code [26, 23] 4 12 Instruction code for ROUTE horizontal_dir [22, 22] 1 0 The horizontal direction: West or East. [0]:w; [1]:e; horizontal_hops [21, 19] 3 0 The horizontal hops. vertical_dir [18, 18] 1 0 The vertical direction: South or North. [0]:s; [1]:n; vertical_hops [17, 15] 3 0 The vertical hops. direction [14, 14] 1 0 The data transfer direction: Read or Write. [0]:r; [1]:w; select_drra_row [13, 13] 1 0 The drra row that send/recieve the data."},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/#sram","title":"SRAM","text":"Field Position Width Default Value Description instr_code [80, 77] 4 13 Instruction code for SRAM rw [76, 76] 1 0 Read or Write [0]:r; [1]:w; init_addr [75, 69] 7 0 Initial address init_delay [68, 65] 4 0 initial delay l1_iter [64, 58] 7 0 level-1 iteration - 1. l1_step [57, 50] 8 1 level-1 step l1_delay [49, 44] 6 0 level-1 delay l2_iter [43, 37] 7 0 level-2 iteration - 1. l2_step [36, 29] 8 1 level-2 step l2_delay [28, 23] 6 0 level-2 delay init_addr_sd [22, 22] 1 0 Is initial address static or dynamic? [0]:s; [1]:d; l1_iter_sd [21, 21] 1 0 Is level-1 iteration static or dynamic? [0]:s; [1]:d; l2_iter_sd [20, 20] 1 0 Is level-2 iteration static or dynamic? [0]:s; [1]:d; init_delay_sd [19, 19] 1 0 Is initial delay static or dynamic? [0]:s; [1]:d; l1_delay_sd [18, 18] 1 0 Is level-1 delay static or dynamic? [0]:s; [1]:d; l2_delay_sd [17, 17] 1 0 Is level-2 delay static or dynamic? [0]:s; [1]:d; l1_step_sd [16, 16] 1 0 Is level-1 step static or dynamic? [0]:s; [1]:d; l2_step_sd [15, 15] 1 0 Is level-2 step static or dynamic? [0]:s; [1]:d; hops [14, 11] 4 0 Number of hops to reach the DiMArch cell - 1"},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/#isa-description-file","title":"ISA Description File","text":""},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/#json-schema","title":"JSON Schema","text":"<p>The ISA description file uses json format and validated by the following json schema:</p> <pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"platform\": { \"type\": \"string\" },\n    \"instr_bitwidth\": { \"type\": \"integer\" },\n    \"instr_code_bitwidth\": { \"type\": \"integer\" },\n    \"instruction_templates\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"code\": { \"type\": \"integer\" },\n          \"name\": { \"type\": \"string\" },\n          \"phase\": { \"type\": \"integer\" },\n          \"max_chunk\": { \"type\": \"integer\" },\n          \"segment_templates\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"object\",\n              \"properties\": {\n                \"name\": { \"type\": \"string\" },\n                \"bitwidth\": { \"type\": \"integer\" },\n                \"default_val\": { \"type\": \"integer\" },\n                \"controllable\": { \"type\": \"boolean\" },\n                \"observable\": { \"type\": \"boolean\" },\n                \"verbo_map\": {\n                  \"type\": \"array\",\n                  \"items\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"key\": { \"type\": \"integer\" },\n                      \"val\": { \"type\": \"string\" }\n                    }\n                  }\n                },\n                \"comment\": { \"type\": \"string\" }\n              },\n              \"required\": [\"name\", \"bitwidth\", \"comment\"]\n            },\n            \"uniqueItems\": true\n          }\n        },\n        \"required\": [\"code\", \"name\"]\n      },\n      \"uniqueItems\": true\n    }\n  },\n  \"required\": [\n    \"platform\",\n    \"instr_bitwidth\",\n    \"instr_code_bitwidth\",\n    \"instruction_templates\"\n  ]\n}\n</code></pre> <p>Note</p> <p>You can validate a ISA description json file using this schema on Json Schema Validator.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/#json","title":"JSON","text":"<p>The ISA description file used for DRRA is shown as follow:</p> <pre><code>{\n  \"platform\": \"SiLago 1\",\n  \"instr_bitwidth\": 27,\n  \"instr_code_bitwidth\": 4,\n  \"instruction_templates\": [\n    {\n      \"code\": 0,\n      \"name\": \"HALT\",\n      \"phase\": 1,\n      \"max_chunk\": 1,\n      \"segment_templates\": []\n    },\n    {\n      \"code\": 1,\n      \"name\": \"REFI\",\n      \"phase\": 4,\n      \"max_chunk\": 3,\n      \"segment_templates\": [\n        {\n          \"name\": \"port_no\",\n          \"comment\": \"Selects one of the RFile port.\",\n          \"bitwidth\": 2,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"w0\" },\n            { \"key\": 1, \"val\": \"w1\" },\n            { \"key\": 2, \"val\": \"r0\" },\n            { \"key\": 3, \"val\": \"r1\" }\n          ]\n        },\n        {\n          \"name\": \"extra\",\n          \"comment\": \"How many following chunks?\",\n          \"bitwidth\": 2\n        },\n        {\n          \"name\": \"init_addr_sd\",\n          \"comment\": \"Is init_addr static or dymamic?\",\n          \"bitwidth\": 1,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"s\" },\n            { \"key\": 1, \"val\": \"d\" }\n          ]\n        },\n        {\n          \"name\": \"init_addr\",\n          \"comment\": \"Initial address.\",\n          \"bitwidth\": 6\n        },\n        {\n          \"name\": \"l1_iter\",\n          \"comment\": \"Level-1 iteration - 1.\",\n          \"bitwidth\": 6\n        },\n        {\n          \"name\": \"init_delay\",\n          \"comment\": \"Initial delay.\",\n          \"bitwidth\": 6,\n          \"controllable\": true\n        },\n        {\n          \"name\": \"l1_iter_sd\",\n          \"comment\": \"Is level-1 iteration static or dymamic?\",\n          \"bitwidth\": 1,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"s\" },\n            { \"key\": 1, \"val\": \"d\" }\n          ]\n        },\n        {\n          \"name\": \"init_delay_sd\",\n          \"comment\": \"Is initial delay static or dynamic?\",\n          \"bitwidth\": 1,\n          \"controllable\": true,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"s\" },\n            { \"key\": 1, \"val\": \"d\" }\n          ]\n        },\n        {\n          \"name\": \"unused_0\",\n          \"comment\": \"Deprecated.\",\n          \"bitwidth\": 2,\n          \"default_val\": 2,\n          \"controllable\": false,\n          \"observable\": false\n        },\n        {\n          \"name\": \"l1_step_sd\",\n          \"comment\": \"Is level-1 step static or dynamic?\",\n          \"bitwidth\": 1,\n          \"default_val\": 0,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"s\" },\n            { \"key\": 1, \"val\": \"d\" }\n          ]\n        },\n        {\n          \"name\": \"l1_step\",\n          \"comment\": \"Level-1 step\",\n          \"bitwidth\": 6,\n          \"default_val\": 1\n        },\n        {\n          \"name\": \"l1_step_sign\",\n          \"comment\": \"The sign of level-1 step.\",\n          \"bitwidth\": 1,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"+\" },\n            { \"key\": 1, \"val\": \"-\" }\n          ]\n        },\n        {\n          \"name\": \"l1_delay_sd\",\n          \"comment\": \"Is the level-1 delay static or dynamic?\",\n          \"bitwidth\": 1,\n          \"controllable\": true,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"s\" },\n            { \"key\": 1, \"val\": \"d\" }\n          ]\n        },\n        {\n          \"name\": \"l1_delay\",\n          \"comment\": \"The level-1 delay, middle delay\",\n          \"bitwidth\": 4,\n          \"controllable\": true\n        },\n        {\n          \"name\": \"l2_iter_sd\",\n          \"comment\": \"Is level-2 iteration static or dymamic?\",\n          \"bitwidth\": 1,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"s\" },\n            { \"key\": 1, \"val\": \"d\" }\n          ]\n        },\n        {\n          \"name\": \"l2_iter\",\n          \"comment\": \"The level-2 iteration - 1.\",\n          \"bitwidth\": 5\n        },\n        {\n          \"name\": \"l2_step\",\n          \"comment\": \"The level-2 step.\",\n          \"bitwidth\": 4,\n          \"default_val\": 1\n        },\n        {\n          \"name\": \"unused_1\",\n          \"comment\": \"Deprecated.\",\n          \"bitwidth\": 4,\n          \"default_val\": 3,\n          \"controllable\": false,\n          \"observable\": false\n        },\n        {\n          \"name\": \"l2_delay_sd\",\n          \"comment\": \"Is the level-2 delay static or dynamic?\",\n          \"bitwidth\": 1,\n          \"controllable\": true,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"s\" },\n            { \"key\": 1, \"val\": \"d\" }\n          ]\n        },\n        {\n          \"name\": \"l2_delay\",\n          \"comment\": \"The level-2 delay, repetition delay.\",\n          \"bitwidth\": 6,\n          \"controllable\": true\n        },\n        {\n          \"name\": \"unused_2\",\n          \"comment\": \"Deprecated.\",\n          \"bitwidth\": 6,\n          \"default_val\": 0,\n          \"controllable\": false,\n          \"observable\": false\n        },\n        {\n          \"name\": \"l1_delay_ext\",\n          \"comment\": \"The extened bits near MSB of l1_delay.\",\n          \"controllable\": true,\n          \"bitwidth\": 2\n        },\n        {\n          \"name\": \"l2_iter_ext\",\n          \"comment\": \"The extened bits near MSB of l2_iter.\",\n          \"bitwidth\": 1\n        },\n        {\n          \"name\": \"l2_step_ext\",\n          \"comment\": \"The extened bits near MSB of l2_step.\",\n          \"bitwidth\": 2\n        },\n        {\n          \"name\": \"unused_3\",\n          \"comment\": \"Deprecated.\",\n          \"bitwidth\": 3,\n          \"default_val\": 0,\n          \"controllable\": false,\n          \"observable\": false\n        },\n        {\n          \"name\": \"dimarch\",\n          \"comment\": \"Is reading/writing from/to DiMArch?\",\n          \"bitwidth\": 1,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"n\" },\n            { \"key\": 1, \"val\": \"y\" }\n          ]\n        },\n        {\n          \"name\": \"compress\",\n          \"comment\": \"Is the data compressed?\",\n          \"bitwidth\": 1,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"n\" },\n            { \"key\": 1, \"val\": \"y\" }\n          ]\n        }\n      ]\n    },\n    {\n      \"code\": 4,\n      \"name\": \"DPU\",\n      \"phase\": 4,\n      \"max_chunk\": 1,\n      \"segment_templates\": [\n        {\n          \"name\": \"mode\",\n          \"comment\": \"The DPU mode.\",\n          \"bitwidth\": 5,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"idle\" },\n            { \"key\": 1, \"val\": \"add\" },\n            { \"key\": 2, \"val\": \"sum_acc\" },\n            { \"key\": 3, \"val\": \"add_const\" },\n            { \"key\": 4, \"val\": \"subt\" },\n            { \"key\": 5, \"val\": \"subt_abs\" },\n            { \"key\": 6, \"val\": \"mode_6\" },\n            { \"key\": 7, \"val\": \"mult\" },\n            { \"key\": 8, \"val\": \"mult_add\" },\n            { \"key\": 9, \"val\": \"mult_const\" },\n            { \"key\": 10, \"val\": \"mac\" },\n            { \"key\": 11, \"val\": \"ld_ir\" },\n            { \"key\": 12, \"val\": \"axpy\" },\n            { \"key\": 13, \"val\": \"max_min_acc\" },\n            { \"key\": 14, \"val\": \"max_min_const\" },\n            { \"key\": 15, \"val\": \"mode_15\" },\n            { \"key\": 16, \"val\": \"max_min\" },\n            { \"key\": 17, \"val\": \"shift_l\" },\n            { \"key\": 18, \"val\": \"shift_r\" },\n            { \"key\": 19, \"val\": \"sigm\" },\n            { \"key\": 20, \"val\": \"tanhyp\" },\n            { \"key\": 21, \"val\": \"expon\" },\n            { \"key\": 22, \"val\": \"lk_relu\" },\n            { \"key\": 23, \"val\": \"relu\" },\n            { \"key\": 24, \"val\": \"div\" },\n            { \"key\": 25, \"val\": \"acc_softmax\" },\n            { \"key\": 26, \"val\": \"div_softmax\" },\n            { \"key\": 27, \"val\": \"ld_acc\" },\n            { \"key\": 28, \"val\": \"scale_dw\" },\n            { \"key\": 29, \"val\": \"scale_up\" },\n            { \"key\": 30, \"val\": \"mac_inter\" },\n            { \"key\": 31, \"val\": \"mode_31\" }\n          ]\n        },\n        {\n          \"name\": \"control\",\n          \"comment\": \"The controll mode: saturation and operator type.\",\n          \"bitwidth\": 2,\n          \"default_val\": 2,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"nosat_int\" },\n            { \"key\": 1, \"val\": \"nosat_fx\" },\n            { \"key\": 2, \"val\": \"sat_int\" },\n            { \"key\": 3, \"val\": \"sat_fx\" }\n          ]\n        },\n        {\n          \"name\": \"unused_0\",\n          \"comment\": \"Deprecated.\",\n          \"bitwidth\": 6,\n          \"default_val\": 2,\n          \"controllable\": false,\n          \"observable\": false\n        },\n        {\n          \"name\": \"acc_clear\",\n          \"comment\": \"The accumulator clear signal will be triggered if the accumulation reaches this number. It also serves as immediate value for some DPU mode.\",\n          \"bitwidth\": 8\n        },\n        {\n          \"id\": 4,\n          \"name\": \"io_change\",\n          \"comment\": \"The IO mode: negate input and absolute output.\",\n          \"bitwidth\": 2,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"no_change\" },\n            { \"key\": 1, \"val\": \"negate_in0\" },\n            { \"key\": 2, \"val\": \"negate_in1\" },\n            { \"key\": 3, \"val\": \"abs_out\" }\n          ]\n        }\n      ]\n    },\n    {\n      \"code\": 5,\n      \"name\": \"SWB\",\n      \"phase\": 3,\n      \"max_chunk\": 1,\n      \"segment_templates\": [\n        {\n          \"name\": \"unused0\",\n          \"comment\": \"Deprecated.\",\n          \"bitwidth\": 1,\n          \"default_val\": 1,\n          \"controllable\": false,\n          \"observable\": false\n        },\n        {\n          \"name\": \"src_row\",\n          \"comment\": \"Source row.\",\n          \"bitwidth\": 1\n        },\n        {\n          \"name\": \"src_block\",\n          \"comment\": \"Source block, RF or DPU.\",\n          \"bitwidth\": 1,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"rf\" },\n            { \"key\": 1, \"val\": \"dpu\" }\n          ]\n        },\n        {\n          \"name\": \"src_port\",\n          \"comment\": \"source port.\",\n          \"bitwidth\": 1\n        },\n        {\n          \"name\": \"hb_index\",\n          \"comment\": \"Index of horizontal bus. This is the column difference of the src and dest cell shifting by 2. For example if the path is from [0,0] to [1,2], the column difference is -2, so the hb_index = -2+2=0.\",\n          \"bitwidth\": 3\n        },\n        {\n          \"name\": \"send_to_other_row\",\n          \"comment\": \"Flag of whether src and dest row are equal.\",\n          \"bitwidth\": 1,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"n\" },\n            { \"key\": 1, \"val\": \"y\" }\n          ]\n        },\n        {\n          \"name\": \"v_index\",\n          \"comment\": \"Index of vertical bus. This is the dest port. If destination is RF, the v_index is the port number, if the dest is DPU, the v_index is port number + 2.\",\n          \"bitwidth\": 3\n        }\n      ]\n    },\n    {\n      \"code\": 6,\n      \"name\": \"JUMP\",\n      \"phase\": 1,\n      \"max_chunk\": 1,\n      \"segment_templates\": [\n        {\n          \"name\": \"pc\",\n          \"comment\": \"The PC to jump to\",\n          \"bitwidth\": 6\n        }\n      ]\n    },\n    {\n      \"code\": 7,\n      \"name\": \"WAIT\",\n      \"phase\": 2,\n      \"max_chunk\": 1,\n      \"segment_templates\": [\n        {\n          \"name\": \"cycle_sd\",\n          \"comment\": \"Is the cycle static or dynamic?\",\n          \"bitwidth\": 1,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"s\" },\n            { \"key\": 1, \"val\": \"d\" }\n          ]\n        },\n        {\n          \"name\": \"cycle\",\n          \"comment\": \"Number of cycles - 1\",\n          \"bitwidth\": 15\n        }\n      ]\n    },\n    {\n      \"code\": 8,\n      \"name\": \"LOOP\",\n      \"phase\": 1,\n      \"max_chunk\": 2,\n      \"segment_templates\": [\n        {\n          \"name\": \"extra\",\n          \"comment\": \"How many following chunks?\",\n          \"bitwidth\": 1\n        },\n        {\n          \"name\": \"loopid\",\n          \"comment\": \"The id of the loop manager slot.\",\n          \"bitwidth\": 2\n        },\n        {\n          \"name\": \"endpc\",\n          \"comment\": \"The PC where loop ends.\",\n          \"bitwidth\": 6\n        },\n        {\n          \"name\": \"start_sd\",\n          \"comment\": \"Is the start static or dynamic?\",\n          \"bitwidth\": 1,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"s\" },\n            { \"key\": 1, \"val\": \"d\" }\n          ]\n        },\n        {\n          \"name\": \"start\",\n          \"comment\": \"The start of iterator.\",\n          \"bitwidth\": 6\n        },\n        {\n          \"name\": \"iter_sd\",\n          \"comment\": \"Is the iteration count static or dynamic?\",\n          \"bitwidth\": 1,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"s\" },\n            { \"key\": 1, \"val\": \"d\" }\n          ]\n        },\n        {\n          \"name\": \"iter\",\n          \"comment\": \"The number of iteration.\",\n          \"bitwidth\": 6\n        },\n        {\n          \"name\": \"step_sd\",\n          \"comment\": \"Is the step static or dynamic?\",\n          \"bitwidth\": 1,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"s\" },\n            { \"key\": 1, \"val\": \"d\" }\n          ]\n        },\n        {\n          \"name\": \"step\",\n          \"comment\": \"The iteration step.\",\n          \"bitwidth\": 6,\n          \"default_val\": 1\n        },\n        {\n          \"name\": \"link\",\n          \"comment\": \"The loops that have the same endpc will be linked together. This field is 1-hot encoded.\",\n          \"bitwidth\": 4,\n          \"controllable\": false\n        }\n      ]\n    },\n    {\n      \"code\": 9,\n      \"name\": \"BW\",\n      \"phase\": 1,\n      \"max_chunk\": 1,\n      \"segment_templates\": [\n        {\n          \"name\": \"config\",\n          \"comment\": \"Bitwidth configuration for DPU: 4-bit, 8-bit, 16-bit\",\n          \"bitwidth\": 2\n        }\n      ]\n    },\n    {\n      \"code\": 10,\n      \"name\": \"RACCU\",\n      \"phase\": 2,\n      \"max_chunk\": 1,\n      \"segment_templates\": [\n        {\n          \"name\": \"mode\",\n          \"comment\": \"RACCU mode\",\n          \"bitwidth\": 3,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"idle\" },\n            { \"key\": 1, \"val\": \"add\" },\n            { \"key\": 2, \"val\": \"sub\" },\n            { \"key\": 3, \"val\": \"shift_r\" },\n            { \"key\": 4, \"val\": \"shift_l\" },\n            { \"key\": 5, \"val\": \"mult\" },\n            { \"key\": 6, \"val\": \"mult_add\" },\n            { \"key\": 7, \"val\": \"mult_sub\" }\n          ]\n        },\n        {\n          \"name\": \"operand1_sd\",\n          \"comment\": \"Is the first operand static or dynamic?\",\n          \"bitwidth\": 1,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"s\" },\n            { \"key\": 1, \"val\": \"d\" }\n          ]\n        },\n        {\n          \"name\": \"operand1\",\n          \"comment\": \"First operand.\",\n          \"bitwidth\": 7\n        },\n        {\n          \"name\": \"operand2_sd\",\n          \"comment\": \"Is the second operand static or dynamic?\",\n          \"bitwidth\": 1,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"s\" },\n            { \"key\": 1, \"val\": \"d\" }\n          ]\n        },\n        {\n          \"name\": \"operand2\",\n          \"comment\": \"Second operand.\",\n          \"bitwidth\": 7\n        },\n        {\n          \"name\": \"result\",\n          \"comment\": \"The RACCU register to store the result.\",\n          \"bitwidth\": 4\n        }\n      ]\n    },\n    {\n      \"code\": 11,\n      \"name\": \"BRANCH\",\n      \"phase\": 1,\n      \"max_chunk\": 1,\n      \"segment_templates\": [\n        {\n          \"name\": \"mode\",\n          \"comment\": \"The branch mode\",\n          \"bitwidth\": 2\n        },\n        {\n          \"name\": \"false_pc\",\n          \"comment\": \"The PC to jump to in case the condition is false.\",\n          \"bitwidth\": 6\n        }\n      ]\n    },\n    {\n      \"code\": 12,\n      \"name\": \"ROUTE\",\n      \"phase\": 4,\n      \"max_chunk\": 1,\n      \"segment_templates\": [\n        {\n          \"name\": \"horizontal_dir\",\n          \"comment\": \"The horizontal direction: West or East.\",\n          \"bitwidth\": 1,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"w\" },\n            { \"key\": 1, \"val\": \"e\" }\n          ]\n        },\n        {\n          \"name\": \"horizontal_hops\",\n          \"comment\": \"The horizontal hops.\",\n          \"bitwidth\": 3\n        },\n        {\n          \"name\": \"vertical_dir\",\n          \"comment\": \"The vertical direction: South or North.\",\n          \"bitwidth\": 1,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"s\" },\n            { \"key\": 1, \"val\": \"n\" }\n          ]\n        },\n        {\n          \"name\": \"vertical_hops\",\n          \"comment\": \"The vertical hops.\",\n          \"bitwidth\": 3\n        },\n        {\n          \"name\": \"direction\",\n          \"comment\": \"The data transfer direction: Read or Write.\",\n          \"bitwidth\": 1,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"r\" },\n            { \"key\": 1, \"val\": \"w\" }\n          ]\n        },\n        {\n          \"name\": \"select_drra_row\",\n          \"comment\": \"The drra row that send/recieve the data.\",\n          \"bitwidth\": 1\n        }\n      ]\n    },\n    {\n      \"code\": 13,\n      \"name\": \"SRAM\",\n      \"phase\": 5,\n      \"max_chunk\": 3,\n      \"segment_templates\": [\n        {\n          \"name\": \"rw\",\n          \"comment\": \"Read or Write\",\n          \"bitwidth\": 1,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"r\" },\n            { \"key\": 1, \"val\": \"w\" }\n          ]\n        },\n        {\n          \"name\": \"init_addr\",\n          \"comment\": \"Initial address\",\n          \"bitwidth\": 7\n        },\n        {\n          \"name\": \"init_delay\",\n          \"comment\": \"initial delay\",\n          \"bitwidth\": 4,\n          \"controllable\": true\n        },\n        {\n          \"name\": \"l1_iter\",\n          \"comment\": \"level-1 iteration - 1.\",\n          \"bitwidth\": 7\n        },\n        {\n          \"name\": \"l1_step\",\n          \"comment\": \"level-1 step\",\n          \"bitwidth\": 8,\n          \"default_val\": 1\n        },\n        {\n          \"name\": \"l1_delay\",\n          \"comment\": \"level-1 delay\",\n          \"bitwidth\": 6,\n          \"controllable\": true\n        },\n        {\n          \"name\": \"l2_iter\",\n          \"comment\": \"level-2 iteration - 1.\",\n          \"bitwidth\": 7\n        },\n        {\n          \"name\": \"l2_step\",\n          \"comment\": \"level-2 step\",\n          \"bitwidth\": 8,\n          \"default_val\": 1\n        },\n        {\n          \"name\": \"l2_delay\",\n          \"comment\": \"level-2 delay\",\n          \"bitwidth\": 6,\n          \"controllable\": true\n        },\n        {\n          \"name\": \"init_addr_sd\",\n          \"comment\": \"Is initial address static or dynamic?\",\n          \"bitwidth\": 1,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"s\" },\n            { \"key\": 1, \"val\": \"d\" }\n          ]\n        },\n        {\n          \"name\": \"l1_iter_sd\",\n          \"comment\": \"Is level-1 iteration static or dynamic?\",\n          \"bitwidth\": 1,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"s\" },\n            { \"key\": 1, \"val\": \"d\" }\n          ]\n        },\n        {\n          \"name\": \"l2_iter_sd\",\n          \"comment\": \"Is level-2 iteration static or dynamic?\",\n          \"bitwidth\": 1,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"s\" },\n            { \"key\": 1, \"val\": \"d\" }\n          ]\n        },\n        {\n          \"name\": \"init_delay_sd\",\n          \"comment\": \"Is initial delay static or dynamic?\",\n          \"bitwidth\": 1,\n          \"controllable\": true,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"s\" },\n            { \"key\": 1, \"val\": \"d\" }\n          ]\n        },\n        {\n          \"name\": \"l1_delay_sd\",\n          \"comment\": \"Is level-1 delay static or dynamic?\",\n          \"bitwidth\": 1,\n          \"controllable\": true,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"s\" },\n            { \"key\": 1, \"val\": \"d\" }\n          ]\n        },\n        {\n          \"name\": \"l2_delay_sd\",\n          \"comment\": \"Is level-2 delay static or dynamic?\",\n          \"bitwidth\": 1,\n          \"controllable\": true,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"s\" },\n            { \"key\": 1, \"val\": \"d\" }\n          ]\n        },\n        {\n          \"name\": \"l1_step_sd\",\n          \"comment\": \"Is level-1 step static or dynamic?\",\n          \"bitwidth\": 1,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"s\" },\n            { \"key\": 1, \"val\": \"d\" }\n          ]\n        },\n        {\n          \"name\": \"l2_step_sd\",\n          \"comment\": \"Is level-2 step static or dynamic?\",\n          \"bitwidth\": 1,\n          \"verbo_map\": [\n            { \"key\": 0, \"val\": \"s\" },\n            { \"key\": 1, \"val\": \"d\" }\n          ]\n        },\n        {\n          \"name\": \"hops\",\n          \"comment\": \"Number of hops to reach the DiMArch cell - 1\",\n          \"bitwidth\": 4\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/Tutorial_DRRA/","title":"DRRA-based AlImp Design Tutorial (v2)","text":"<p>Note</p> <p>This page is written for vesyla-suite version 2. It's deprecated and will be removed soon. You should only use it for old project such as DRRA characterization. For vesyla-suite version 3, please see Tutorial.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/Tutorial_DRRA/#introduction","title":"Introduction","text":"<p>Vesyla-suite provides two commands: vesyla and manas. Vesyla is used for compiling Matlab code to DRRA and DiMArch based SiLago fabric. Manas is used for instruction scheduling and generating RTL simulation environment.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/Tutorial_DRRA/#write-the-source-code","title":"Write the source code","text":"<p>Please Check the Vesyla Programming Guide v2.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/Tutorial_DRRA/#compilation","title":"Compilation","text":"<p>To compile a program that is purely matlab script by using Vesyla and Manas, use the following command:</p> <pre><code>vesyla -o $PathToOutputDirectory $PathToMatlabFile\nmanas -o $PathToOutputDirectory -t json $PathToOutputDirectory/filegen\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/Tutorial_DRRA/#rtl-simulation","title":"RTL simulation","text":"<p>Vesyla also generates environment for RTL simulation. It's in $OUTPUT/filegen/sim_vsim. However, you can't directly simulate it under QuestaSim because you need to specify the path to the DRRA+DiMArch fabric.</p> <p>To specify the path to the fabric, use the command:</p> <pre><code>export FABRIC_PATH=$PathToFabric\n</code></pre> <p>Then, you can use Questasim to run the simulation script genereated by Vesyla:</p> <pre><code>cd $OUTPUT/filegen/\nvsim -c -do run_gui.do\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/VesylaProgrammingGuide/","title":"Vesyla Programming Guide (v2)","text":"<p>Note</p> <p>This page is written for vesyla-suite version 2. It's deprecated and will be removed soon. You should only use it for old project such as DRRA characterization. For vesyla-suite version 3, please see Vesyla Programming Guide.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/VesylaProgrammingGuide/#basics","title":"Basics","text":""},{"location":"Docs/ToolChain/Vesyla-suite/v2/VesylaProgrammingGuide/#general-guide","title":"General Guide","text":"<p>Vesyla accept modified matlab code as input language. You shouldn't write the matlab code like a programming language. You should instead use it as a tool to model the behaviour of the hardware. Vesyla supports small portion of matlab grammar. There are some generic rules expressing the programming style vesyla accepts.</p> <ul> <li>General function call is not allowed unless the function is predefined as primitive function.</li> <li>Variable except for constant variable and loop iterator should always be decleared via pragma.</li> <li>Statement should always ends with semicolon (<code>;</code>) to avoid unexpected outputs while simulating in matlab.</li> <li>Constant number is normally treated as integers, not double floating point.</li> </ul>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/VesylaProgrammingGuide/#pragma","title":"Pragma","text":"<p>Pragma is the notation that guides Vesyla during synthesis process. Vesyla recongnize pragma starting with symbols <code>%!</code>. The main function of pragmas is specify allocation and binding information since Vesyla can't perform automatic allocation and binding. Section Variable Declaration, Arithmetic Operation, Address Constraint DPU Chain and DPU Internal Scalar Register describe how to use pragmas to allocate and bind resources. Some other usage of pragma also exist, check section Resource Sharing Region for more detail.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/VesylaProgrammingGuide/#variable-declaration","title":"Variable Declaration","text":"<p>Variables supported by Vesyla are vectored Register file variables and SRAM variables. Register file variables will bind to register file and SRAM variables will bind to DiMArch. Since matlab dosen't require variable declaration, we need to give initial value to declare them. You can use the standard initialization assignment for matlab 1-D arry to declare a variable. Function such as <code>zeros()</code> and  <code>ones()</code> are also supported.</p> <p>To declear SRAM variable, you need to use <code>%! MEM[row, col]</code> pragma. <code>row</code> and <code>col</code> are the coordinate of the SRAM block you want to bind for this variable. SRAM usually organized as a 2-D bit matrix without bit-level and word-level access. Data communication with SRAM happens in bulk mode where each data exchange need to be a complete SRAM row. Suppose SRAM with is N and Register width (1 word) is M bit. Each SRAM row will have N/M words. Typical value for M and N are M=256 and N=16. Since SRAM only support whole line reading and writing, the SRAM variable you defined should always have multiple of M/N elements.</p> <p>Example</p> <p>The example shows how to define a SRAM variable <code>y</code> on SRAM block <code>[0,0]</code>. <code>y</code> is initialized by a 1-D vector <code>[1,2,3,4,5,...,16]</code>. <pre><code>y = [1:16]; %! MEM[0,0]\n</code></pre></p> <p>To declear register file variable, you need to use <code>%! RFIL[row, col]</code> pragma. <code>row</code> and <code>col</code> are the coordinate of the DRRA cell you want to bind for this variable. Unlike SRAM, register file is organized in the way that each row will always represent a word. So there is no restriction on the size of register file variable as long as it doesn't exceed the register depth limit.</p> <p>Example</p> <p>The example shows how to define a register file variable <code>x</code> on DRRA cell <code>[0,0]</code>.<code>x</code> has 5 elements and is initialized by a <code>zeros()</code> function which will set all elements in <code>x</code> to <code>0</code>. <pre><code>x = zeros(1, 5); %! REFI[0,0]\n</code></pre></p> <p>For debugging purpose, vesyla allows initialization of register file variable. However, register should not be initialized with any value other than zeros because the real DRRA cell doesn't have interface to support the register initalization. Register file variables hence should always get data from SRAM variables.</p> <p>Error</p> <p>The following variable declaration style is incorrect:</p> <ol> <li>No storage pragma specified <pre><code>x = zeros(1, 5);\n</code></pre></li> <li>Initialized to scalar <pre><code>x = 1; %! RFILE[1,1]\n</code></pre></li> <li>Initialized to 2-D array <pre><code>x = ones(2,3); %! RFILE[1,1]\n</code></pre></li> <li>SRAM varible is not the size of SRAM row <pre><code>x = [1:3]; %! MEM[0,1]\n</code></pre></li> <li>Initialization function <code>randi()</code> is not supported <pre><code>x = randi(10, 1, 16); %! MEM[0,1]\n</code></pre></li> </ol>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/VesylaProgrammingGuide/#vector-slicing-and-address-generation","title":"Vector Slicing and Address Generation","text":"<p>Each DPU can only process one scalar data each time, so the vectored register variable should be slice first before sending to DPU. The slicing operation is mapped on AGU by REFI instruction. While writing matlab code, you don't have to worry about the slicing since matlab directly support vector slicing.</p> <p>Here is an example of slicing a vector:</p> <p>Example</p> <pre><code>x = [1:5]; %! REFI[0,0]\ny = [1:5]; %! REFI[0,0]\ny(1:5) = x(1:5) + y(1:5); %! DPU[0,0]\n</code></pre> <p>If you don't use any slicing and directly feed a vectored register variable to arithmetic operaion, Vesyla will use the full range of that variable.</p> <p>When slicing a SRAM varialbe, the minimal slice should always be multiple of 16.</p> <p>Except for the matlab default slicing method, you can also use two primitive AGU function to linear slice a vectored varialbe both in 1-D or 2-D. Example is given below. All address sequence in the following example are \"1,2,3,4,5\".</p> <p>Example</p> <pre><code>x = [1:5]; %! REFI[0,0]\ny = [1:5]; %! REFI[0,0]\ny(1:5) = x(silago_agu_linear_1d(1,1,5)) + y(silago_agu_linear_2d(1,0,1,1,5)); %! DPU[0,0]\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/VesylaProgrammingGuide/#arithmetic-operation","title":"Arithmetic Operation","text":"<p>Certain type of arithmetic operations are supported by Vesyla. They are addition, subtraction, dot multiplication, sum, abs, etc. Special arithmetic operation need to be mapped to special DPU mode by primitive function call, see section Primitive Function.</p> <p>Bug</p> <p>Symbol <code>~</code> is not supported yet!</p> <p>For arithmetic assignment, you can have a multiple variables as output depending on the DPU mode. The ignored output can be muted by symbol <code>~</code>.</p> <p>Arithmetic operation need a computation resource to perform required operation, that is the DPU. So, every arithmetic operation need to bind to a DPU resource via pragma.</p> <p>Example of an arithmetic assignment is demonstrated as following:</p> <p>Example</p> <pre><code>x = [1:5]; %! REFI[0,0]\ny = [1:5]; %! REFI[0,0]\ny(1:5) = x(1:5) + y(1:5); %! DPU[0,0]\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/VesylaProgrammingGuide/#static-loop","title":"Static Loop","text":"<p>Vesyla accept all static loops. A static loop should have constant start point, static increment as well as static iteration. If an expression that can be simplified to a constant number, it also considered as constant, hence can be used in static loop. Example below shows how to use a static loop.</p> <p>Example</p> <pre><code>n = 3;\nfor i = 1:1:n+1\n    ...\nend\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/VesylaProgrammingGuide/#dynamic-loop","title":"Dynamic Loop","text":"<p>Vesyla support limited dynamic loops. Dynamic loop can have dynamic start point, and dynamic iteration. However, those number should be in address domain, a.k.a computed by RACCU and is fully determinastic after unrolling all the loops.</p> <p>Example of such dynamic loop is shown below:</p> <p>Example</p> <pre><code>for i = 1:1:4\n    for j = i:1:i+3\n        ...\n    end\nend\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/VesylaProgrammingGuide/#branch","title":"Branch","text":"<p>Vesyla support normal matlab branch except for both operands of condition are constants. The usage of branch is the same as the original matlab code. For example:</p> <p>Example</p> <pre><code>x = [1:5]; %! REFI[0,0]\ny = [1:5]; %! REFI[0,0]\nw = [3, 5]; %! REFI[0,0]\nif w(1) &gt; w(2)\n    y = x;\nelse\n    y = x+y; %! DPU[0,0]\nend\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/VesylaProgrammingGuide/#address-constraint","title":"Address Constraint","text":"<p>Address constraints are parameters used by address generation in AGU. Address constraints can be constant or RACCU variable calculated at run-time in RACCU. Dynamic address constraint variables are usually used in loops. Example below shows how to use a RACCU variable to serve as address constraint.</p> <p>Example</p> <pre><code>x = [1:5]; %! REFI[0,0]\ny = [1:16]; %! REFI[0,0]\na = 1; %! RACCU_VAR\nfor i = 1:1:4\n    y(a+1:a+1+5) = x(1:5) + y(a:a+5); %! DPU[0,0]\n    a = a+1;\nend\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/VesylaProgrammingGuide/#advanced-features","title":"Advanced Features","text":""},{"location":"Docs/ToolChain/Vesyla-suite/v2/VesylaProgrammingGuide/#macro","title":"Macro","text":"<p>Vesyla support symbolic expression to enable fast design space exploration. One of the technique is to use macros. Before the lexecal analysis, vesyla will expand all macro to normal program code. Macro gives programmer the tool to generate multiple program with small variations.</p> <p>Programmer need to provide a template and a series of data. Data is organized in json format and will be loaded in to evaluate those macros defined in template. Template use a grammar like the templating package inja. Infact, vesyla directly use inja library to evaluate macros.</p> <p>Example below demonstrate how to define a loop in template:</p> <p>Example</p> <p>An template file defined as following:</p> <pre><code>{% for x in range(par_col) %}\nx0_mem_{{x}} = [1 : n/col]; %! MEM[0, {{x}}]\ny0_mem_{{x}} = [1 : n/col]; %! MEM[0, {{x}}]\n{% endfor %}\n</code></pre> <p>With a json-formated data file:</p> <pre><code>{\"par_col\" : 2}\n</code></pre> <p>This template will generate a real matlab code as following by expanding the FOR-LOOP macro:</p> <pre><code>x0_mem_0 = [1 : n/col]; %! MEM[0, 0]\ny0_mem_0 = [1 : n/col]; %! MEM[0, 0]\nx0_mem_1 = [1 : n/col]; %! MEM[0, 1]\ny0_mem_1 = [1 : n/col]; %! MEM[0, 1]\n</code></pre> <p>Tip</p> <p>More complex usage please visit inja website.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/VesylaProgrammingGuide/#primitive-function","title":"Primitive Function","text":"<p>Primitive DPU functions are functions that corresponds to a complete DPU mode. Different DPUs targeting on different application domain may have some special modes specifically made for such application domain. For example, sigmoid function for neural network application. Those primitive function is not directly supported by matlab, but they are supported by vesyla.</p> <p>To use a specific DPU mode as primitive function, first you need to make sure the DRRA cell you are using has such mode. Then you need to change the configuration of vesyla to recongnize such mode. The configuration file is $Vesyla_root/config/primitive_func_def.xml. Finally, you can use the function inside your program.</p> <p>All primitive DPU functions have name should start with silago_dpu_ to be accepted by Vesyla.</p> <p>Example of using primitive DPU function:</p> <p>Example</p> <pre><code>x = [1:5]; %! REFI[0,0]\nx = silago_dpu_sigmoid(x); %! DPU[0,0]\n</code></pre> <p>AUGs also have special primitive functions to express the complex addressing mode. But AGU primitive functions are not custom. There are two AGU primitive function: silago_agu_linear_1d() and silago_agu_linear_2d(). More AGU primitive functions will be added if some application domain requires.</p> <p>Example of using primitive DPU function:</p> <p>Example</p> <pre><code>x = [1:5]; %! REFI[0,0]\na = [1]; %! REFI[0,0]\nx = x + a(silago_agu_linear_1d(1, 0, 5)); %! DPU[0,0]\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/VesylaProgrammingGuide/#resource-sharing-region","title":"Resource Sharing Region","text":"<p>When multiple operations need some common operands, due to the limit of the number of reading ports, those operations can't happen at the same time in normal condition. Resource sharing region tries to solve the problem. By enabling the broadcasting mechanism, all operation will recieve the same common operand at the same time generated by single reading port of the register file. The datapath of transmitting the common operand is now shared among those operations.</p> <p>Resource sharing region requires a fixed datapath layout. Dynamic change of datapath structure is forbidden inside resource sharing region. So, you should only use it when needed.</p> <p>Following example shows how to active resource sharing region.</p> <p>Example</p> <pre><code>x0 = [1:5]; %! REFI[0,0]\nx1 = [1:5]; %! REFI[1,0]\na2 = [1:5]; %! REFI[2,0]\nx3 = [1:5]; %! REFI[3,0]\nx4 = [1:5]; %! REFI[4,0]\n\n%! RESOURCE_SHARING_BEGIN\nx0 = x0 + a2; %! DPU[0,0]\nx1 = x1 + a2; %! DPU[1,0]\nx3 = x3 + a2; %! DPU[3,0]\nx4 = x4 + a2; %! DPU[4,0]\n%! RESOURCE_SHARING_END\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/VesylaProgrammingGuide/#dpu-chain","title":"DPU Chain","text":"<p>Datapath can be configured as a chain of DPU operation. The output of the previous DPU will immediately enter the next DPU without any register file involved in between. Consider we want to compute a vector addition and a sigmoid function: z = \\sigma (x+y). We can employ two DPUs to perform the complete operation in pipelined fashion. By writing the matlab like the following, you can enable the feature.</p> <p>Example</p> <pre><code>x = [1:5]; %! REFI[0,0]\ny = [1:5]; %! REFI[0,0]\nz = [1:5]; %! REFI[0,0]\nt = zeros(1, 5); %! CDPU[0,0]\n\nt = x + y;\nz = silago_dpu_sigmoid(t); %! DPU[1,0]\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/VesylaProgrammingGuide/#dpu-internal-scalar-register","title":"DPU Internal Scalar Register","text":"<p>Inside each DPU, there are two internal scalar registers which can be explicitly used via high-level matlab program. One can use them by declearing them with the pragma <code>%! CDPU[row, col]</code>.</p> <p>The available functions to load and store values to/from internal scalar registers are:</p> <pre><code>r0 = silago_dpu_load_reg_0(x(1));\nr1 = silago_dpu_load_reg_1(x(1));\n[r0, r1] = silago_dpu_load_reg_both(x(1), x(2));\nx(1) = silago_dpu_load_store_0(r0);\nx(1) = silago_dpu_load_store_1(r1);\n[x(1), y(1)] = silago_dpu_load_store_both(r0, r1);\n</code></pre> <p>Warning</p> <p>Programmer should keep in mind that lifetime and physical location of those variable. Vesyla has very weak semantic checking on those internal scalar register variables.</p> <p>Example</p> <p>For example, if one want to calculate a function: y = ax.y. Instead of put the coefficient a inside a normal register and waste other register entries of the same register block, you can put the coefficient to the internal register, and configure DPU to a scaled multiplication mode to get the correct result.</p> <pre><code>a_mem = [1:16]; %! SRAM[0,0]\nx_mem = [1:16]; %! SRAM[0,0]\ny_mem = [1:16]; %! SRAM[0,0]\nx = [1:16]; %! REFI[0,0]\ny = [1:16]; %! REFI[0,0]\nr = zeros(1, 1); %! CDPU[0,0]\n\nx = a_mem;\nr = silago_dpu_load_reg_1(x(1));\nx = x_mem;\ny = y_mem;\ny = silago_dpu_scaled_mul(x, y, r); %! DPU[0,0]\ny_mem = y;\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/VesylaProgrammingGuide/#not-supported","title":"Not Supported","text":"<p>Some matlab code is not accepted by Vesyla because it can't execute on DRRA fabric. They are:</p> <ul> <li>While-loop.</li> <li>For-loop inside branch.</li> <li>Arithmetic statement that can't be mapped to single DPU mode.</li> <li>Normal function call except for primitive function call.</li> <li>Indirect addressing.</li> </ul>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/isa/","title":"Isa","text":"<p>Note</p> <p>Instruction fields marked by bold font are controllable and observable. Users can modify these fields in Manas input file.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/isa/#halt","title":"HALT","text":"Field Position Width Default Value Description instr_code [26, 23] 4 0 Instruction code for HALT"},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/isa/#refi","title":"REFI","text":"Field Position Width Default Value Description instr_code [80, 77] 4 1 Instruction code for REFI port_no [76, 75] 2 0 Selects one of the RFile port. [0]:w0; [1]:w1; [2]:r0; [3]:r1; extra [74, 73] 2 0 How many following chunks? init_addr_sd [72, 72] 1 0 Is init_addr static or dymamic? [0]:s; [1]:d; init_addr [71, 66] 6 0 Initial address. l1_iter [65, 60] 6 0 Level-1 iteration - 1. init_delay [59, 54] 6 0 Initial delay. l1_iter_sd [53, 53] 1 0 Is level-1 iteration static or dymamic? [0]:s; [1]:d; init_delay_sd [52, 52] 1 0 Is initial delay static or dynamic? [0]:s; [1]:d; unused_0 [51, 50] 2 2 Deprecated. l1_step_sd [49, 49] 1 0 Is level-1 step static or dynamic? [0]:s; [1]:d; l1_step [48, 43] 6 1 Level-1 step l1_step_sign [42, 42] 1 0 The sign of level-1 step. [0]:+; [1]:-; l1_delay_sd [41, 41] 1 0 Is the level-1 delay static or dynamic? [0]:s; [1]:d; l1_delay [40, 37] 4 0 The level-1 delay, middle delay l2_iter_sd [36, 36] 1 0 Is level-2 iteration static or dymamic? [0]:s; [1]:d; l2_iter [35, 31] 5 0 The level-2 iteration - 1. l2_step [30, 27] 4 1 The level-2 step. unused_1 [26, 23] 4 3 Deprecated. l2_delay_sd [22, 22] 1 0 Is the level-2 delay static or dynamic? [0]:s; [1]:d; l2_delay [21, 16] 6 0 The level-2 delay, repetition delay. unused_2 [15, 10] 6 0 Deprecated. l1_delay_ext [9, 8] 2 0 The extened bits near MSB of l1_delay. l2_iter_ext [7, 7] 1 0 The extened bits near MSB of l2_iter. l2_step_ext [6, 5] 2 0 The extened bits near MSB of l2_step. unused_3 [4, 2] 3 0 Deprecated. dimarch [1, 1] 1 0 Is reading/writing from/to DiMArch? [0]:n; [1]:y; compress [0, 0] 1 0 Is the data compressed? [0]:n; [1]:y;"},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/isa/#dpu","title":"DPU","text":"Field Position Width Default Value Description instr_code [26, 23] 4 4 Instruction code for DPU mode [22, 18] 5 0 The DPU mode. [0]:idle; [1]:add; [2]:sum_acc; [3]:add_const; [4]:subt; [5]:subt_abs; [6]:mode_6; [7]:mult; [8]:mult_add; [9]:mult_const; [10]:mac; [11]:ld_ir; [12]:axpy; [13]:max_min_acc; [14]:max_min_const; [15]:mode_15; [16]:max_min; [17]:shift_l; [18]:shift_r; [19]:sigm; [20]:tanhyp; [21]:expon; [22]:lk_relu; [23]:relu; [24]:div; [25]:acc_softmax; [26]:div_softmax; [27]:ld_acc; [28]:scale_dw; [29]:scale_up; [30]:mac_inter; [31]:mode_31; control [17, 16] 2 2 The controll mode: saturation and operator type. [0]:nosat_int; [1]:nosat_fx; [2]:sat_int; [3]:sat_fx; unused_0 [15, 10] 6 2 Deprecated. acc_clear [9, 2] 8 0 The accumulator clear signal will be triggered if the accumulation reaches this number. It also serves as immediate value for some DPU mode. io_change [1, 0] 2 0 The IO mode: negate input and absolute output. [0]:no_change; [1]:negate_in0; [2]:negate_in1; [3]:abs_out;"},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/isa/#swb","title":"SWB","text":"Field Position Width Default Value Description instr_code [26, 23] 4 5 Instruction code for SWB unused0 [22, 22] 1 1 Deprecated. src_row [21, 21] 1 0 Source row. src_block [20, 20] 1 0 Source block, RF or DPU. [0]:rf; [1]:dpu; src_port [19, 19] 1 0 source port. hb_index [18, 16] 3 0 Index of horizontal bus. This is the column difference of the src and dest cell shifting by 2. For example if the path is from [0,0] to [1,2], the column difference is -2, so the hb_index = -2+2=0. send_to_other_row [15, 15] 1 0 Flag of whether src and dest row are equal. [0]:n; [1]:y; v_index [14, 12] 3 0 Index of vertical bus. This is the dest port. If destination is RF, the v_index is the port number, if the dest is DPU, the v_index is port number + 2."},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/isa/#jump","title":"JUMP","text":"Field Position Width Default Value Description instr_code [26, 23] 4 6 Instruction code for JUMP pc [22, 17] 6 0 The PC to jump to"},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/isa/#wait","title":"WAIT","text":"Field Position Width Default Value Description instr_code [26, 23] 4 7 Instruction code for WAIT cycle_sd [22, 22] 1 0 Is the cycle static or dynamic? [0]:s; [1]:d; cycle [21, 7] 15 0 Number of cycles - 1"},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/isa/#loop","title":"LOOP","text":"Field Position Width Default Value Description instr_code [53, 50] 4 8 Instruction code for LOOP extra [49, 49] 1 0 How many following chunks? loopid [48, 47] 2 0 The id of the loop manager slot. endpc [46, 41] 6 0 The PC where loop ends. start_sd [40, 40] 1 0 Is the start static or dynamic? [0]:s; [1]:d; start [39, 34] 6 0 The start of iterator. iter_sd [33, 33] 1 0 Is the iteration count static or dynamic? [0]:s; [1]:d; iter [32, 27] 6 0 The number of iteration. step_sd [26, 26] 1 0 Is the step static or dynamic? [0]:s; [1]:d; step [25, 20] 6 1 The iteration step. link [19, 16] 4 0 The loops that have the same endpc will be linked together. This field is 1-hot encoded."},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/isa/#bw","title":"BW","text":"Field Position Width Default Value Description instr_code [26, 23] 4 9 Instruction code for BW config [22, 21] 2 0 Bitwidth configuration for DPU: 4-bit, 8-bit, 16-bit"},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/isa/#raccu","title":"RACCU","text":"Field Position Width Default Value Description instr_code [26, 23] 4 10 Instruction code for RACCU mode [22, 20] 3 0 RACCU mode [0]:idle; [1]:add; [2]:sub; [3]:shift_r; [4]:shift_l; [5]:mult; [6]:mult_add; [7]:mult_sub; operand1_sd [19, 19] 1 0 Is the first operand static or dynamic? [0]:s; [1]:d; operand1 [18, 12] 7 0 First operand. operand2_sd [11, 11] 1 0 Is the second operand static or dynamic? [0]:s; [1]:d; operand2 [10, 4] 7 0 Second operand. result [3, 0] 4 0 The RACCU register to store the result."},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/isa/#branch","title":"BRANCH","text":"Field Position Width Default Value Description instr_code [26, 23] 4 11 Instruction code for BRANCH mode [22, 21] 2 0 The branch mode false_pc [20, 15] 6 0 The PC to jump to in case the condition is false."},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/isa/#route","title":"ROUTE","text":"Field Position Width Default Value Description instr_code [26, 23] 4 12 Instruction code for ROUTE horizontal_dir [22, 22] 1 0 The horizontal direction: West or East. [0]:w; [1]:e; horizontal_hops [21, 19] 3 0 The horizontal hops. vertical_dir [18, 18] 1 0 The vertical direction: South or North. [0]:s; [1]:n; vertical_hops [17, 15] 3 0 The vertical hops. direction [14, 14] 1 0 The data transfer direction: Read or Write. [0]:r; [1]:w; select_drra_row [13, 13] 1 0 The drra row that send/recieve the data."},{"location":"Docs/ToolChain/Vesyla-suite/v2/InstructionSet/isa/#sram","title":"SRAM","text":"Field Position Width Default Value Description instr_code [80, 77] 4 13 Instruction code for SRAM rw [76, 76] 1 0 Read or Write [0]:r; [1]:w; init_addr [75, 69] 7 0 Initial address init_delay [68, 65] 4 0 initial delay l1_iter [64, 58] 7 0 level-1 iteration - 1. l1_step [57, 50] 8 1 level-1 step l1_delay [49, 44] 6 0 level-1 delay l2_iter [43, 37] 7 0 level-2 iteration - 1. l2_step [36, 29] 8 1 level-2 step l2_delay [28, 23] 6 0 level-2 delay init_addr_sd [22, 22] 1 0 Is initial address static or dynamic? [0]:s; [1]:d; l1_iter_sd [21, 21] 1 0 Is level-1 iteration static or dynamic? [0]:s; [1]:d; l2_iter_sd [20, 20] 1 0 Is level-2 iteration static or dynamic? [0]:s; [1]:d; init_delay_sd [19, 19] 1 0 Is initial delay static or dynamic? [0]:s; [1]:d; l1_delay_sd [18, 18] 1 0 Is level-1 delay static or dynamic? [0]:s; [1]:d; l2_delay_sd [17, 17] 1 0 Is level-2 delay static or dynamic? [0]:s; [1]:d; l1_step_sd [16, 16] 1 0 Is level-1 step static or dynamic? [0]:s; [1]:d; l2_step_sd [15, 15] 1 0 Is level-2 step static or dynamic? [0]:s; [1]:d; hops [14, 11] 4 0 Number of hops to reach the DiMArch cell - 1"},{"location":"Docs/ToolChain/Vesyla-suite/v3/Installation/","title":"Installation","text":"<p>Note</p> <p>This page is written for vesyla-suite version 3. We don't recommend to compile for vesyla-suite version 2.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/Installation/#create-and-use-docker-image","title":"Create and Use Docker Image","text":""},{"location":"Docs/ToolChain/Vesyla-suite/v3/Installation/#prerequisites","title":"Prerequisites","text":"<p>To use docker image, you need to install docker first. You can install docker according to the instruction on the official website: https://docs.docker.com/install/.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/Installation/#build-docker-image","title":"Build Docker Image","text":"<p>There is a docker file in the root folder of vesyla-suite. You can use it to create a docker image for vesyla-suite. The docker image is based on Fedora Linux. You can use the following command to create a docker image (assuming the version is 3.0):</p> <pre><code>docker build -t vesyla-suite:3.0 .\n</code></pre> <p>Optionally, you can export the docker image to a tar file by using the following command:</p> <pre><code>docker save -o vesyla-suite-3.0.tar vesyla-suite:3.0\n</code></pre> <p>You don't have to build your own docker image from the source code. It is also possible to download the docker image from one-drive. Ask the vesyla-suite maintainer for the download link. Once you can import the docker image using the command:</p> <pre><code>docker load -i vesyla-suite-3.0.tar\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/Installation/#create-docker-container","title":"Create Docker Container","text":"<p>To create a docker container from the docker image and bind the current directory to the <code>/work</code> directory in the container, you can use the following command:</p> <pre><code>docker run --name vesyla-suite -v $PWD:/work vesyla-suite:3.0\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/Installation/#use-docker-container","title":"Use Docker Container","text":"<p>Once the container has been created, you can use the following command to enter the container and access the commands provided by vesyla-suite:</p> <pre><code>docker start -i vesyla-suite\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/Installation/#compile-and-install-from-source-code","title":"Compile and Install from Source Code","text":""},{"location":"Docs/ToolChain/Vesyla-suite/v3/Installation/#prerequisites_1","title":"Prerequisites","text":"<p>Vesyla-suite can be compiled and installed on any modern linux distribution. Before compiling vesyla-suite, you need to install compilation tool chain. You need to use the correct package manager of your Linux distribution. The necessary packages include: g++ (version 5 or above), make, cmake, boost liabrires, gecode. Here, we give the example command for Fedora Linux.</p> <pre><code>sudo dnf install g++ make cmake boost-devel perl autoconf libgmp-devel  \n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/Installation/#installation-gecode","title":"Installation Gecode","text":"<p>Vesyla uses Gecode it for CP scheduling engine. You can install it according to the installation instruction on the official website: https://www.gecode.org/. Please install Gecode in stanard location (such as <code>/usr</code> or <code>/usr/local</code>) so that the cmake can find it.</p> <pre><code>cd /gecode/root/folder\n./configure --prefix=/desired/install/path\nmake\nmake install\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/Installation/#install-python3-and-python3-packages","title":"Install Python3 and Python3 packages","text":"<p>Python3 is assential for vesyla-suite. You can install it according to the instruction on the official website: https://www.python.org/. You also need to install some python3 packages. Here, we give the example command for Fedora Linux.</p> <pre><code>sudo dnf install python3-devel python3-pip\n</code></pre> <p>Vesyla-suite uses nuitka to compile python3 scripts into native executable programs. You can install it by using pip3.</p> <pre><code>sudo dnf install patchelf\npip3 install nuitka\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/Installation/#compile-and-install-vesyla-suite","title":"Compile and install vesyla-suite","text":"<p>Vesyla-suite also need flex and bison to compile. You can install them by using the package manager of your Linux distribution. Here, we give the example command for Fedora Linux.</p> <pre><code>sudo dnf install bison flex\n</code></pre> <p>Then, you can download the vesyla-suite source package and make a build directory.</p> <pre><code>cd /vesyla-suite/root/folder\nmkdir build\n</code></pre> <p>Next step is to generate makefile according to the CMake configuration file CMakeLists.txt and specify the installation path. Once the makefile is generated, you can compile it and install the compiled program.</p> <pre><code>cd build\ncmake -DCMAKE_INSTALL_PREFIX=/desired/install/path ..\nmake\nmake install\n</code></pre> <p>Now, all executable programs in vesyla-suite are installed.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/Installation/#post-installation-setup","title":"Post-installation Setup","text":"<p>If vesyla-suite are installed in non-standard location, you need to set the following environment variables to make it work.</p> <pre><code>export PATH=$PATH:/path/to/vesyla-suite/bin\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/vesyla-suite/lib\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/gecode/lib\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionPhase/","title":"Instruction Phase","text":"<p>Instruction phase is the critical timing point when the instruction behavior changes. Each instruction has 1 or more phases. It roughly corresponds to the FSM transition point of each level-2 controller. The following table list all the phases of each instruction on DRRA.</p> Instruction Number Phases HALT 1 FETCH REFI 4 FETCH, ISSUE, ACTIVE, END DPU 4 FETCH, ISSUE, ACTIVE, END SWB 3 FETCH, ISSUE, END JUMP 1 FETCH WAIT 2 FETCH, END LOOP 1 FETCH RACCU 2 FETCH, ISSUE BRANCH 1 FETCH ROUTE 4 FETCH, ISSUE, ARRIVE, END SRAM 5 FETCH, ISSUE, ARRIVE, ACTIVE, END"},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/","title":"Instruction Set","text":""},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/#instructions","title":"Instructions","text":"<p>Note</p> <p>Instruction fields marked by bold font are controllable and observable. Users can modify these fields in Manas input file.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/#halt","title":"HALT","text":"Field Position Width Default Value Description instr_code [26, 23] 4 0 Instruction code for HALT"},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/#refi","title":"REFI","text":"Field Position Width Default Value Description instr_code [80, 77] 4 1 Instruction code for REFI port_no [76, 75] 2 0 Selects one of the RFile port. [0]:w0; [1]:w1; [2]:r0; [3]:r1; extra [74, 73] 2 0 How many following chunks? init_addr_sd [72, 72] 1 0 Is init_addr static or dymamic? [0]:s; [1]:d; init_addr [71, 66] 6 0 Initial address. l1_iter [65, 60] 6 0 Level-1 iteration - 1. init_delay [59, 54] 6 0 Initial delay. l1_iter_sd [53, 53] 1 0 Is level-1 iteration static or dymamic? [0]:s; [1]:d; init_delay_sd [52, 52] 1 0 Is initial delay static or dynamic? [0]:s; [1]:d; unused_0 [51, 50] 2 2 Deprecated. l1_step_sd [49, 49] 1 0 Is level-1 step static or dynamic? [0]:s; [1]:d; l1_step [48, 43] 6 1 Level-1 step l1_step_sign [42, 42] 1 0 The sign of level-1 step. [0]:+; [1]:-; l1_delay_sd [41, 41] 1 0 Is the level-1 delay static or dynamic? [0]:s; [1]:d; l1_delay [40, 37] 4 0 The level-1 delay, middle delay l2_iter_sd [36, 36] 1 0 Is level-2 iteration static or dymamic? [0]:s; [1]:d; l2_iter [35, 31] 5 0 The level-2 iteration - 1. l2_step [30, 27] 4 1 The level-2 step. unused_1 [26, 23] 4 3 Deprecated. l2_delay_sd [22, 22] 1 0 Is the level-2 delay static or dynamic? [0]:s; [1]:d; l2_delay [21, 16] 6 0 The level-2 delay, repetition delay. unused_2 [15, 10] 6 0 Deprecated. l1_delay_ext [9, 8] 2 0 The extened bits near MSB of l1_delay. l2_iter_ext [7, 7] 1 0 The extened bits near MSB of l2_iter. l2_step_ext [6, 5] 2 0 The extened bits near MSB of l2_step. unused_3 [4, 2] 3 0 Deprecated. dimarch [1, 1] 1 0 Is reading/writing from/to DiMArch? [0]:n; [1]:y; compress [0, 0] 1 0 Is the data compressed? [0]:n; [1]:y;"},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/#dpu","title":"DPU","text":"Field Position Width Default Value Description instr_code [26, 23] 4 4 Instruction code for DPU mode [22, 18] 5 0 The DPU mode. [0]:idle; [1]:add; [2]:sum_acc; [3]:add_const; [4]:subt; [5]:subt_abs; [6]:mode_6; [7]:mult; [8]:mult_add; [9]:mult_const; [10]:mac; [11]:ld_ir; [12]:axpy; [13]:max_min_acc; [14]:max_min_const; [15]:mode_15; [16]:max_min; [17]:shift_l; [18]:shift_r; [19]:sigm; [20]:tanhyp; [21]:expon; [22]:lk_relu; [23]:relu; [24]:div; [25]:acc_softmax; [26]:div_softmax; [27]:ld_acc; [28]:scale_dw; [29]:scale_up; [30]:mac_inter; [31]:mode_31; control [17, 16] 2 2 The controll mode: saturation and operator type. [0]:nosat_int; [1]:nosat_fx; [2]:sat_int; [3]:sat_fx; unused_0 [15, 10] 6 2 Deprecated. acc_clear [9, 2] 8 0 The accumulator clear signal will be triggered if the accumulation reaches this number. It also serves as immediate value for some DPU mode. io_change [1, 0] 2 0 The IO mode: negate input and absolute output. [0]:no_change; [1]:negate_in0; [2]:negate_in1; [3]:abs_out;"},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/#swb","title":"SWB","text":"Field Position Width Default Value Description instr_code [26, 23] 4 5 Instruction code for SWB unused0 [22, 22] 1 1 Deprecated. src_row [21, 21] 1 0 Source row. src_block [20, 20] 1 0 Source block, RF or DPU. [0]:rf; [1]:dpu; src_port [19, 19] 1 0 source port. hb_index [18, 16] 3 0 Index of horizontal bus. This is the column difference of the src and dest cell shifting by 2. For example if the path is from [0,0] to [1,2], the column difference is -2, so the hb_index = -2+2=0. send_to_other_row [15, 15] 1 0 Flag of whether src and dest row are equal. [0]:n; [1]:y; v_index [14, 12] 3 0 Index of vertical bus. This is the dest port. If destination is RF, the v_index is the port number, if the dest is DPU, the v_index is port number + 2."},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/#jump","title":"JUMP","text":"Field Position Width Default Value Description instr_code [26, 23] 4 6 Instruction code for JUMP pc [22, 17] 6 0 The PC to jump to"},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/#wait","title":"WAIT","text":"Field Position Width Default Value Description instr_code [26, 23] 4 7 Instruction code for WAIT cycle_sd [22, 22] 1 0 Is the cycle static or dynamic? [0]:s; [1]:d; cycle [21, 7] 15 0 Number of cycles - 1"},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/#loop","title":"LOOP","text":"Field Position Width Default Value Description instr_code [53, 50] 4 8 Instruction code for LOOP extra [49, 49] 1 0 How many following chunks? loopid [48, 47] 2 0 The id of the loop manager slot. endpc [46, 41] 6 0 The PC where loop ends. start_sd [40, 40] 1 0 Is the start static or dynamic? [0]:s; [1]:d; start [39, 34] 6 0 The start of iterator. iter_sd [33, 33] 1 0 Is the iteration count static or dynamic? [0]:s; [1]:d; iter [32, 27] 6 0 The number of iteration. step_sd [26, 26] 1 0 Is the step static or dynamic? [0]:s; [1]:d; step [25, 20] 6 1 The iteration step. link [19, 16] 4 0 The loops that have the same endpc will be linked together. This field is 1-hot encoded."},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/#bw","title":"BW","text":"Field Position Width Default Value Description instr_code [26, 23] 4 9 Instruction code for BW config [22, 21] 2 0 Bitwidth configuration for DPU: 4-bit, 8-bit, 16-bit"},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/#raccu","title":"RACCU","text":"Field Position Width Default Value Description instr_code [26, 23] 4 10 Instruction code for RACCU mode [22, 20] 3 0 RACCU mode [0]:idle; [1]:add; [2]:sub; [3]:shift_r; [4]:shift_l; [5]:mult; [6]:mult_add; [7]:mult_sub; operand1_sd [19, 19] 1 0 Is the first operand static or dynamic? [0]:s; [1]:d; operand1 [18, 12] 7 0 First operand. operand2_sd [11, 11] 1 0 Is the second operand static or dynamic? [0]:s; [1]:d; operand2 [10, 4] 7 0 Second operand. result [3, 0] 4 0 The RACCU register to store the result."},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/#branch","title":"BRANCH","text":"Field Position Width Default Value Description instr_code [26, 23] 4 11 Instruction code for BRANCH mode [22, 21] 2 0 The branch mode false_pc [20, 15] 6 0 The PC to jump to in case the condition is false."},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/#route","title":"ROUTE","text":"Field Position Width Default Value Description instr_code [26, 23] 4 12 Instruction code for ROUTE horizontal_dir [22, 22] 1 0 The horizontal direction: West or East. [0]:w; [1]:e; horizontal_hops [21, 19] 3 0 The horizontal hops. vertical_dir [18, 18] 1 0 The vertical direction: South or North. [0]:s; [1]:n; vertical_hops [17, 15] 3 0 The vertical hops. direction [14, 14] 1 0 The data transfer direction: Read or Write. [0]:r; [1]:w; select_drra_row [13, 13] 1 0 The drra row that send/recieve the data."},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/#sram","title":"SRAM","text":"Field Position Width Default Value Description instr_code [80, 77] 4 13 Instruction code for SRAM rw [76, 76] 1 0 Read or Write [0]:r; [1]:w; init_addr [75, 69] 7 0 Initial address init_delay [68, 65] 4 0 initial delay l1_iter [64, 58] 7 0 level-1 iteration - 1. l1_step [57, 50] 8 1 level-1 step l1_delay [49, 44] 6 0 level-1 delay l2_iter [43, 37] 7 0 level-2 iteration - 1. l2_step [36, 29] 8 1 level-2 step l2_delay [28, 23] 6 0 level-2 delay init_addr_sd [22, 22] 1 0 Is initial address static or dynamic? [0]:s; [1]:d; l1_iter_sd [21, 21] 1 0 Is level-1 iteration static or dynamic? [0]:s; [1]:d; l2_iter_sd [20, 20] 1 0 Is level-2 iteration static or dynamic? [0]:s; [1]:d; init_delay_sd [19, 19] 1 0 Is initial delay static or dynamic? [0]:s; [1]:d; l1_delay_sd [18, 18] 1 0 Is level-1 delay static or dynamic? [0]:s; [1]:d; l2_delay_sd [17, 17] 1 0 Is level-2 delay static or dynamic? [0]:s; [1]:d; l1_step_sd [16, 16] 1 0 Is level-1 step static or dynamic? [0]:s; [1]:d; l2_step_sd [15, 15] 1 0 Is level-2 step static or dynamic? [0]:s; [1]:d; hops [14, 11] 4 0 Number of hops to reach the DiMArch cell - 1"},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/#io","title":"IO","text":"Field Position Width Default Value Description instr_code [80, 77] 4 13 Instruction code for IO rw [76, 76] 1 0 Read or Write. [0]:r; [1]:w; init_addr [75, 51] 25 0 Initial address init_delay [50, 45] 6 0 initial delay l1_iter [44, 40] 5 0 level-1 iteration - 1. l1_step [39, 35] 5 1 level-1 step l1_delay [34, 29] 6 0 level-1 delay mask [28, 13] 16 0 mask it to 1 if a word is not useful. init_addr_sd [12, 12] 1 0 Is initial address static or dynamic? [0]:s; [1]:d; init_delay_sd [11, 11] 1 0 Is initial delay static or dynamic? [0]:s; [1]:d; l1_iter_sd [10, 10] 1 0 Is level-1 iteration static or dynamic? [0]:s; [1]:d; l1_step_sd [9, 9] 1 0 Is level-1 step static or dynamic? [0]:s; [1]:d;"},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/#perm","title":"PERM","text":"Field Position Width Default Value Description instr_code [26, 23] 4 14 Instruction code for SHUFFLE mode [22, 20] 3 0 Shuffle mode. [0]:left shift (zero-fill); [1]:right shift (zero-fill); [2]:left shift (same fill); [3]:right shift (same fill); [4]:left rotate; [5]:right rotate; block [19, 18] 2 0 Sub-block in register file. distance [17, 2] 16 0 shuffle distance."},{"location":"Docs/ToolChain/Vesyla-suite/v3/ManasProgrammingGuide/","title":"Manas Programming Guide","text":"<p>Note</p> <p>This page is written for both vesyla-suite version 2 and version 3.</p> <p>Warning</p> <p>This programming guide is intended to fine-grained control of Manas. We do not recommend you to use this guide unless you are familiar with the internal structure of Manas. For most cases, you can use the Vesyla Programming Guide to generate inputs for Manas.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/ManasProgrammingGuide/#basics","title":"Basics","text":""},{"location":"Docs/ToolChain/Vesyla-suite/v3/ManasProgrammingGuide/#general-guide","title":"General Guide","text":"<p>Manas is an assembler for SiLago platform (DRRA+DiMArch). It accepts defination of instructions and their dependencies and generates a RTL testbench for simulation. Manas uses the scheduling engine of Vesyla to schedule these instructions based on user-defined dependencies.</p> <p>The input file of Manas is a plan text file with four segments:</p> <ul> <li>the DATA segment</li> <li>the CODE segment</li> <li>the RELATION segment</li> <li>the DEPENDENCY segment.</li> </ul>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/ManasProgrammingGuide/#data-segment","title":"DATA Segment","text":"<p>Data layout in DiMArch and Register Files are defined in DATA segment. A DATA segment starts with a segment identifier:</p> <pre><code>.DATA\n</code></pre> <p>A variable is defined by the following syntax:</p> <pre><code>VAR_NAME VAR_LOCATION VAR_TYPE ROW COL INIT_DATA\n</code></pre> <p>VAR_NAME: the name of a variable. It must start with the symbol <code>$</code>. It must be unique.</p> <p>VAR_LOCATION: the location of the varialbe, either DiMArch (VAR_LOCATION=1) or Register File (VAR_LOCATION=0).</p> <p>VAR_TYPE: the type of the variable, either integer (VAR_TYPE=0) or fixpoint(VAR_TYPE=1)</p> <p>ROW &amp; COL: The coordinate of the DiMArch or Register File.</p> <p>INIT_DATA: The initialization data of the variable. It also defines the variable size. The size must be multiple of 16 for DiMArch variables since each DiMArch row has 16 words. To initialize the variable, one can use any of the following method:</p> <p>Example</p> <p>Example of variable initialization</p> <pre><code>$A 1 0 0 0 ONES(16)\n$B 1 0 0 0 ZEROS(16)\n$C 1 0 0 0 [1,2,3,4,5,6,7,8,7,6,5,4,3,2,1]\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/ManasProgrammingGuide/#code-segment","title":"CODE Segment","text":"<p>Instructions are defined in CODE segment. A CODE segment starts with segment identifier:</p> <pre><code>.CODE\n</code></pre> <p>All statements after the CODE segment identifer and before any other segment identifier are considered part of the CODE segment.</p> <p>A code segment can include multiple sections leading by a cell location identifier:</p> <pre><code>CELL &lt;r, c&gt;\n</code></pre> <p>It defines the coordinate in terms of row (<code>r</code>) and column (<code>c</code>) of each instructions that follow it. It applies to all instructions until another cell location identifier or the end of the CODE segment.</p> <p>An instruction consists a instruction name and an argument list. They are seperated by space. All arguments should be integers unless specified otherwise. You can find all supported instructions in the Instruction Set.</p> <p>Each instruction has multiple fields. Some fields are controllable which means one can set the value of that field through the assembly language. All the controllable fields are marked by bold text in the Instruction Set.</p> <p>Each field in an instruction has a default value. In the Instruction Set page, the default value is explicitly written in the Range/Value section unless the default value is 0. While wring the Assebly language, you only need to set the field whoes expected value is not the default value.</p> <p>To write a instruction, use the following format:</p> <pre><code>LABEL INSTR_NAME NAME_0 = VALUE_0, NAME_1 = VALUE_1, ...\n</code></pre> <p>Example</p> <p>This is a example for code segment</p> <pre><code>.CODE\nCELL &lt;0,0&gt;\n\"label_0\" REFI port_no=2, init_addr=16\n\"label_1\" REFI port_no=0\n\"label_2\" DPU mode=10\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/ManasProgrammingGuide/#relation-segment","title":"RELATION Segment","text":"<p>Relation segment specifies the hierarchical structure of the mapping. The entire mapping is organized as a hierarichical graph. The outer most node is called <code>ROOT</code>. Inside the <code>ROOT</code> node, there are other nodes, such as loop node, branch node, and other normal instruction node.</p> <p>Each node represents either an hierarchical structure or an instruction phase. For example, a node can represent the whole loop structure and it contains all instructions and inner loops inside its children graph. Each instruction in the CODE segment can be divided into multiple instruction phases. Each phase marks a critical timing point when the instruction changes behavior. For example, a <code>REFI</code> instruction has four phases: FETCH, ISSUE, ACTIVE, and END. The name of the node that represents an instruction phase is to combine the instruction label and the phase index. For example, if a <code>REFI</code> instruction has a label called <code>instr_refi_0</code>, then the FETCH phase will be mapped to the node named as <code>instr_refi_0_0</code> since the FETCH phase is the first phase of the REFI instruction. See Instruction Phase</p> <p>Each relation record in the RELATION segment specifies the children of one hierarchical node. The format is:</p> <pre><code>\"NODE_NAME\" 1 IS_BULK [NODE0_IN_CHILD0, NODE1_IN_CHILD0, ...] [NODE0_IN_CHILD1, NODE1_IN_CHILD1, ...] EXPAND_LOOP\n</code></pre> <p>The NODE_NAME can be any string, it's the name of the hierarchical node. The second parameter is deprecated, it's always 1. The third parameter IS_BULK specifies whether this node should be treated as bulk node. A bulk node does not allow overlap with other nodes. The array of child0 and child1 are used to specify the children node in the 0<sup>th</sup> and 1th child graph. All hierarchical node other than IF-ELSE branch has only child0. The brach node has two children, child0 is the true branch, and child1 is the false branch. The last parameter is the EXPAND_LOOP. It's a flag to suggest the assembler to do cross-iteration software pipelining.</p> <p>Note</p> <p>The IS_BULK and EXPAND_LOOP are very confusing in manas. We will modify manas to make it more clear. Right now, all nodes other than loop should set both parameters to 0. For most inner loop, you should let IS_BULK=0 and EXPAND_LOOP=1. For other loops, set IS_BULK=1 and EXPAND_LOOP=1.</p> <p>When write node names in child graph array, you can use regular expression to include a group of nodes. For example, <code>instr_refi_0_.*</code> will include all the phases of the instruction named as \"instr_refi_0\".</p> <p>Example</p> <p>This is a example for relation segment</p> <pre><code>.CODE\nCELL &lt;0,0&gt;\n\"instr0\" ROUTE horizontal_dir=0, horizontal_hops=0, vertical_dir=1, vertical_hops=1, direction=0, select_drra_row=0\n\"instr1\" SWB src_row=0, src_block=0, src_port=0, hb_index=2, send_to_other_row=0, v_index=2\n\"instr2\" SWB src_row=0, src_block=0, src_port=0, hb_index=3, send_to_other_row=0, v_index=3\n\"instr3\" SWB src_row=0, src_block=0, src_port=1, hb_index=2, send_to_other_row=0, v_index=4\n\"instr4\" SWB src_row=0, src_block=0, src_port=1, hb_index=3, send_to_other_row=0, v_index=5\n\"instr5\" LOOP extra=1, loopid=0, iter=2, step=4\n\"instr6\" LOOP loopid=1, iter=3, step=2\n\"instr7\" RACCU mode=1, operand1_sd=1, operand1=14, operand2_sd=1, operand2=15, result=0 \n\"instr8\" SRAM rw=0, init_addr=0, l1_iter=3, l1_step=1, l1_delay=0, init_addr_sd=1, hops=0\n\"instr9\" REFI port_no=0, extra=2, init_addr_sd=0, init_addr=0, l1_iter=3, l1_step=1, l1_delay=0, dimarch=1\n\"instr10\" REFI port_no=2, extra=2, init_addr=0,  l1_iter=3, l1_step=1, l2_delay=2, l2_iter=28, l2_step=1 \n\"instr11\" REFI port_no=3, extra=2, init_addr=32, l1_iter=3, l1_step=1, l2_delay=2, l2_iter=28, l2_step=1\n\"instr12\" LOOP loopid=2, iter=29, step=1\n\"instr13\" DPU mode=10, control=2\n\nCELL &lt;0,1&gt;\n\"instr14\" DPU mode=1, control=2 \n\"instr15\" ROUTE horizontal_dir=0, horizontal_hops=0, vertical_dir=1, vertical_hops=1, direction=0\n\"instr16\" SWB src_row=0, src_block=1, src_port=0, hb_index=1, v_index=2 \n\"instr17\" SWB src_row=0, src_block=1, src_port=1, hb_index=1, v_index=3\n\"instr18\" SRAM l1_iter=1, l1_step=1, l1_delay=0, l2_iter=1, l2_step=2, l2_delay=0, hops=0\n\"instr19\" REFI port_no=0, extra=2, l1_iter=1, l1_step=1, dimarch=1\n\"instr20\" LOOP extra=1, loopid=0, iter=2, step=4\n\"instr21\" LOOP extra=0, loopid=1, iter=3, step=2\n\"instr22\" REFI port_no=2, extra=2, init_addr= 0, l1_iter=3, l1_step=1, l2_iter=28, l2_delay=2, l2_step=0 \n\"instr23\" REFI port_no=3, extra=2, init_addr=16, l1_iter=3, l1_step=1, l2_iter=28, l2_delay=2, l2_step=0 \n\"instr24\" LOOP loopid=2, iter=29, step=1\n\nCELL &lt;0,2&gt;\n\"instr25\" DPU mode=1, control=2 \n\"instr26\" ROUTE horizontal_dir=0, horizontal_hops=0, vertical_dir=1, vertical_hops=1, direction=0\n\"instr27\" ROUTE horizontal_dir=0, horizontal_hops=0, vertical_dir=1, vertical_hops=1, direction=1 \n\"instr28\" SWB src_row=0, src_block=0, src_port=1, hb_index=2, v_index=2\n\"instr29\" SWB src_row=0, src_block=1, src_port=0, hb_index=2, v_index=1\n\"instr30\" SWB src_row=0, src_block=1, src_port=0, hb_index=1, v_index=3\n\"instr31\" LOOP extra=1, loopid=0, iter=2, step=4\n\"instr32\" REFI port_no=3, extra=2, l1_step=1, l1_iter=28, l1_delay=5, l2_iter=2, l2_delay=25, l2_step=0\n\"instr33\" REFI port_no=1, extra=2, l1_step=1, l1_iter=28, l1_delay=5, l2_iter=2, l2_delay=25, l2_step=0\n\"instr34\" LOOP extra=0, loopid=1, iter=3, step=2\n\"instr35\" SRAM rw=0, l1_iter=1, l1_step=1, l1_delay=0, hops=0, init_addr_sd=d, init_addr=14\n\"instr36\" REFI port_no=0, extra=2, l1_iter=1, l1_step=1, dimarch=1\n\"instr37\" LOOP loopid=2, iter=29, step=1\n\"instr38\" SRAM rw=1, l1_iter=1, l1_step=1, l1_delay=0, hops= 0, init_addr_sd=d, init_addr=14\n\"instr39\" REFI port_no=2, extra=2, l1_iter=1, l1_step=1, dimarch=1\n\n.RELATION\n\"ROOT\" 1 0 [\"LOOP0\",\"Op_0_0_0_1\", \"Op_0_0_0_2\", \"Op_0_0_1_1\", \"Op_0_0_1_2\", \"Op_0_0_2_1\",\"Op_0_0_2_2\", \"Op_0_0_3_1\", \"Op_0_0_3_2\", \"Op_0_0_4_1\", \"Op_0_0_4_2\",\"Op_0_1_0_1\", \"Op_0_1_0_2\", \"Op_0_1_0_3\", \"Op_0_1_1_1\", \"Op_0_1_1_2\",\"Op_0_1_2_1\", \"Op_0_1_2_2\", \"Op_0_1_3_1\", \"Op_0_1_3_2\", \"Op_0_1_4_1\", \"Op_0_1_4_2\", \"Op_0_1_5_1\",\"Op_0_2_0_1\", \"Op_0_2_0_2\", \"Op_0_2_0_3\", \"Op_0_2_1_1\", \"Op_0_2_1_2\",\"Op_0_2_2_1\", \"Op_0_2_2_2\", \"Op_0_2_3_1\", \"Op_0_2_3_2\", \"Op_0_2_4_1\", \"Op_0_2_4_2\",\"Op_0_2_5_1\", \"Op_0_2_5_2\"] [] 0\n\n\"LOOP0\" 1 1 [\"LOOP0_BODY\",\"Op_0_0_5_1\",\"Op_0_1_6_1\",\"Op_0_2_6_1\"] [] 1\n\n\"LOOP0_BODY\" 1 0 [\"LOOP1\",\"Op_0_1_4_3\", \"Op_0_1_4_4\", \"Op_0_1_5_2\", \"Op_0_1_5_3\",\"Op_0_2_7_1\",\"Op_0_2_8_1\"] [] 0\n\n\"LOOP1\" 1 1 [\"LOOP1_BODY\",\"Op_0_0_6_1\",\"Op_0_1_7_1\",\"Op_0_2_9_1\"] [] 1\n\n\"LOOP1_BODY\" 1 0 [\"LOOP2\",\"Op_0_0_7_1\", \"Op_0_0_8_1\", \"Op_0_0_8_2\", \"Op_0_0_8_3\", \"Op_0_0_8_4\", \"Op_0_0_10_1\", \"Op_0_0_11_1\",\"Op_0_0_9_1\", \"Op_0_0_9_2\", \"Op_0_0_9_3\",\"Op_0_1_8_1\", \"Op_0_1_9_1\", \"Op_0_2_10_1\", \"Op_0_2_10_2\", \"Op_0_2_10_3\", \"Op_0_2_10_4\",\"Op_0_2_11_1\",\"Op_0_2_11_2\", \"Op_0_2_11_3\",\"Op_0_2_13_1\",\"Op_0_2_13_2\",\"Op_0_2_13_3\", \"Op_0_2_13_4\", \"Op_0_2_14_1\", \"Op_0_2_14_2\",\"Op_0_2_14_3\"] [] 0\n\n\"LOOP2\" 1 0 [\"LOOP2_BODY\", \"Op_0_0_12_1\",\"Op_0_1_10_1\", \"Op_0_2_12_1\"] [] 1\n\n\"LOOP2_BODY\" 1 0 [\"Op_0_0_13_1\", \"Op_0_0_13_2\", \"Op_0_0_13_3\", \"Op_0_0_10_2\", \"Op_0_0_10_3\", \"Op_0_0_11_2\",\"Op_0_0_11_3\", \"Op_0_1_8_2\", \"Op_0_1_8_3\",  \"Op_0_1_9_2\", \"Op_0_1_9_3\",\"Op_0_2_7_2\",\"Op_0_2_7_3\", \"Op_0_2_8_2\",\"Op_0_2_8_3\"] [] 0\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/ManasProgrammingGuide/#dependency-segment","title":"DEPENDENCY Segment","text":"<p>Dependencies among instructions are defined in dependency segment. A dependency segment starts with segment identifier:</p> <pre><code>.DEPENDENCY\n</code></pre> <p>Each instruction of DRRA has 5 phases: FETCH, ISSUE, ARRIVE, ACTIVE, END. They are represented by number: 1 to 5 respectively.</p> <p>User can define dependencies among instruction phases. These dependencies will guide the scheduler to order instructions properly. Each phase corresponds to a vertex in the dependency graph. You should know the naming convension when reference those phases. For example, the 2<sup>nd</sup> phase of the 1<sup>st</sup> instruction in cell &lt;3,5&gt; will be mapped to a vertex called Op_3_5_0_2.</p> <p>A dependency is defined by four fields:</p> <ul> <li>SRC : the source vertex name.</li> <li>DEST: the destination vertex name.</li> <li>D_LO: the lower bound of distance.</li> <li>D_HI: the higher bound of distance.</li> </ul> <p>The format is:</p> <pre><code>SRC DEST D_LO D_HI\n</code></pre> <p>Example</p> <p>This is a example for dependency segment</p> <pre><code>.DEPENDENCY\n\"0_0_0_0\" \"0_0_1_1\" 1 +INF\n\"0_0_1_1\" \"0_0_1_3\" 0 +INF\n\"1_0_1_1\" \"1_0_1_1\" 2 5\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/RepoOrganization/","title":"Repo Organization","text":"<p>Vesyla eco-system is constructed by many modules. One can create a new app in this eco-system by combining several modules.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/RepoOrganization/#module-type","title":"Module Type","text":""},{"location":"Docs/ToolChain/Vesyla-suite/v3/RepoOrganization/#executable-module","title":"Executable Module","text":"<p>The executable modules create executable applications. If written in C++, it will be compiled to an executable binary file.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/RepoOrganization/#data-module","title":"Data Module","text":"<p>The data modules define classes for various data structures. In vesyla eco-system, we encourage developer to define pure data structure using descriptive language or library. The protobuf (version 3) from Google is a very good libarary for such purpose because it's language-neutral and platform-neutral.</p> <p>Besides the pure data structure, developers should also include a handler class to provide a data access interface. Several programming language specific interfaces could be provided.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/RepoOrganization/#process-module","title":"Process Module","text":"<p>The process modules manupilate the data structer defined by other data modules. The process modules usually implement one or more algorithms to refine the data structure.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/RepoOrganization/#utility-module","title":"Utility Module","text":"<p>The utility modules include the basic functionality that is needed by the majority of other modules, such as event logging, configuration file searching, and global variable mantainance.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/RepoOrganization/#module-implementation","title":"Module Implementation","text":"<p>Each module is implemented by github submodule function.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/RepoOrganization/#module-testing","title":"Module Testing","text":"<p>Each module should have a top-level folder for testing. For executable module, the tests could be overall general testcases. We recommend to use the Robot Framework to automatically run all testcases. For other type of modules, the tests are mostly unit-tests. C++ based modules can easily be tested via standard boost test library</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/RepoOrganization/#organization","title":"Organization","text":"<p>The top-level repo is called vesyla suite. It contains all the other repo as modules. The flat and shallow dependency strucutre makes it easier to manage. There are two major executable modules: vesyla and manas.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/RepoOrganization/#branch","title":"Branch","text":"<p>We recommend to use two branches in each repo: master and develop. The master branch keeps stable version of the repo and the develop branch is for adding new features and fixing bugs. The develop branch should be merged/rebased to the master branch at least once per month.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/Tutorial_DRRA/","title":"DRRA-based AlImp Design Tutorial (v3)","text":"<p>Note</p> <p>This page is written for vesyla-suite version 3. For vesyla-suite version 2, please see  DRRA-based AlImp Design Tutorial v3.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/Tutorial_DRRA/#introduction","title":"Introduction","text":""},{"location":"Docs/ToolChain/Vesyla-suite/v3/Tutorial_DRRA/#programming-model","title":"Programming Model","text":"<p>Each algorithm compiled by vesyla-suite will be mapped to a DRRA fabric. The DRRA fabric has a globally addressable input buffer and a globally addressable output buffer, as shown in the following figure.</p> <p></p> <p>The input buffer is used to store the input data of the algorithm. The output buffer is used to store the output data of the algorithm. The input buffer and the output buffer are connected to the DRRA fabric through the input and output ports of the fabric. The input and output ports are used to connect the DRRA fabric to the outside world.</p> <p>Currently, we assume that all DRRA cells have access to both input and output buffer. This assumption might be modified in the future when introducing SiLago 2 DRRA fabric. The input bandwidth and output bandwith are determined by the number of columns of the DRRA fabric.</p> <p>Right now, we don't support scratch-pad memory implemented by DiMArch rows. This will change when migrating to SiLago 2 DRRA fabric.</p> <p>The assumption of giant globally addressable memory buffers is not realistic. However, these buffers will not be implemented as it is. Instead, application-level synthesis (ALS) tool will synthesize the input and output buffers to the actual hardware. The input and output buffers are used to simplify the algorithmic compilation process.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/Tutorial_DRRA/#initialization","title":"Initialization","text":"<p>In any directory, you can initialize a vesyla-suite project by using the command:</p> <pre><code>vs-init -s vs-vesyla\n</code></pre> <p>If this directory has already been initialized, you can force the re-initialization by using the command:</p> <pre><code>vs-init -f -s vs-vesyla\n</code></pre> <p>You will notice that several files has been created in this directory. One of the files is <code>config.json</code>. This file contains the configuration of the vesyla-suite project. You can modify this file to change the configuration of the project. The configuration file is described in the following section.</p> <p>Another file you need to modify is <code>main.cpp.jinja2</code>. This file is a template file used to generate the <code>main.cpp</code> file. You need to define some of the functions in this file. The functions are described in the following section.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/Tutorial_DRRA/#implementation","title":"Implementation","text":"<p>We use a simple example to demonstrate the implementation of algorithms. The example is a element-wise addition of two vectors. It has two inputs: vector <code>A</code> and vector <code>B</code>. It has one output: vector <code>C</code>. All of them have size equal to 16. The element-wise addition is defined as: <code>C[i] = A[i] + B[i]</code>.</p> <p>We first define the hardware architecture in <code>config.json</code>.</p> <pre><code>{\n  \"ARCH_DRRA_ROW\": 1,\n  \"ARCH_DRRA_COL\": 1,\n  \"ARCH_SRAM_ROW\": 0,\n  \"ARCH_SRAM_COL\": 0,\n  \"ARCH_SRAM_DEPTH\": 64,\n  \"ARCH_SRAM_WIDTH\": 256,\n  \"ARCH_RF_DEPTH\": 64,\n  \"ARCH_RF_WIDTH\": 16,\n  \"ARCH_IO_DEPTH\": 1024,\n  \"ARCH_IO_WIDTH\": 256,\n  \"ARCH_IRAM_DEPTH\": 64\n}\n</code></pre> <p><code>ARCH_DRRA_ROW</code> and <code>ARCH_DRRA_COL</code> are the number of rows and columns of the DRRA fabric. <code>ARCH_SRAM_ROW</code> and <code>ARCH_SRAM_COL</code> are the number of rows and columns of the SRAM array used as scratch-pad memory. <code>ARCH_SRAM_DEPTH</code> is the depth of each SRAM cell. <code>ARCH_SRAM_WIDTH</code> is the width of each SRAM cell in terms of bits. In this example, we will not use any SRAM cell. <code>ARCH_RF_DEPTH</code> is the depth of each register file. <code>ARCH_RF_WIDTH</code> is the width of each register file in terms of bits. <code>ARCH_IO_DEPTH</code> is the depth of each input and output buffer. <code>ARCH_IO_WIDTH</code> is the width of each input and output buffer in terms of bits. <code>ARCH_IRAM_DEPTH</code> is the depth of the instruction RAM in each DRRA cell.</p> <p>Before we implement the algorithm in <code>main.cpp.jinja2</code>, we need to define the input and output data layout in input and output buffer. Both input and output buffer has width that equals to 256 bits. So, each row can be divided by 16 16-bit chunks, each of which stores an element of <code>A</code>, <code>B</code>, or <code>C</code>. The layout is described by the following table.</p> <pre><code>Input Buffer:\n+------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n| addr | CHK0| CHK1| CHK2| CHK3| CHK4| CHK5| CHK6| CHK7| CHK8| CHK9|CHK10|CHK11|CHK12|CHK13|CHK14|CHK15|\n+------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n|    0 | A[0]| A[1]| A[2]| A[3]| A[4]| A[5]| A[6]| A[7]| A[8]| A[9]|A[10]|A[11]|A[12]|A[13]|A[14]|A[15]|\n|    1 | B[0]| B[1]| B[2]| B[3]| B[4]| B[5]| B[6]| B[7]| B[8]| B[9]|B[10]|B[11]|B[12]|B[13]|B[14]|B[15]|\n+------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n\nOutput Buffer:\n+------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n| addr | CHK0| CHK1| CHK2| CHK3| CHK4| CHK5| CHK6| CHK7| CHK8| CHK9|CHK10|CHK11|CHK12|CHK13|CHK14|CHK15|\n+------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n|    0 | C[0]| C[1]| C[2]| C[3]| C[4]| C[5]| C[6]| C[7]| C[8]| C[9]|C[10]|C[11]|C[12]|C[13]|C[14]|C[15]|\n+------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n</code></pre> <p>In <code>main.cpp.jinja2</code>, you need to implement the following functions:</p> <ul> <li><code>void init()</code>: This function is used to initialize the input buffer.</li> <li><code>void model_l0()</code>: This function is used to implement the algorithm in the level 0 model. It's a pure software implementation of the algorithm. It's used to verify the correctness of the algorithm.</li> <li><code>void model_l1()</code>: This function is used to implement the algorithm in the level 1 model. It will be the input of vesyla-suite compiler. It's a software implementation of the algorithm with some hardware primitives. For syntax, plaese refer to Vesyla Programming Guide.</li> </ul> <p>We implement these functions one by one.</p> <p>The <code>init()</code> function is used to initialize the input buffer. It's a pure software implementation. The following code shows how to initialize the input buffer.</p> <pre><code>void init(){\n  // Set the seed for random number generator\n  srand((unsigned) time(NULL));\n\n  // Generate 32 random numbers in range [0,100) for both vector A and B\n  vector&lt;int16_t&gt; v(32);\n  for(auto i=0; i&lt;32; i++){\n    v[i] = rand()%100;\n  }\n\n  // Write the random numbers to the input buffer at starting address 0, and the number of row to write is 2.\n  __input_buffer__.write&lt;int16_t&gt;(0, 2, v);\n}\n</code></pre> <p>The <code>model_l0()</code> function is used to implement the algorithm in the level 0 model. It's a pure software implementation of the algorithm. It's used to verify the correctness of the algorithm. The following code shows how to implement the algorithm in the level 0 model.</p> <pre><code>void model_l0(){\n  // Read the input buffer to A. The starting address is 0, and the number of row to read is 1. \n  vector&lt;int16_t&gt; a = __input_buffer__.read&lt;int16_t&gt;(0, 1);\n  // Read the input buffer to B. The starting address is 1, and the number of row to read is 1. \n  vector&lt;int16_t&gt; b = __input_buffer__.read&lt;int16_t&gt;(1, 1);\n  // Add A and B\n  vector&lt;int16_t&gt; c(16);\n  for(auto i=0; i&lt;16; i++){\n    c[i] = a[i] + b[i];\n  }\n  // Write the result C to the output buffer at starting address 0, and the number of row to write is 1.\n  __output_buffer__.write&lt;int16_t&gt;(0, 1, c);\n}\n</code></pre> <p>Now, it's time to implement the algorithm in the level 1 model. The level 1 model is a software implementation of the algorithm with some hardware primitives. It serves dual purposes. First, it's used to verify the correctness of the algorithm. Second, it's used as the input of the compiler. The following code shows how to implement the algorithm in the level 1 model.</p> <pre><code>void model_l1(){\n  // Declare the input and output streams. The input and output streams are disorganized data after reading or before writing to the input and output buffer.\n  STREAM_IO_CHUNK sab, sc;\n  // Read the input buffer to sab. The starting address is 0, the step is 1, and the number of row to read is 2. This stream include data for both A and B.\n  sab=silago_io_read(__input_buffer__, silago_agu_affine_1(0,1,2));\n\n  // Declare the RF variable to model register file. We use pragma to bind it to the register file in cell [0,0]. We then store the data stream to the register file.\n  #pragma bind rf_0_0\n  RF rf_0_0;\n  rf_0_0 = silago_rf_write_from_io_stream (sab, silago_agu_affine_1(0,1,2), rf_0_0);\n\n  // Declare the register file streams.\n  STREAM_RF_CHUNK aa, bb, cc;\n  // Read the data from the register file to aa and bb.\n  aa = silago_rf_read(rf_0_0, silago_agu_affine_1(0,1,16));\n  bb = silago_rf_read(rf_0_0, silago_agu_affine_1(16,1,16));\n  // We use pragma to bind the following arithmetic operation to DPU[0,0]. We then add aa and bb and produce cc.\n  #pragma bind dpu_0_0\n  cc = silago_dpu_add(aa, bb);\n  // The stream cc is stored to the register file.\n  rf_0_0 = silago_rf_write(cc, silago_agu_affine_1(0,1,16), rf_0_0);\n\n  // Read the data from the register file to sc to generate the output stream sc.\n  sc = silago_rf_read_to_io_stream (rf_0_0 , silago_agu_affine_1(0,1,1));\n  // We then write the output stream sc to the output buffer.\n  __output_buffer__=silago_io_write(sc, silago_agu_affine_1(0,1,1), __output_buffer__);\n}\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/Tutorial_DRRA/#simulation-and-verification","title":"Simulation and Verification","text":"<p>To simulate the algorithm, simply run:</p> <pre><code>./run.sh\n</code></pre> <p>If the output shows the simulation is successful, then the algorithm is correct.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/Tutorial_RISCV/","title":"RISCV-based AlImp Design Tutorial","text":""},{"location":"Docs/ToolChain/Vesyla-suite/v3/Tutorial_RISCV/#introduction","title":"Introduction","text":""},{"location":"Docs/ToolChain/Vesyla-suite/v3/Tutorial_RISCV/#programming-model","title":"Programming Model","text":"<p>Algorithms with intensive control flow or scalar computation should be mapped on processor-like computation nodes. Vesyla-suite support the mapping of algorithms to RISC-V processor. The RISC-V based computation nodes have the same I/O interface as the DRRA-based computation nodes to communicate with a globally addressable input buffer and a globally addressable output buffer, as shown in the following figure.</p> <p></p> <p>The input buffer is used to store the input data of the algorithm. The output buffer is used to store the output data of the algorithm. The input buffer and the output buffer are connected to the RISC V computation node through the input and output ports of the fabric. The input and output ports are used to connect the RISC V to the outside world.</p> <p>Currently, we assume that RISC V core accesses both input and output buffer through peripheral interface: the read_unit and write_unit. The bandwith of the read_unit and write_unit are fixed as 1 channel because a RISC V core only has 1 thread. The wide bandwidth of the input and output ports are more than enough for the RISC V core. The RISC V core considers the read_unit and write_unit as memory mapped peripheral devices. Each of them has a 64-bit configuration register that can be accessed by the RISC V core via the bus. The address for the read_unit configuration register is <code>0x80000000</code>, and the write_unit configuration register is <code>0x80000008</code>. All data are organized in little endian style. The configuration register fields are shown in the following table.</p> Field Name (MSB to LSB) Bit Width Description enable 1 Enable the read_unit or write_unit. addr_ext 25 The address of the input or output buffer. addr_int 5 The address of the internal SRAM. unused 1 Unused. step_ext 5 The step size of the input or output buffer. step_int 5 The step size of the internal SRAM. iter 5 The number of iterations. unused 17 Unused. <p>There is a 1 kB scratch-pad SRAM array working as the main data memory for the RISC V core. The RISC V core can access the SRAM array through the load and store instructions. The read_unit and write_unit can also bring data from or store data to the outside world.</p> <p>The assumption of giant globally addressable memory buffers is not realistic. However, these buffers will not be implemented as it is. Instead, application-level synthesis (ALS) tool will synthesize the input and output buffers to the actual hardware. The input and output buffers are used to simplify the algorithmic compilation process.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/Tutorial_RISCV/#initialization","title":"Initialization","text":"<p>In any directory, you can initialize a vesyla-suite project for RISC V by using the command:</p> <pre><code>vs-init -s vs-rvsim\n</code></pre> <p>If this directory has already been initialized, you can force the re-initialization by using the command:</p> <pre><code>vs-init -f -s vs-rvsim\n</code></pre> <p>You will notice that several files has been created in this directory. One of the files is <code>config.json</code>. This file contains the configuration of the vesyla-suite project. You can modify this file to change the configuration of the project. The configuration file is described in the following section.</p> <p>Another file you need to modify is <code>main.cpp.jinja2</code>. This file is a template file used to generate the <code>main.cpp</code> file. You need to define some of the functions in this file. The functions are described in the following section.</p> <p>The last file you need to modify is <code>instruction.bin</code>. This file contains the instructions of the RISC V core in binary or hex form. You need to generate the instructions and write them to this file. The easiest way is to write assembly code and compile it by using RISC V assembler.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/Tutorial_RISCV/#implementation","title":"Implementation","text":"<p>We use a simple example to demonstrate the implementation of algorithms. The example is a element-wise addition of two vectors. It has two inputs: vector <code>A</code> and vector <code>B</code>. It has one output: vector <code>C</code>. All of them have size equal to 16. The element-wise addition is defined as: <code>C[i] = A[i] + B[i]</code>.</p> <p>We first define the hardware architecture in <code>config.json</code>.</p> <pre><code>{\n  \"style\": \"vs-rvsim\",\n  \"ARCH_IO_DEPTH\": 1024,\n  \"ARCH_IO_WIDTH\": 256,\n  \"ARCH_SRAM_SIZE\": 1024,\n  \"ARCH_IRAM_SIZE\": 1024\n}\n</code></pre> <p><code>ARCH_IO_DEPTH</code> is the depth of each input and output buffer. <code>ARCH_IO_WIDTH</code> is the width of each input and output buffer in terms of bits. <code>ARCH_SRAM_SIZE</code> is the size of SRAM in terms of bytes.<code>ARCH_IRAM_SIZE</code> is the depth of the instruction RAM in terms of bytes.</p> <p>Before we implement the algorithm in <code>main.cpp.jinja2</code>, we need to define the input and output data layout in input and output buffer. Both input and output buffer has width that equals to 256 bits. So, each row can be divided by 16 16-bit chunks, each of which stores an element of <code>A</code>, <code>B</code>, or <code>C</code>. The layout is described by the following table.</p> <pre><code>Input Buffer:\n+------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n| addr | CHK0| CHK1| CHK2| CHK3| CHK4| CHK5| CHK6| CHK7| CHK8| CHK9|CHK10|CHK11|CHK12|CHK13|CHK14|CHK15|\n+------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n|    0 | A[0]| A[1]| A[2]| A[3]| A[4]| A[5]| A[6]| A[7]| A[8]| A[9]|A[10]|A[11]|A[12]|A[13]|A[14]|A[15]|\n|    1 | B[0]| B[1]| B[2]| B[3]| B[4]| B[5]| B[6]| B[7]| B[8]| B[9]|B[10]|B[11]|B[12]|B[13]|B[14]|B[15]|\n+------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n\nOutput Buffer:\n+------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n| addr | CHK0| CHK1| CHK2| CHK3| CHK4| CHK5| CHK6| CHK7| CHK8| CHK9|CHK10|CHK11|CHK12|CHK13|CHK14|CHK15|\n+------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n|    0 | C[0]| C[1]| C[2]| C[3]| C[4]| C[5]| C[6]| C[7]| C[8]| C[9]|C[10]|C[11]|C[12]|C[13]|C[14]|C[15]|\n+------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n</code></pre> <p>In <code>main.cpp.jinja2</code>, you need to implement the following functions:</p> <ul> <li><code>void init()</code>: This function is used to initialize the input buffer.</li> <li><code>void model_l0()</code>: This function is used to implement the algorithm in the level 0 model. It's a pure software implementation of the algorithm. It's used to verify the correctness of the algorithm.</li> </ul> <p>We implement these functions one by one.</p> <p>The <code>init()</code> function is used to initialize the input buffer. It's a pure software implementation. The following code shows how to initialize the input buffer.</p> <pre><code>void init(){\n  // Set the seed for random number generator\n  srand((unsigned) time(NULL));\n\n  // Generate 32 random numbers in range [0,100) for both vector A and B\n  vector&lt;int16_t&gt; v(32);\n  for(auto i=0; i&lt;32; i++){\n    v[i] = rand()%100;\n  }\n\n  // Write the random numbers to the input buffer at starting address 0, and the number of row to write is 2.\n  __input_buffer__.write&lt;int16_t&gt;(0, 2, v);\n}\n</code></pre> <p>The <code>model_l0()</code> function is used to implement the algorithm in the level 0 model. It's a pure software implementation of the algorithm. It's used to verify the correctness of the algorithm. The following code shows how to implement the algorithm in the level 0 model.</p> <pre><code>void model_l0(){\n  // Read the input buffer to A. The starting address is 0, and the number of row to read is 1. \n  vector&lt;int16_t&gt; a = __input_buffer__.read&lt;int16_t&gt;(0, 1);\n  // Read the input buffer to B. The starting address is 1, and the number of row to read is 1. \n  vector&lt;int16_t&gt; b = __input_buffer__.read&lt;int16_t&gt;(1, 1);\n  // Add A and B\n  vector&lt;int16_t&gt; c(16);\n  for(auto i=0; i&lt;16; i++){\n    c[i] = a[i] + b[i];\n  }\n  // Write the result C to the output buffer at starting address 0, and the number of row to write is 1.\n  __output_buffer__.write&lt;int16_t&gt;(0, 1, c);\n}\n</code></pre> <p>Now, it's time to get the instructions for RISC V core. We first write the assembly code as following:</p> <pre><code>lui x1, 0x80000       # load the base address of read_unit and write_unit conf reg \nlui x2, 0x80000       # composing the configuration words for read_unit:\nlui x3, 0x08440       # enable=1, addr_ext=0, addr_int=0, step_ext=1, step_int=1, iter=2\nsw x3, 0(x1)          # write to conf reg, lower half\nsw x2, 4(x1)          # write to conf reg, upper half\n\naddi x4, x0, 32       # offset address boundry, used for loop end condition\naddi x5, x0, 0        # loop iterator, also work as address\n__back:\nlh x7, 0(x5)          # load one element in A (16-bit)\nlh x8, 32(x5)         # load one element in B (16-bit)\nadd x7, x7, x8        # add\nsh x7, 64(x5)         # store the result\naddi x5, x5, 2        # update iterator by 2 since 16-bit is 2 bytes\nblt x5, x4, __back    # check loop condition and jump\n__done:\n\nlui x2, 0x80000       # composing the configuration words for read_unit:\naddi x2, x2, 0x004    # enable=1, addr_ext=0, addr_int=2, step_ext=1, step_int=1, iter=1\nlui x3, 0x08420       \nsw x3, 8(x1)          # write to conf reg, lower half    \nsw x2, 12(x1)         # write to conf reg, upper half  \n\naddi x0, x0, 0        # NOP, wait the data transfer to complete\naddi x0, x0, 0        # NOP, wait the data transfer to complete\n</code></pre> <p>Then, we use the online RISC V assembler to compile and get the hex instructions. The following figure shows the result.</p> <pre><code>800000b7\n80000137\n084401b7\n0030a023\n0020a223\n02000213\n00000293\n00029383\n02029403\n008383b3\n04729023\n00228293\nfe42c6e3\n80000137\n00410113\n084201b7\n0030a423\n0020a623\n00000013\n00000013\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/Tutorial_RISCV/#simulation-and-verification","title":"Simulation and Verification","text":"<p>To simulate the algorithm, simply run:</p> <pre><code>./run.sh\n</code></pre> <p>If the output shows the simulation is successful, then the algorithm is correct.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/VesylaProgrammingGuide/","title":"Vesyla Programming Guide (v3)","text":"<p>Note</p> <p>This page is written for vesyla-suite version 3. For vesyla-suite version 2, please see Vesyla Programming Guide v2.</p> <p>Note</p> <p>Vesyla-suite version 3 is under active development. Some of the features that exists on version 2 may not be available on version 3. We will update this page actively to reflect the changes.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/VesylaProgrammingGuide/#basics","title":"Basics","text":""},{"location":"Docs/ToolChain/Vesyla-suite/v3/VesylaProgrammingGuide/#general-guide","title":"General Guide","text":"<p>Vesyla accept modified C++ code as input language. You shouldn't write the C++ code like a programming language. You should instead use it as a tool to model the behaviour of the hardware. Vesyla supports small portion of C++ grammar. There are some generic rules expressing the programming style vesyla accepts.</p> <ul> <li>General function call is not allowed unless the function is predefined as primitive function.</li> <li>Variables except for constant variable and loop iterator should always model real memory components, and should be declared with implicit or explicit pragma.</li> <li>Supported constant numbers are integers.</li> <li>For-loop is supported. If-statement is largely supported. While-loop is not supported.</li> </ul>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/VesylaProgrammingGuide/#pragma","title":"Pragma","text":"<p>Pragma is the notation that guides Vesyla during synthesis process. Vesyla recognize pragma starting with symbols <code>#pragma</code>. The main function of pragmas is specify allocation and binding information since Vesyla can't perform automatic allocation and binding. Section Variable Declaration, Arithmetic Operation, Address Constraint DPU Chain and DPU Internal Scalar Register describe how to use pragmas to allocate and bind resources. Some other usage of pragma also exist, check section Resource Sharing Region for more detail.</p> <p>There are two types of pragmas: single-line pragma and block pragma. Single-line pragma only affects the statement immediately following it. Block pragma affects all statements within the block. Block pragma is started with <code>#pragma start</code> and ended with <code>#pragma end</code>. The following example shows how to use pragmas to allocate and bind resources.</p> <p>Example</p> <pre><code>Explicit single-line pragma that binds the variable a to register file [0,0]\n```c++\n#pragma bind rf_0_0\nRF a;\n```\n\nImplicit binding without pragma that binds the variable rf_0_1 to register file [0,1]\n```c++\nRF rf_0_1;\n```\n\nBlock pragma that makes declare a conflict-free zone.\n```c++\n#pragma start conflict_free_zone\n...\n...\n#pragma end conflict_free_zone\n```\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/VesylaProgrammingGuide/#variable-declaration","title":"Variable Declaration","text":""},{"location":"Docs/ToolChain/Vesyla-suite/v3/VesylaProgrammingGuide/#storage-variable","title":"Storage Variable","text":"<p>There is three type of vector storage variables: Register file variable, SRAM variable and I/O variable. Register file variable is used to model register file. SRAM variable is used to model SRAM scratch-pad memory. I/O variable is used to model input and output buffer.</p> <p>Example</p> <pre><code>Declare a register file variable.\n```c++\n#pragma bind rf_0_0\nRF a;\n```\n\nDeclare a SRAM variable.\n```c++\n#pragma bind sram_0_0\nSRAM b;\n```\n</code></pre> <p>You should not declare any I/O variables. They are defined as global varialbes in the generated header file. You can use them as normal variables. The input buffer is named <code>__input_buffer__</code> and the output buffer is named <code>__output_buffer__</code>. You can only read from input buffer and write to output buffer. Writing to input buffer and reading from output buffer are not allowed.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/VesylaProgrammingGuide/#transient-variable","title":"Transient Variable","text":"<p>Transient variables are not tight to any hardware resource. It describes the unorganized stream of data after reading from the source storage variables and before writing to the destination storage variables.</p> <p>The type of transient variables depend on the supported data transfer mode on DRRA fabric. Currently, we support four types of transient variable types:</p> <ul> <li><code>STREAM_IO_CHUNK</code>: Data stream between IO and RF.</li> <li><code>STREAM_SRAM_CHUNK</code>: Data stream between SRAM and RF.</li> <li><code>STREAM_RF_CHUNK</code>: Data stream between RF and RF, between RF and DPU, and between DPU and DPU.</li> <li><code>STREAM_ADDR</code>: A stream of address made of integers.</li> </ul>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/VesylaProgrammingGuide/#scalar-auxiliary-variable","title":"Scalar Auxiliary Variable","text":"<p>Auxiliary variables are usually used for address calculation. They are not tight to any hardware resource. They can only be declared as <code>int</code> type at the moment.</p> <p>Example</p> <pre><code>Declare and use scalar auxiliary variables.\n```c++\nint i, j;\nfor (i=0; i&lt;10; i=i+1){\n    j=i+1;\n    ...\n}\n```\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/VesylaProgrammingGuide/#primitive-function-for-address-generation","title":"Primitive Function for Address Generation","text":"<p>Vesyla has certain reading or writing primitive functions to interact with storage variables. These primitive functions usually require address stream to specify which chunk of data is affected. To generate such address stream, you need to use primitive functions designed for address generation. Currently, three primitive functions are supported. The following example shows how to use these primitive functions to generate address stream.</p> <p>Example</p> <pre><code>Generate an address stream that contains only one address.\n```c++\nSTREAM_ADDR addr = silago_agu_constant(1);\n```\n\nGenerate a 1-d affine address stream that start from 0, increment by 1, and has 10 elements.\n```c++\nSTREAM_ADDR addr = silago_agu_affine_1(0, 1, 10);\n```\n\nGenerate a 2-d affine address stream that start from 0, increment by 1, and has 10 elements as level 1 and increment by 2 and has 20 elements as level 2.\n```c++\nSTREAM_ADDR addr = silago_agu_affine_2(0, 1, 10, 2, 20);\n```\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/VesylaProgrammingGuide/#primitive-function-for-arithmetic-operation","title":"Primitive Function for Arithmetic Operation","text":"<p>Certain type of arithmetic operations are supported by Vesyla. They are addition, subtraction, dot multiplication, etc. Other arithmetic operations need to be mapped to special DPU mode by primitive function call. We recommend to always use primitive function call to perform arithmetic operation. The following example shows how to use these primitive functions to perform arithmetic operation.</p> <p>Example</p> <pre><code>Perform operation: ``c = a + b``\n```c++\n#pragma bind dpu_0_0\nc = silago_dpu_add(a, b);\n```\n</code></pre> <p>Note that, you should always specify the binding information for arithmetic operations mapped to DPU. Otherwise, Vesyla will not be able to perform allocation and binding.</p> <p>If a primitive function has multiple outputs, you can use the <code>tie()</code> function to bundle them to a tuple. For example:</p> <p>Example</p> <pre><code>Perform operation: ``e = a + b`` and ``f = c + d``\n```c++\n#pragma bind dpu_0_0\ntie(e, f) = silago_dpu_add_2(a, b, c, d);\n```\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/VesylaProgrammingGuide/#loop","title":"Loop","text":"<p>Vesyla accept very restrict loop syntax to simplify the parsing process. A static loop should have constant start point, static increment as well as static iteration. If an expression that can be simplified to a constant number, it also considered as constant, hence can be used in static loop. Example below shows how to use a static loop.</p> <p>Example</p> <pre><code>int n;\nn = 3;\nfor (i=0; i&lt;n+1; i=i+1){\n    ...\nend\n</code></pre> <p>Vesyla support limited dynamic loops. Dynamic loop can have dynamic start point. But the iteration number should be constant.</p> <p>Example of such dynamic loop is shown below:</p> <p>Example</p> <pre><code>for (i=1; i&lt;4; i=i+1)\n    for (j=i; j&lt;i+3; j=j+1)\n        ...\n    end\nend\n</code></pre> <p>Warning</p> <pre><code>Vesyla does not support while-loop style dynamic loop with dynamic iteration number. Free style for-loop that implements a dynamic loop is not supported as well.\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/VesylaProgrammingGuide/#advanced-features","title":"Advanced Features","text":""},{"location":"Docs/ToolChain/Vesyla-suite/v3/VesylaProgrammingGuide/#dpu-chain","title":"DPU Chain","text":"<p>Datapath can be configured as a chain of DPU operation. The output of the previous DPU will immediately enter the next DPU without any register file involved in between. Consider we want to compute a vector addition and a sigmoid function: z = \\sigma (x+y). We can employ two DPUs to perform the complete operation in pipelined fashion. By writing the matlab like the following, you can enable the feature.</p> <p>Example</p> <pre><code>#pragma bind dpu_0_0\nt = silago_dpu_mac(x, y);\n#pragma bind dpu_0_1\nz = silago_dpu_sigm(t);\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/VesylaProgrammingGuide/#a-complete-example","title":"A Complete Example","text":"<p>Here is a complete example of a Vesyla program. The program is a simple vector addition.</p> <pre><code>void model_l1(){\n    // Read from input buffer\n    STREAM_IO_CHUNK sab, sc;\n    #pragma bind rf_0_0\n    RF rf_0_0;\n    sab=silago_io_read(__input_buffer__, silago_agu_affine_1(0,1,2));\n    rf_0_0 = silago_rf_write_from_io_stream (sab, silago_agu_affine_1(0,1,2), rf_0_0);\n\n    // Read from register file\n    STREAM_RF_CHUNK aa, bb, cc;\n    aa = silago_rf_read(rf_0_0, silago_agu_affine_1(0,1,16));\n    bb = silago_rf_read(rf_0_0, silago_agu_affine_1(16,1,16));\n\n    // Computation\n    #pragma bind dpu_0_0\n    cc = silago_dpu_add(aa, bb);\n\n    // Write to register file\n    rf_0_0 = silago_rf_write(cc, silago_agu_affine_1(0,1,16), rf_0_0);\n\n    // Write to output buffer\n    sc = silago_rf_read_to_io_stream (rf_0_0 , silago_agu_affine_1(0,1,1));\n    __output_buffer__=silago_io_write(sc, silago_agu_affine_1(0,1,1), __output_buffer__);\n}\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/isa/","title":"Isa","text":"<p>Note</p> <p>Instruction fields marked by bold font are controllable and observable. Users can modify these fields in Manas input file.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/isa/#halt","title":"HALT","text":"Field Position Width Default Value Description instr_code [26, 23] 4 0 Instruction code for HALT"},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/isa/#refi","title":"REFI","text":"Field Position Width Default Value Description instr_code [80, 77] 4 1 Instruction code for REFI port_no [76, 75] 2 0 Selects one of the RFile port. [0]:w0; [1]:w1; [2]:r0; [3]:r1; extra [74, 73] 2 0 How many following chunks? init_addr_sd [72, 72] 1 0 Is init_addr static or dymamic? [0]:s; [1]:d; init_addr [71, 66] 6 0 Initial address. l1_iter [65, 60] 6 0 Level-1 iteration - 1. init_delay [59, 54] 6 0 Initial delay. l1_iter_sd [53, 53] 1 0 Is level-1 iteration static or dymamic? [0]:s; [1]:d; init_delay_sd [52, 52] 1 0 Is initial delay static or dynamic? [0]:s; [1]:d; unused_0 [51, 50] 2 2 Deprecated. l1_step_sd [49, 49] 1 0 Is level-1 step static or dynamic? [0]:s; [1]:d; l1_step [48, 43] 6 1 Level-1 step l1_step_sign [42, 42] 1 0 The sign of level-1 step. [0]:+; [1]:-; l1_delay_sd [41, 41] 1 0 Is the level-1 delay static or dynamic? [0]:s; [1]:d; l1_delay [40, 37] 4 0 The level-1 delay, middle delay l2_iter_sd [36, 36] 1 0 Is level-2 iteration static or dymamic? [0]:s; [1]:d; l2_iter [35, 31] 5 0 The level-2 iteration - 1. l2_step [30, 27] 4 1 The level-2 step. unused_1 [26, 23] 4 3 Deprecated. l2_delay_sd [22, 22] 1 0 Is the level-2 delay static or dynamic? [0]:s; [1]:d; l2_delay [21, 16] 6 0 The level-2 delay, repetition delay. unused_2 [15, 10] 6 0 Deprecated. l1_delay_ext [9, 8] 2 0 The extened bits near MSB of l1_delay. l2_iter_ext [7, 7] 1 0 The extened bits near MSB of l2_iter. l2_step_ext [6, 5] 2 0 The extened bits near MSB of l2_step. unused_3 [4, 2] 3 0 Deprecated. dimarch [1, 1] 1 0 Is reading/writing from/to DiMArch? [0]:n; [1]:y; compress [0, 0] 1 0 Is the data compressed? [0]:n; [1]:y;"},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/isa/#dpu","title":"DPU","text":"Field Position Width Default Value Description instr_code [26, 23] 4 4 Instruction code for DPU mode [22, 18] 5 0 The DPU mode. [0]:idle; [1]:add; [2]:sum_acc; [3]:add_const; [4]:subt; [5]:subt_abs; [6]:mode_6; [7]:mult; [8]:mult_add; [9]:mult_const; [10]:mac; [11]:ld_ir; [12]:axpy; [13]:max_min_acc; [14]:max_min_const; [15]:mode_15; [16]:max_min; [17]:shift_l; [18]:shift_r; [19]:sigm; [20]:tanhyp; [21]:expon; [22]:lk_relu; [23]:relu; [24]:div; [25]:acc_softmax; [26]:div_softmax; [27]:ld_acc; [28]:scale_dw; [29]:scale_up; [30]:mac_inter; [31]:mode_31; control [17, 16] 2 2 The controll mode: saturation and operator type. [0]:nosat_int; [1]:nosat_fx; [2]:sat_int; [3]:sat_fx; unused_0 [15, 10] 6 2 Deprecated. acc_clear [9, 2] 8 0 The accumulator clear signal will be triggered if the accumulation reaches this number. It also serves as immediate value for some DPU mode. io_change [1, 0] 2 0 The IO mode: negate input and absolute output. [0]:no_change; [1]:negate_in0; [2]:negate_in1; [3]:abs_out;"},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/isa/#swb","title":"SWB","text":"Field Position Width Default Value Description instr_code [26, 23] 4 5 Instruction code for SWB unused0 [22, 22] 1 1 Deprecated. src_row [21, 21] 1 0 Source row. src_block [20, 20] 1 0 Source block, RF or DPU. [0]:rf; [1]:dpu; src_port [19, 19] 1 0 source port. hb_index [18, 16] 3 0 Index of horizontal bus. This is the column difference of the src and dest cell shifting by 2. For example if the path is from [0,0] to [1,2], the column difference is -2, so the hb_index = -2+2=0. send_to_other_row [15, 15] 1 0 Flag of whether src and dest row are equal. [0]:n; [1]:y; v_index [14, 12] 3 0 Index of vertical bus. This is the dest port. If destination is RF, the v_index is the port number, if the dest is DPU, the v_index is port number + 2."},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/isa/#jump","title":"JUMP","text":"Field Position Width Default Value Description instr_code [26, 23] 4 6 Instruction code for JUMP pc [22, 17] 6 0 The PC to jump to"},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/isa/#wait","title":"WAIT","text":"Field Position Width Default Value Description instr_code [26, 23] 4 7 Instruction code for WAIT cycle_sd [22, 22] 1 0 Is the cycle static or dynamic? [0]:s; [1]:d; cycle [21, 7] 15 0 Number of cycles - 1"},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/isa/#loop","title":"LOOP","text":"Field Position Width Default Value Description instr_code [53, 50] 4 8 Instruction code for LOOP extra [49, 49] 1 0 How many following chunks? loopid [48, 47] 2 0 The id of the loop manager slot. endpc [46, 41] 6 0 The PC where loop ends. start_sd [40, 40] 1 0 Is the start static or dynamic? [0]:s; [1]:d; start [39, 34] 6 0 The start of iterator. iter_sd [33, 33] 1 0 Is the iteration count static or dynamic? [0]:s; [1]:d; iter [32, 27] 6 0 The number of iteration. step_sd [26, 26] 1 0 Is the step static or dynamic? [0]:s; [1]:d; step [25, 20] 6 1 The iteration step. link [19, 16] 4 0 The loops that have the same endpc will be linked together. This field is 1-hot encoded."},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/isa/#bw","title":"BW","text":"Field Position Width Default Value Description instr_code [26, 23] 4 9 Instruction code for BW config [22, 21] 2 0 Bitwidth configuration for DPU: 4-bit, 8-bit, 16-bit"},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/isa/#raccu","title":"RACCU","text":"Field Position Width Default Value Description instr_code [26, 23] 4 10 Instruction code for RACCU mode [22, 20] 3 0 RACCU mode [0]:idle; [1]:add; [2]:sub; [3]:shift_r; [4]:shift_l; [5]:mult; [6]:mult_add; [7]:mult_sub; operand1_sd [19, 19] 1 0 Is the first operand static or dynamic? [0]:s; [1]:d; operand1 [18, 12] 7 0 First operand. operand2_sd [11, 11] 1 0 Is the second operand static or dynamic? [0]:s; [1]:d; operand2 [10, 4] 7 0 Second operand. result [3, 0] 4 0 The RACCU register to store the result."},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/isa/#branch","title":"BRANCH","text":"Field Position Width Default Value Description instr_code [26, 23] 4 11 Instruction code for BRANCH mode [22, 21] 2 0 The branch mode false_pc [20, 15] 6 0 The PC to jump to in case the condition is false."},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/isa/#route","title":"ROUTE","text":"Field Position Width Default Value Description instr_code [26, 23] 4 12 Instruction code for ROUTE horizontal_dir [22, 22] 1 0 The horizontal direction: West or East. [0]:w; [1]:e; horizontal_hops [21, 19] 3 0 The horizontal hops. vertical_dir [18, 18] 1 0 The vertical direction: South or North. [0]:s; [1]:n; vertical_hops [17, 15] 3 0 The vertical hops. direction [14, 14] 1 0 The data transfer direction: Read or Write. [0]:r; [1]:w; select_drra_row [13, 13] 1 0 The drra row that send/recieve the data."},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/isa/#sram","title":"SRAM","text":"Field Position Width Default Value Description instr_code [80, 77] 4 13 Instruction code for SRAM rw [76, 76] 1 0 Read or Write [0]:r; [1]:w; init_addr [75, 69] 7 0 Initial address init_delay [68, 65] 4 0 initial delay l1_iter [64, 58] 7 0 level-1 iteration - 1. l1_step [57, 50] 8 1 level-1 step l1_delay [49, 44] 6 0 level-1 delay l2_iter [43, 37] 7 0 level-2 iteration - 1. l2_step [36, 29] 8 1 level-2 step l2_delay [28, 23] 6 0 level-2 delay init_addr_sd [22, 22] 1 0 Is initial address static or dynamic? [0]:s; [1]:d; l1_iter_sd [21, 21] 1 0 Is level-1 iteration static or dynamic? [0]:s; [1]:d; l2_iter_sd [20, 20] 1 0 Is level-2 iteration static or dynamic? [0]:s; [1]:d; init_delay_sd [19, 19] 1 0 Is initial delay static or dynamic? [0]:s; [1]:d; l1_delay_sd [18, 18] 1 0 Is level-1 delay static or dynamic? [0]:s; [1]:d; l2_delay_sd [17, 17] 1 0 Is level-2 delay static or dynamic? [0]:s; [1]:d; l1_step_sd [16, 16] 1 0 Is level-1 step static or dynamic? [0]:s; [1]:d; l2_step_sd [15, 15] 1 0 Is level-2 step static or dynamic? [0]:s; [1]:d; hops [14, 11] 4 0 Number of hops to reach the DiMArch cell - 1"},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/isa/#io","title":"IO","text":"Field Position Width Default Value Description instr_code [80, 77] 4 13 Instruction code for IO rw [76, 76] 1 0 Read or Write. [0]:r; [1]:w; init_addr [75, 51] 25 0 Initial address init_delay [50, 45] 6 0 initial delay l1_iter [44, 40] 5 0 level-1 iteration - 1. l1_step [39, 35] 5 1 level-1 step l1_delay [34, 29] 6 0 level-1 delay mask [28, 13] 16 0 mask it to 1 if a word is not useful. init_addr_sd [12, 12] 1 0 Is initial address static or dynamic? [0]:s; [1]:d; init_delay_sd [11, 11] 1 0 Is initial delay static or dynamic? [0]:s; [1]:d; l1_iter_sd [10, 10] 1 0 Is level-1 iteration static or dynamic? [0]:s; [1]:d; l1_step_sd [9, 9] 1 0 Is level-1 step static or dynamic? [0]:s; [1]:d;"},{"location":"Docs/ToolChain/Vesyla-suite/v3/InstructionSet/isa/#perm","title":"PERM","text":"Field Position Width Default Value Description instr_code [26, 23] 4 14 Instruction code for SHUFFLE mode [22, 20] 3 0 Shuffle mode. [0]:left shift (zero-fill); [1]:right shift (zero-fill); [2]:left shift (same fill); [3]:right shift (same fill); [4]:left rotate; [5]:right rotate; block [19, 18] 2 0 Sub-block in register file. distance [17, 2] 16 0 shuffle distance."},{"location":"Docs/ToolChain/Vesyla-suite/v4/Architecture/","title":"Architecture Description","text":""},{"location":"Docs/ToolChain/Vesyla-suite/v4/Architecture/#main-concepts","title":"Main Concepts","text":""},{"location":"Docs/ToolChain/Vesyla-suite/v4/Architecture/#resources","title":"Resources","text":"<p>Resources are the basic building blocks for implement vector processing. Typical resources include register files, SRAMs, IOs, and DPUs. Each resource can occupy a number of slots. The interconnection interface attached on each resource is standardized. They can be either word level or bulk level. Word level interface is used for intra-cell communication, while bulk level interface is used for inter-cell communication.</p> <p>A slot is the basic \"place-holder\" for a resource. It can be either occupied or unoccupied. Each slot contains a instruction decoder, a function implementation space, a word-level input port, a word-level output port, a bulk-level input port and a bulk-level output port.</p> <p>A resource can occupy one or more continuous slots. The number of slots occupied by a resource is called the resource size. The resource size is determined by several factors, including the number of input/output ports, the complexity of the function logic, etc.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/Architecture/#controllers","title":"Controllers","text":"<p>A controller is the building block that manages the resources in a cell. It issues instructions into the slots of the resources. The controller can have many flavors, varying its instruction memory size, maximum slot number, RACCU register width, etc.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/Architecture/#cells","title":"Cells","text":"<p>Each cell consists of a controller and one or more resources. The controller manages the resources in the cell. The resources can be either homogeneous or heterogeneous. Only bulk-level interface is visible between cells.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/Architecture/#fabric","title":"Fabric","text":"<p>The fabric is the collection of cells. The cells are connected together using bulk-level interface. The fabric can be either homogeneous or heterogeneous. The cells in a fabric is arranged in a 2-D mesh style.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/Architecture/#json-schema","title":"JSON Schema","text":"<p>Validation</p> <p>You can validate a architecture description json file using this schema on Json Schema Validator.</p> <p>The architecture description file uses json format and validated by the following json schema:</p> <pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"platform\": { \"type\": \"string\" },\n    \"resources\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": { \"type\": \"string\" },\n          \"size\": { \"type\": \"integer\" },\n          \"word_input_port\": { \"type\": \"integer\" },\n          \"word_output_port\": { \"type\": \"integer\" },\n          \"bulk_input_port\": { \"type\": \"integer\" },\n          \"bulk_output_port\": { \"type\": \"integer\" }\n        },\n        \"required\": [\n          \"name\",\n          \"size\",\n          \"word_input_port\",\n          \"word_output_port\",\n          \"bulk_input_port\",\n          \"bulk_output_port\"\n        ]\n      },\n      \"uniqueItems\": true\n    },\n    \"controllers\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": { \"type\": \"string\" },\n          \"size\": { \"type\": \"integer\" },\n          \"iram_size\": { \"type\": \"integer\" },\n          \"reg_bitwidth\": { \"type\": \"integer\" }\n        },\n        \"required\": [\"name\", \"size\", \"iram_size\", \"reg_bitwidth\"]\n      },\n      \"uniqueItems\": true\n    },\n    \"cells\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": { \"type\": \"string\" },\n          \"controller\": { \"type\": \"string\" },\n          \"resource_list\": {\n            \"type\": \"array\",\n            \"items\": { \"type\": \"string\" }\n          }\n        },\n        \"required\": [\"name\", \"controller\", \"resource_list\"]\n      },\n      \"uniqueItems\": true\n    },\n    \"fabric\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"width\": { \"type\": \"integer\" },\n        \"height\": { \"type\": \"integer\" },\n        \"cell_list\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"properties\": {\n              \"coordinates\": {\n                \"type\": \"array\",\n                \"items\": {\n                  \"type\": \"object\",\n                  \"properties\": {\n                    \"row\": { \"type\": \"integer\" },\n                    \"col\": { \"type\": \"integer\" }\n                  },\n                  \"required\": [\"row\", \"col\"]\n                },\n                \"uniqueItems\": true\n              },\n              \"cell\": { \"type\": \"string\" }\n            },\n            \"required\": [\"coordinates\", \"cell\"]\n          },\n          \"uniqueItems\": true\n        }\n      }\n    }\n  },\n  \"required\": [\"platform\", \"resources\", \"controllers\", \"cells\", \"fabric\"]\n}\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/IO/","title":"IO for DRRA-2 Fabric","text":""},{"location":"Docs/ToolChain/Vesyla-suite/v4/IO/#introduction","title":"Introduction","text":"<p>A DRRA-2 system consists of a global controller (implemented by RISC-V), several peripheral devices, and an acceleration fabric. The acceleration fabric or DRRA-2 fabric is a 2D mesh of cells. It requires at least 3 rows of cells. The first row hosts exclusively the IOSRAM that are used for temporarily store data loading from the input buffer. The last row hosts exclusively the IOSRAM that are used for temporarily store data storing to the output buffer. The middle rows are normal DRRA-2 cells that are used for computation or temporary storage.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/IO/#non-deterministic-protocol","title":"Non-deterministic Protocol","text":"<p>The communication between DRRA-2 cells and the input/output buffer are based on non-deterministic protocol to support the communication between dynamic algorithms via global NoCs. Here we use \"reading data from input buffer to SRAM\" as an example to illustrate the communication protocol.</p> <p>The slot that can host IOSRAM are slot 1. It is hardwired. The IOSRAM will have the following communication wires:</p> <ul> <li><code>addr</code>: The address input port. It is used to specify the address of the data to be read from the input buffer.</li> <li><code>en</code>: The enable input port. It is used to enable the read operation.</li> <li><code>valid</code>: The flag to indicate the data is ready to be read.</li> <li><code>data</code>: The data input port. It is used to read data from the input buffer to the IOSRAM.</li> </ul> <p>Two DSU instructions need to be issued. The first DSU instruction should be send to the slot 1 port 0. It will configure the FSM in port 0 to read data from the input buffer. The second DSU instruction should be send to the slot 1 port 2. It will configure the FSM in port 2 to put the data into the SRAM. The two instructions can also be wrapped by multiple REP instructions to form loop. The two instructions can be activated at the same time since the second DSU will not take effect immediately.</p> <p>For example, if we need to read the data in address 0,1,2,3 from the input buffer to address 3,4,5,6 in IOSRAM, the first DSU instruction and its REP instructions should be: <pre><code>rop &lt;read_to_input&gt; (slot=1, port=0){\n    dsu (slot=1, port=0, addr_sd=0, addr=0)\n    rep (slot=1, port=0, step=1, iter=4)\n}\n</code></pre> The second DSU instruction and its REP instructions should be: <pre><code>rop &lt;write_to_iosram&gt; (slot=1, port=2){\n    dsu (slot=1, port=2, addr_sd=0, addr=3)\n    rep (slot=1, port=2, step=1, iter=4)\n}\n</code></pre> We need to activate the two instructions at the same time. So we need to define the constraint:</p> <p><pre><code>linear read_to_input == write_to_iosram\n</code></pre> Now, the FSM in port 0 should generate the first address (0) and send it out to the <code>addr</code> signal and set the <code>en</code> signal to high. The FSM in port 1 will generate the first address (3), but it will not write anything into SRAM since the data is not ready yet. Once the signal <code>valid</code> and <code>data</code> from the input buffer becomes ready, the FSM in port 1 can then write the data into SRAM. At the same time the FSM in port 0 will generate the next address and repeat the process until everything is done.</p> <p>When slot 1 finishes, it will notify the sequencer that every operation in this slot has finished. The sequencer completes the waiting states and enter the next instruction.</p> <p>Usually, we don't do anything after the data loading is done, a <code>halt</code> instruction is automatically added to the end of the code segment. The <code>halt</code> instruction will notify the global controller that the code segment has finished. The global controller can then issue the next code segment to process the data.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/IO/#simplified-deterministic-protocol","title":"Simplified Deterministic Protocol","text":"<p>In some situation, the algorithm is completely static. It's more beneficial to assume the data is always ready at the next cycle or the data is always ready after some fixed delay. In this case, the data loading and storing can happen at the same time when computation is happening. We don't have to load data to the SRAM and notify the global controller first then start the computation.</p> <p>The assumption of having fixed delay for reading and storing data from/to external buffer has to be guaranteed by the application-level synthesis tool. If all other algorithms in the same application are also static, there will be no problem. However, if there are dynamic algorithms in the same application, special communication barriers has to be inserted between the static and dynamic algorithms to ensure that the static algorithms can still access data whenever they need. That means, we have to insert enough buffers that can hold the complete data token or even use ping-pong buffer to ensure the data is always ready.</p> <p>Till now, we are only dealing with static algorithms. therefore, we use the simplified deterministic protocol to communicate with the input/output buffer. When implementing the communication protocol, we can assume the data is always ready at the next cycle. The communication protocol is simplified to the following steps:</p> <p><pre><code>rop &lt;read_to_input&gt; (slot=1, port=0){\n    dsu (slot=1, port=0, addr_sd=0, addr=0)\n    rep (slot=1, port=0, step=1, iter=4, delay=t1)\n}\nrop &lt;write_to_iosram&gt; (slot=1, port=2){\n    dsu (slot=1, port=2, addr_sd=0, addr=3)\n    rep (slot=1, port=2, step=1, iter=4, delay=t1)\n}\n</code></pre> We also need to define the constraint to activate the two instructions at the same time:</p> <pre><code>linear read_to_input == write_to_iosram\n</code></pre> <p>Readers can go to the Tutorial DRRA to see how to use the simplified deterministic protocol to communicate with the input/output buffer.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/Installation/","title":"Installation and Usage","text":""},{"location":"Docs/ToolChain/Vesyla-suite/v4/Installation/#cheddar","title":"Cheddar","text":"<p>Recommendation</p> <p>The easiest way to use vesyla-suite is to use the pre-installed version on Cheddar.</p> <p>Vesyla-suite is pre-installed on Cheddar. You can use it directly without any installation. Contact the system administrator if you need an account on Cheddar. Use the following command to check the version of vesyla-suite.</p> <pre><code>vesyla-suite --version\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/Installation/#appimage","title":"AppImage","text":"<p>Vesyla-suite is also available as an AppImage. You can download the AppImage file from the here. You should put the AppImage file in a directory in your PATH. For example, you can put the AppImage file in the /usr/bin directory.</p> <pre><code>sudo mv vesyla-suite /usr/bin/vesyla-suite\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/Installation/#source-code","title":"Source Code","text":"<p>If you want to compile and install vesyla-suite from source code and make the AppImage file, you can follow the instructions below.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/Installation/#prerequisites","title":"Prerequisites","text":"<p>Vesyla-suite can be compiled and installed on any modern linux distribution. Before compiling vesyla-suite, you need to install compilation tool chain. You need to use the correct package manager of your Linux distribution. Read the requirements.txt file in the vesyla-suite source package to get the detailed information about the required packages.</p> <p>We also provide a script for major Linux distributions to install the required packages automatically. You can find the script in the vesyla-suite source package. The script is named install_dependencies.sh. You can run the script to install the required packages.</p> <pre><code>./install_dependencies.sh\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/Installation/#compile-and-install-vesyla-suite","title":"Compile and install vesyla-suite","text":"<p>We provide a simple script to compile vesyla-suite and make the AppImage file. You can find the script in the vesyla-suite source package. The script is named make_appimage.sh. You can run the script to compile vesyla-suite and make the AppImage file.</p> <pre><code>./make_appimage.sh\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/Installation/#put-the-appimage-file-in-your-path","title":"Put the AppImage file in your PATH","text":"<p>After you make the AppImage file, you should put the AppImage file in a directory in your PATH. For example, you can put the AppImage file in the /usr/bin directory.</p> <pre><code>sudo mv vesyla-suite /usr/bin/vesyla-suite\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/","title":"Instruction Set V4","text":""},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/#v41-current","title":"v4.1 (Current)","text":""},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/#instruction-format","title":"Instruction Format","text":"<p>Instructions are 32-bit wide. The MSB indicates whether it's a control instruction or a resource instruction. [0]: control; [1]: resource; The first 4-bit (bit 32~28) is the instruction code. The rest of the bits are used to encode the instruction content. For resource instructions, bit 27~24 in the instruction content are used to indicate the slot number. The rest of the bits are used to encode the instruction content.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/#control-instructions","title":"Control Instructions","text":"Field Position Width Description instr_code [31, 28] 4 Instruction code. The MSB indicates whether it's a control instruction or a resource instruction. [0]: control; [1]: data; instr_content [27, 0] 27 The content of the instruction. The meaning of this field depends on the instruction type and instruction code."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/#0000-halt","title":"0000 halt","text":"Field Position Width Default Value Description instr_code [31, 28] 4 0 Instruction code for halt. The halt instruction will stop the execution of the controller."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/#0001-wait","title":"0001 wait","text":"Field Position Width Default Value Description instr_code [31, 28] 4 1 Instruction code for wait mode [27, 27] 1 0 Wait mode: [0]: wait for a number of cycles; [1]: wait for the completion of task in slot X, X is defined by the cycle field using 1-hot encoding; cycle [26, 0] 28 0 if mode is 0, the wait instruction waits for cycle extra cycles excluding the current cycle used for the wait instruction. If mode is 1, it waits for the sensitive slots defined by 1-hot encoded cycle."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/#0010-act","title":"0010 act","text":"<p>Note</p> <p>Mode 2 is not supported for now.</p> Field Position Width Default Value Description instr_code [31, 28] 4 2 Instruction code for act ports [27, 12] 16 0 1-hot encoded ports that need to be activated. There are 64 ports in total, but only 16 can be activated at the same time. The ports are filtered by the mode and parameter field. mode [11, 8] 4 0 Filter mode: [0]: Continues ports start from slot X; [1] All port X in each slot; [2]: the predefined 64-bit activation code in internal activation memory location X. param [7, 0] 8 0 The parameter for the filter mode."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/#0011-calc","title":"0011 calc","text":"Field Position Width Default Value Description instr_code [31, 28] 4 3 Instruction code for CALC mode [27, 24] 4 0 Calculation mode. [0]:idle; [1]:add; [2]:sub; [3]:lls; [4]:lrs; [5]:mul; [6]:div; [7]:mod; [8]:bit-and; [9]:bit-or; [10]:bit-inv; [11]:bit-xor; [17]:eq; [18]:ne; [19]:gt; [20]:ge; [21]:lt; [22]:le; [32]:and; [33]:or; [34]:not; operand1 [23, 20] 4 0 First operand. operand2_sd [19, 19] 1 0 Is the second operand static or dynamic? [0]:s; [1]:d; operand2 [18, 11] 8 0 Second operand. result [10, 7] 4 0 The register to store the result. If it's scalar operation, the result is stored in the scalar register. If it's logic operations, the result is stored in the bool register."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/#0100-brn","title":"0100 brn","text":"Field Position Width Default Value Description instr_code [31, 28] 4 4 Instruction code for brn reg [27, 24] 4 0 The bool register to check target_true [23, 15] 9 0 The relative pc offset if the bool register is true. target_false [14, 6] 9 0 The relative pc offset if the bool register is false."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/#resource-instructions","title":"Resource Instructions","text":"Field Position Width Description instr_code [31, 28] 4 Instruction code. The MSB indicates whether it's a control instruction or a resource instruction. [0]: control; [1]: data; slot [27, 24] 4 The slot number. instr_content [23, 0] 24 The content of the instruction. The meaning of this field depends on the instruction type and instruction code. <p>Note</p> <p>When instruction code start with \"111\", the instruction contains a field that need to be replaced by RACCU registers if the filed is marked \"dynamic\".</p> Slot Type Supported Instructions Register File DSU, REP, REPX SRAM Block DSU, REP, REPX IO Block DSU, REP, REPX DPU DPU, REP, REPX, FSM"},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/#1000-rep","title":"1000 rep","text":"<p>This instruction is accepted by the following slots:</p> <ul> <li>swb</li> <li>iosram</li> <li>dpu</li> <li>rf</li> <li>sram</li> </ul> Field Position Width Default Value Description instr_code [31, 28] 4 8 Instruction code for REP slot [27, 24] 4 N/A Slot number. port [23, 21] 2 0 The port number. [0]: write narrow; [1]: read narrow; [2]: write wide; [3]: read wide; level [20, 17] 4 0 The level of the REP instruction. [0]: inner most level, [15]: outer most level. iter [16, 11] 6 0 iteration - 1. step [10, 5] 6 0 iteration step. This field is only useful when paired with REFI/SRAM instructions. delay [5, 0] 6 0 Repetition delay."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/#1001-repx","title":"1001 repx","text":"<p>This instruction is accepted by the following slots:</p> <ul> <li>swb</li> <li>iosram</li> <li>dpu</li> <li>rf</li> <li>sram</li> </ul> Field Position Width Default Value Description instr_code [31, 28] 4 9 Instruction code for REPX. Configure the higher 6-bit of each field in the REP instruction. slot [27, 24] 4 N/A Slot number. port [23, 21] 2 0 The port number. [0]: write narrow; [1]: read narrow; [2]: write wide; [3]: read wide; level [20, 17] 4 0 The level of the REP instruction. [0]: inner most level, [15]: outer most level. iter [16, 11] 6 0 iteration - 1. step [10, 5] 6 0 iteration step. This field is only useful when paired with REFI/SRAM instructions. delay [5, 0] 6 0 Repetition delay."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/#1010-fsm","title":"1010 fsm","text":"<p>This instruction is accepted by the following slots:</p> <ul> <li>swb</li> <li>dpu</li> </ul> Field Position Width Default Value Description instr_code [31, 28] 4 10 Instruction code for FSM slot [27, 24] 4 N/A Slot number. port [23, 21] 3 0 The port number. [0]: write narrow; [1]: write narrow; [2]: write wide; [3]: read wide; delay_0 [20, 14] 7 0 The delay between state 0 and 1. delay_1 [13, 7] 7 0 The delay between state 1 and 2. delay_2 [6, 0] 7 0 The delay between state 2 and 3."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/#1011-dpu","title":"1011 dpu","text":"<p>This instruction is accepted by the following slots:</p> <ul> <li>dpu</li> </ul> Field Position Width Default Value Description instr_code [31, 28] 4 11 Instruction code for DPU slot [27, 24] 4 N/A Slot number. option [23, 22] 2 0 Programmable FSM states. Max 4 states. mode [21, 17] 5 0 The DPU mode. [0]:idle; [1]:add; [2]:sum_acc; [3]:add_const; [4]:subt; [5]:subt_abs; [6]:mode_6; [7]:mult; [8]:mac; [9]:mult_const; [10]:accumulate; [11]:ld_ir; [12]:axpy; [13]:max_min_acc; [14]:max_min_const; [15]:mode_15; [16]:max_min; [17]:shift_l; [18]:shift_r; [19]:sigm; [20]:tanhyp; [21]:expon; [22]:lk_relu; [23]:relu; [24]:div; [25]:acc_softmax; [26]:div_softmax; [27]:ld_acc; [28]:scale_dw; [29]:scale_up; [30]:mac_inter; [31]:mode_31; immediate [16, 1] 16 0 The immediate field used by some DPU modes."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/#1100-swb","title":"1100 swb","text":"<p>This instruction is accepted by the following slots:</p> <ul> <li>swb</li> </ul> Field Position Width Default Value Description instr_code [31, 28] 4 12 Instruction code for SWB slot [27, 24] 4 N/A Slot number. option [23, 22] 2 0 Programmable FSM states. Max 4 states. channel [21, 18] 4 0 Bus channel. Note: if the SWB is implemented by a crossbar, the channel is always equals to the target slot. source [17, 14] 4 0 Source slot. target [13, 10] 4 0 Target slot"},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/#1101-route","title":"1101 route","text":"<p>This instruction is accepted by the following slots:</p> <ul> <li>swb</li> </ul> Field Position Width Default Value Description instr_code [31, 28] 4 13 Instruction code for ROUTE slot [27, 24] 4 N/A Slot number. option [23, 22] 2 0 Programmable FSM states. Max 4 states. sr [21, 21] 1 0 Send or receive. [0]: send; [1]: receive; source [20, 17] 4 0 1-hot encoded direction: E/N/W/S. If it's a receive instruction, the direction can only have 1 bit set to 1. target [16, 1] 16 0 1-hot encoded slot number. If it's a send instruction, the slot can only have 1 bit set to 1."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/#1110-dsu","title":"1110 dsu","text":"<p>This instruction is accepted by the following slots:</p> <ul> <li>iosram</li> <li>rf</li> <li>sram</li> </ul> Field Position Width Default Value Description instr_code [31, 28] 4 14 Instruction code for DSU slot [27, 24] 4 N/A Slot number. init_addr_sd [23, 23] 1 0 Is init_addr static or dynamic? [0]:s; [1]:d; init_addr [22, 7] 16 0 Initial address. port [6, 5] 2 0 The port number. [0]: write_narrow; [1]: read_narrow; [2]: write_wide; [3]: read_wide; If it's applied to IO, then [0]: read from IO to SRAM; [1]: write from SRAM to IO;"},{"location":"Docs/ToolChain/Vesyla-suite/v4/ProgrammingGuide/","title":"Programming Guide","text":""},{"location":"Docs/ToolChain/Vesyla-suite/v4/ProgrammingGuide/#introduction","title":"Introduction","text":"<p>The Proto-Assembly Language is a low-level language that is used to write programs for the DRRA-2 architecture. The language is designed to be simple and easy to understand, while still providing the necessary features to write complex programs. The Proto-Assembly Language are structured assembly language whose instructions are not yet been scheduled. It preserves control hierarchy but lack of timing information. This guide will provide an overview of the language and how to write programs in it. In this guide, you will learn about the syntax of the Proto-Assembly Language, and its constraints.</p> <p>Syntax Highlighting</p> <p>We highly recommend to install the vscode extension for syntax highlighting of all languages used by the SiLago project. The extension is not published on vscode marketplace since it's still in alpha quality. However, you can download and install it from VSIX package available on github.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/ProgrammingGuide/#file-types","title":"File Types","text":"<p>The Proto-Assembly Language uses the <code>.pasm</code> file extension for source files. These files contain the source code for a program written in the Proto-Assembly Language.</p> <p>To supplement the Proto-Assembly Language, the <code>.cstr</code> file extension is used for constraint files. These files contain the constraints for the program written in the Proto-Assembly Language. The constraints are necessary for the scheduling of the instructions in the Proto-Assembly Language.</p> <p>The output of the scheduling and synchronization process is an assembly language file with <code>.asm</code> as suffix. This file contains the scheduled instructions that is ready to processed by the assembler.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/ProgrammingGuide/#syntax-for-proto-assembly-language","title":"Syntax for Proto-Assembly Language","text":""},{"location":"Docs/ToolChain/Vesyla-suite/v4/ProgrammingGuide/#comments","title":"Comments","text":"<p>Comments in the Proto-Assembly Language are denoted by the <code>#</code> character. Anything after the <code>#</code> character on a line is considered a comment and is ignored by the compiler.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/ProgrammingGuide/#syntax-format","title":"Syntax Format","text":"<p>All regions, operations, and instructions follow the same syntax format. The syntax format is as follows:</p> <p><pre><code>NAME &lt;ID&gt; (PARAM_0=VALUE_0, PARAM_1=VALUE_1, ...) {\n    CONTENT_0\n    CONTENT_1\n    ...\n}\n</code></pre> However, different regions, operations, and instructions requires only some parts of the syntax format. For example, loop region usually don't need the <code>ID</code> part; Instructions don't have any contents.</p> <p>The following EBNF grammar describes the syntax of the Proto-Assembly Language:</p> <pre><code>start: (loop_region | cond_region | epoch_region)*\n\nloop_region: \"loop\"   (\"&lt;\" IDENTIFIER \"&gt;\")? (\"(\" parameter (\",\" parameter)* \")\") \"{\" (loop_region | cond_region | epoch_region)+ \"}\"\ncond_region: \"cond\"   (\"&lt;\" IDENTIFIER \"&gt;\")? (\"(\" parameter (\",\" parameter)* \")\") \"{\" (loop_region | cond_region | epoch_region)+ \"}\"\nepoch_region: \"epoch\" (\"&lt;\" IDENTIFIER \"&gt;\")? (\"(\" parameter (\",\" parameter)* \")\")? \"{\" cell_region+ \"}\"\ncell_region: \"cell\"   (\"&lt;\" IDENTIFIER \"&gt;\")? \"(\" parameter (\",\" parameter)* \")\" \"{\" (cop_region | rop_region | raw_region)+ \"}\"\n\ncop_region: \"cop\" (\"&lt;\" IDENTIFIER \"&gt;\")? (\"(\" parameter (\",\" parameter)* \")\")? \"{\" instruction+ \"}\"\nrop_region: \"rop\" (\"&lt;\" IDENTIFIER \"&gt;\")? (\"(\" parameter (\",\" parameter)* \")\")? \"{\" instruction+ \"}\"\nraw_region: \"raw\" (\"&lt;\" IDENTIFIER \"&gt;\")? \"{\" instruction+ \"}\"\n\ninstruction: IDENTIFIER (\"&lt;\" IDENTIFIER \"&gt;\")? (\"(\" parameter (\",\" parameter)* \")\")?\nparameter: IDENTIFIER \"=\" (IDENTIFIER | NUMBER)\n\nIDENTIFIER: /[_a-zA-Z][_a-zA-z0-9]*/\nNUMBER: /[+-]?(0[xdob])?[0-9\\.]+/\n\n%import common.WS\n%ignore WS\nCOMMENTS: /#.*/\n%ignore COMMENTS\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/ProgrammingGuide/#concepts","title":"Concepts","text":"<p>Regions and instructions are the basic building blocks of a program written in the Proto-Assembly Language. We introduce the following concepts to help you understand the structure of a program written in the Proto-Assembly Language.</p> <ul> <li>start region represents the whole program. It contains one or more regions among loop, cond, and epoch.</li> <li>loop region is a hierarchical region that contains one or more regions among loop, cond, and epoch.</li> <li>cond region is a hierarchical region that contains one or more regions among loop, cond, and epoch.</li> <li>epoch region is a region that contains one or more cell region.</li> <li>cell region is a region that contains one or more operations among rop, cop, and raw.</li> <li>rop or resource operation is a region that contains one or more resource instructions.</li> <li>cop or control operation is a region that contains one or more control instructions.</li> <li>raw or raw assembly operation is a region that contains assembly instruction that do not need to be process by the scheduler.</li> <li>control instructions are instructions that are executed by a sequencer.</li> <li>resource instructions are instructions that are executed by a specific resource.</li> </ul> <p>Note</p> <p>The Proto-Assembly Language is case-sensitive. All keywords must be written in lowercase.</p> <p>Note</p> <p>The raw region is not compatible with cop and rop regions. They are not allowed in the same epoch region. This is because the instruction scheduling process works on the entire epoch.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/ProgrammingGuide/#example","title":"Example","text":"<p>The following is an example of a simple program written in the Proto-Assembly Language:</p> <pre><code>epoch &lt;rb0&gt; {\n    cell (x=0, y=0) {\n        rop &lt;route0r&gt; (slot=0, port=2){\n            route (slot=0, option=0, sr=0, source=2, target= 0b010000000)\n        }\n\n        rop &lt;input_r&gt; (slot=1, port=0){\n            dsu (slot=1, port=0, init_addr=0)\n            rep (slot=1, port=0, level=0, iter=2, step=1, delay=0)\n        }\n\n        rop &lt;input_w&gt; (slot=1, port=2){\n            dsu (slot=1, port=2, init_addr=0)\n            rep (slot=1, port=2, iter=2, step=1, delay=0)\n        }\n\n        rop &lt;read_ab&gt; (slot=2, port=3){\n            dsu (slot=2, port=3, init_addr=0)\n            rep (slot=2, port=3, iter=2, step=1, delay=0)\n        }\n    }\n\n    cell (x=1, y=0) {\n        rop &lt;route1wr&gt; (slot=0, port=2){\n            route (slot=0, option=0, sr=1, source=1, target= 0b0000000000000110)\n            route (slot=0, option=0, sr=0, source=3, target= 0b010000000)\n        }\n\n        rop &lt;write_a&gt; (slot=1, port=2){\n            dsu (slot=1, port=2, init_addr=0)\n            rep (slot=1, port=2, iter=1, step=1, delay=t1)\n        }\n\n        rop &lt;write_b&gt; ( slot=2, port=2){\n            dsu (slot=2, port=2, init_addr=0)\n            rep (slot=2, port=2, iter=1, step=1, delay=t1)\n        }\n\n        rop &lt;swb&gt; ( slot=0, port=0){\n            swb (slot=0, option=0, channel=4, source=1, target=4)\n            swb (slot=0, option=0, channel=5, source=1, target=5)\n            swb (slot=0, option=0, channel=3, source=4, target=3)\n        }\n\n        rop &lt;read_a_seq&gt; ( slot=1, port=1){\n            dsu (slot=1, port=1, init_addr=0)\n            rep (slot=1, port=1, iter=16, step=1, delay=0)\n        }\n\n        rop &lt;read_b_seq&gt; ( slot=2, port=1){\n            dsu (slot=2, port=1, init_addr=0)\n            rep (slot=2, port=1, iter=16, step=1, delay=0)\n        }\n\n        rop &lt;write_c_seq&gt; ( slot=3, port=0){\n            dsu (slot=3, port=0, init_addr=0)\n            rep (slot=3, port=0, iter=16, step=1, delay=0)\n        }\n\n        rop &lt;compute&gt; ( slot=4, port=0){\n            dpu (slot=4, mode=1)\n        }\n\n        rop &lt;read_c&gt; ( slot=3, port=3){\n            dsu (slot=3, port=3, init_addr=0)\n            rep (slot=3, port=3, iter=1, step=1, delay=0)\n        }\n    }\n\n    cell (x=2, y=0) {\n        rop &lt;route2w&gt; ( slot=0, port=2){\n            route (slot=0, option=0, sr=1, source=1, target= 0b0000000000000100)\n        }\n\n        rop &lt;write_c&gt; ( slot=2, port=2){\n            dsu (slot=2, port=2, init_addr=0)\n            rep (slot=2, port=2, iter=1, step=1, delay=0)\n        }\n\n        rop &lt;output_r&gt; (slot=1, port=3){\n            dsu (slot=1, port=3, init_addr=0)\n            rep (slot=1, port=3, iter=1, step=1, delay=0)\n        }\n\n        rop &lt;output_w&gt; (slot=1, port=1){\n            dsu (slot=1, port=1, init_addr=0)\n            rep (slot=1, port=1, iter=1, step=1, delay=0)\n        }\n    }\n}\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/ProgrammingGuide/#syntax-for-constraint-files","title":"Syntax for Constraint Files","text":"<p>The constraint files are used to specify the constraints for the program written in the Proto-Assembly Language. The constraints are necessary for the scheduling of the instructions in the Proto-Assembly Language.</p> <p>Constraint is also organized as code region. Only the <code>epoch</code> region is supported in the constraint file because only it requires timing constraints. The <code>ID</code> field of the <code>epoch</code> region should be the same as the <code>epoch</code> region in the proto-assembly file, which is used to match the constraints with the program.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/ProgrammingGuide/#comments_1","title":"Comments","text":"<p>Comments in the constraint file are denoted by the <code>#</code> character. Anything after the <code>#</code> character on a line is considered a comment and is ignored by the compiler.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/ProgrammingGuide/#syntax-format_1","title":"Syntax Format","text":"<p>The syntax format for the constraint file is as follows:</p> <pre><code>epoch ID {\n    TYPE CONTENT_0\n    TYPE CONTENT_1\n    ...\n}\n</code></pre> <p>Currently, we only support linear constraint type. The linear constraints support normal equality and inequality.</p> <p>The following EBNF grammar describes the syntax of the constraint file:</p> <pre><code>start: (epoch_region)*\nepoch_region: \"epoch\" (\"&lt;\" IDENTIFIER \"&gt;\")? (\"(\" parameter (\",\" parameter)* \")\")? \"{\" constraint* \"}\"\nconstraint: IDENTIFIER ANY\nparameter: IDENTIFIER \"=\" (IDENTIFIER | NUMBER)\nIDENTIFIER: /[_a-zA-Z][_a-zA-z0-9]*/\nNUMBER: /[+-]?(0[xdob])?[0-9\\.]+/\nANY: /.+/\n%import common.WS\n%ignore WS\nCOMMENTS: /#.*/\n%ignore COMMENTS\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/ProgrammingGuide/#concepts_1","title":"Concepts","text":"<ul> <li>epoch region is a region that contains one or more constraints.</li> <li>constraint is single line statement that specifies the constraint type and its content. Each constraint is expressed by a relationship among operations, events, and anchors.</li> <li>operation is the ID of the operation in the proto-assembly file. Each operation, depends on its internal instruction list, can be interpreted as a sequence of events and their transformation. The event name in resource operation is used to represent the specific event for operations using <code>FSM</code> instructions to construct multi-state FSM. For control operations, each instruction will be a new event. The event name always starts with <code>e</code> and followed by a number. They are always numerically ordered. For example, the first, second and third event of operation <code>op0</code> will be <code>op0.e0</code>, <code>op0.e1</code> and <code>op0.e2</code> respectively.</li> <li>anchor is the specific instances of events in different loop iterations implemented by the <code>rep</code> instruction. The anchor name is the event name followed by a sequence of loop iteration number. For example, the first event of operation <code>op0</code> in the second loop iteration will be <code>op0.e0[1]</code>. The left-to-right order of the loop iteration number is from the outermost loop to the innermost loop.</li> </ul>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/ProgrammingGuide/#example_1","title":"Example","text":"<p>The following is an example of a constraint file that specifies the constraints for the proto-assembly program written in the previous section:</p> <pre><code>epoch &lt;rb0&gt; {\n    linear ( input_r == input_w )\n    linear ( route0r &lt; read_ab )\n    linear ( route1wr &lt; write_a )\n    linear ( route1wr &lt; write_b )\n    linear ( read_ab.e0[0] == write_a.e0[0] - 1 )\n    linear ( read_ab.e0[1] == write_b.e0[0] - 1 )\n    linear ( write_a &lt; read_a_seq )\n    linear ( write_b &lt; read_b_seq )\n    linear ( swb &lt; read_a_seq )\n    linear ( read_a_seq == read_b_seq )\n    linear ( read_a_seq + 1 &gt; compute )\n    linear ( write_c_seq == read_a_seq + 2 )\n\n    linear ( compute != route1wr )\n    linear ( compute != swb )\n\n    linear ( read_c.e0[0] &gt; write_c_seq.e0[15] )\n\n    linear ( write_c == read_c + 1 )\n    linear ( output_r &gt; write_c )\n    linear ( output_r == output_w )\n}\n</code></pre>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/Scheduling/","title":"Instruction Scheduling","text":"<p>Warning</p> <p>This document is still under construction. The content is not complete.</p> <p>The instruction scheduler in Vesyla-suite is a stand-alone program that can generate assembly instruction list for DRRA-2 from a proto instruction list and a constraint file. The core scheduling process targets a single <code>epoch</code> region. The proto-assembly file and constraint file will be converted to an internal timing model that can work as the intermeditate representation for finally converting to constraint programing (CP) model. We use the or-tools (python binding) from Google to finally solve the scheduling problem once the CP model is created.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/Scheduling/#timing-model","title":"Timing Model","text":"<p>The timing model consists two parts:</p> <ol> <li>Operation behavior description</li> <li>Timing constraints</li> </ol> <p>Operation behavior description models the timing behavior of every resource operation (rop) and control operation (cop). It uses concepts like operation, event, and anchor similar to the proto-assembly language.</p> <p>Each operation will have one or more events, they are named numerically as <code>e0</code>, <code>e1</code>, etc. Among events, it is possible to apply two types of transformation operator: transition (T operator) and repetition (R operator). The T operator describes the timing transition from one event to another event. While the R operator describes the repetition of a single event or a group of events. Those operator can be applied recursively to form very complex timing behavior.</p> <p>Example</p> <p><pre><code>operation a T&lt;6&gt;(R&lt;2,3&gt;(T&lt;4&gt;(e0, e1)), e2) \n</code></pre> The above expression describe an operation a, it has three events: e0, e1, and e2.</p> <p>The expression <code>T&lt;4&gt;(e0, e1)</code> means that four cycles after the event e0, e1 happens.</p> <p>The expression <code>R&lt;2,3&gt;(T&lt;4&gt;(e0, e1))</code> means that the above transition is repeated twice and the repetitions are separated by 3 cycles.</p> <p>Finally, the whole expression <code>T&lt;6&gt;(R&lt;2,3&gt;(T&lt;4&gt;(e0, e1)), e2)</code> means that after the above repetition and further delay of 6 cycles, the event e2 will happen.</p> <p>The timing constraint used by the is the model is the same as the constraint file. It's a direction translation.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/Scheduling/#cp-model","title":"CP Model","text":"<p>For each operation, event, and anchor, we create a variable in the CP model.</p> <p>The event and anchor variables are restricted by the corresponding operation variables according to the operation timing model. Those restrictions are translated to the CP model as constraints.</p> <p>Custom constraints are automatically added to the CP model according to the constraint file.</p> <p>The objective function is to minimize the total time of the epoch.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/Tutorial_DRRA/","title":"DRRA-based AlImp Design Tutorial (v4)","text":""},{"location":"Docs/ToolChain/Vesyla-suite/v4/Tutorial_DRRA/#introduction","title":"Introduction","text":"<p>This tutorial demonstrates how to implement algorithms using vesyla-suite for DRRA-based architecture. We first introduce the programming model, then demonstrate with an example how to implement an algorithm using vesyla-suite.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/Tutorial_DRRA/#programming-model","title":"Programming Model","text":"<p>Each algorithm compiled by vesyla-suite will be mapped to a DRRA-2 fabric. The DRRA-2 fabric has a globally addressable input buffer and a globally addressable output buffer, as shown in the following figure.</p> <p></p> <p>The input buffer is used to store the input data of the algorithm. The output buffer is used to store the output data of the algorithm. The input buffer and the output buffer are connected to the DRRA fabric through the input and output ports of the fabric. The input and output ports are used to connect the DRRA fabric to the outside world.</p> <p>Only the top row of DRRA-2 cells have access to the input buffer and only the bottom row of DRRA-2 cells have access to the output buffer. The input bandwidth and output bandwidth are determined by the number of columns of the DRRA fabric.</p> <p>The assumption of giant globally addressable memory buffers is not realistic. However, these buffers will not be implemented as it is. Instead, application-level synthesis (ALS) tool will synthesize the input and output buffers to the actual hardware. The input and output buffers are used to simplify the algorithmic compilation process.</p> <p>A typical setup of a DRRA-2 fabric consists of a input row on the top, an output row on the bottom, and a number of computation rows in the middle. The input row is used to read data from the input buffer. The output row is used to write data to the output buffer. The computation rows are used to perform the actual computation. The data flow direction is in general top-down. </p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/Tutorial_DRRA/#initialization","title":"Initialization","text":"<p>In any directory, you can initialize a DRRA style project by using the command:</p> <pre><code>vesyla-suite testcase init -s drra\n</code></pre> <p>If this directory has already been initialized, you can force the re-initialization by using the command:</p> <pre><code>vesyla-suite testcase init -f -s drra\n</code></pre> <p>You will notice that several files has been created in this directory. One of the files is <code>arch.json</code>. This file contains the architecture description. You can modify this file to change the resources that are included on the fabric. The configuration file is described in the following section.</p> <p>Another file you need to modify is <code>main.cpp</code>. You need to define some of the functions in this file. The functions are described in the following section.</p> <p>The third location you need to modify is the <code>pasm</code> folder. This folder contains all the code segments in proto-assembly and constraint format. The name of each code segment should be a unique number. For example <code>0.pasm</code>/<code>0.cstr</code>, <code>1.pasm</code>/<code>1.cstr</code>, and so on.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/Tutorial_DRRA/#implementation","title":"Implementation","text":"<p>We use a simple example to demonstrate the implementation of algorithms. The example is a element-wise addition of two vectors. It has two inputs: vector <code>A</code> and vector <code>B</code>. It has one output: vector <code>C</code>. All of them have size equal to 16. The element-wise addition is defined as: <code>C[i] = A[i] + B[i]</code>.</p> <p>We first define the hardware architecture in <code>arch.json</code>. It should include three cells: cell [0,0], cell [1,0], and cell [2,0]. Cell [0,0] is used to read data from input buffer, and cell [2,0] is used to write result to output buffer. Cell [1,0] will be the one that does the actual addition.</p> <pre><code>{\n  \"platform\": \"drra\",\n  \"resources\": [\n    {\n      \"name\": \"iosram\",\n      \"size\": 4,\n      \"word_input_port\": 0,\n      \"word_output_port\": 0,\n      \"bulk_input_port\": 2,\n      \"bulk_output_port\": 2,\n      \"custom_properties\": [\n        {\n          \"key\": \"depth\",\n          \"val\": 64\n        }\n      ]\n    },\n    {\n      \"name\": \"swb\",\n      \"size\": 1,\n      \"word_input_port\": 0,\n      \"word_output_port\": 0,\n      \"bulk_input_port\": 0,\n      \"bulk_output_port\": 0\n    },\n    {\n      \"name\": \"dpu\",\n      \"size\": 2,\n      \"word_input_port\": 2,\n      \"word_output_port\": 1,\n      \"bulk_input_port\": 0,\n      \"bulk_output_port\": 0\n    },\n    {\n      \"name\": \"rf\",\n      \"size\": 1,\n      \"word_input_port\": 1,\n      \"word_output_port\": 1,\n      \"bulk_input_port\": 1,\n      \"bulk_output_port\": 1,\n      \"custom_properties\": [\n        {\n          \"key\": \"depth\",\n          \"val\": 64\n        }\n      ]\n    }\n  ],\n  \"controllers\": [\n    {\n      \"name\": \"controller_io\",\n      \"size\": 8,\n      \"iram_size\": 64\n    },\n    {\n      \"name\": \"controller_normal\",\n      \"size\": 16,\n      \"iram_size\": 64\n    }\n  ],\n  \"cells\": [\n    {\n      \"name\": \"drra_cell_input\",\n      \"controller\": \"controller_io\",\n      \"resource_list\": [\"swb\", \"iosram\"]\n    },\n    {\n      \"name\": \"drra_cell_output\",\n      \"controller\": \"controller_io\",\n      \"resource_list\": [\"swb\", \"iosram\"]\n    },\n    {\n      \"name\": \"drra_cell_normal\",\n      \"controller\": \"controller_normal\",\n      \"resource_list\": [\"swb\", \"rf\", \"rf\", \"rf\", \"dpu\"]\n    }\n  ],\n  \"fabric\": {\n    \"height\": 3,\n    \"width\": 1,\n    \"cell_lists\": [\n      {\n        \"coordinates\": [{ \"row\": 0, \"col\": 0 }],\n        \"cell_name\": \"drra_cell_input\"\n      },\n      {\n        \"coordinates\": [{ \"row\": 1, \"col\": 0 }],\n        \"cell_name\": \"drra_cell_normal\"\n      },\n      {\n        \"coordinates\": [{ \"row\": 2, \"col\": 0 }],\n        \"cell_name\": \"drra_cell_output\"\n      }\n    ],\n    \"custom_properties\": []\n  },\n  \"interface\": {\n    \"input_buffer_depth\": 1024,\n    \"output_buffer_depth\": 1024\n  }\n}\n</code></pre> <p>Before we implement the algorithm in <code>main.cpp</code>, we need to define the input and output data layout in input and output buffer. Both input and output buffer has width that equals to 256 bits. So, each row can be divided by 16 16-bit chunks, each of which stores an element of <code>A</code>, <code>B</code>, or <code>C</code>. The layout is described by the following table.</p> <pre><code>Input Buffer:\n+------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n| addr | CHK0| CHK1| CHK2| CHK3| CHK4| CHK5| CHK6| CHK7| CHK8| CHK9|CHK10|CHK11|CHK12|CHK13|CHK14|CHK15|\n+------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n|    0 | A[0]| A[1]| A[2]| A[3]| A[4]| A[5]| A[6]| A[7]| A[8]| A[9]|A[10]|A[11]|A[12]|A[13]|A[14]|A[15]|\n|    1 | B[0]| B[1]| B[2]| B[3]| B[4]| B[5]| B[6]| B[7]| B[8]| B[9]|B[10]|B[11]|B[12]|B[13]|B[14]|B[15]|\n+------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n\nOutput Buffer:\n+------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n| addr | CHK0| CHK1| CHK2| CHK3| CHK4| CHK5| CHK6| CHK7| CHK8| CHK9|CHK10|CHK11|CHK12|CHK13|CHK14|CHK15|\n+------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n|    0 | C[0]| C[1]| C[2]| C[3]| C[4]| C[5]| C[6]| C[7]| C[8]| C[9]|C[10]|C[11]|C[12]|C[13]|C[14]|C[15]|\n+------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n</code></pre> <p>In <code>main.cpp</code>, you need to implement the following functions:</p> <ul> <li><code>void init()</code>: This function is used to initialize the input buffer.</li> <li><code>void model_l0()</code>: This function is used to implement the algorithm in the level 0 model. It's a pure software implementation of the algorithm. It's used to verify the correctness of the algorithm.</li> <li><code>void model_l1()</code>: This function is used to implement the algorithm in the level 1 model. It should consists a set of function call of simulation request of the code segments stored in folder <code>pasm</code>.</li> </ul> <p>We implement these functions one by one.</p> <p>The <code>init()</code> function is used to initialize the input buffer. It's a pure software implementation. The following code shows how to initialize the input buffer.</p> <pre><code>void init() {\n#define N 16\n  // Set the seed for random number generator\n  srand((unsigned)time(NULL));\n\n  // Generate N random numbers in range [0,100)\n  vector&lt;int16_t&gt; v(2 * N);\n  for (auto i = 0; i &lt; 2 * N; i++) {\n    v[i] = rand() % 100;\n  }\n\n  // Write the random numbers to the input buffer.\n  __input_buffer__.write&lt;int16_t&gt;(0, (2 * N) / 16, v);\n}\n</code></pre> <p>The <code>model_l0()</code> function is used to implement the algorithm in the level 0 model. It's a pure software implementation of the algorithm. It's used to verify the correctness of the algorithm. The following code shows how to implement the algorithm in the level 0 model.</p> <pre><code>void model_l0() {\n#define N 16\n  // Read the input buffer to A and B.\n  vector&lt;int16_t&gt; a = __input_buffer__.read&lt;int16_t&gt;(0, N / 16);\n  vector&lt;int16_t&gt; b = __input_buffer__.read&lt;int16_t&gt;(0, N / 16);\n  vector&lt;int16_t&gt; c(N);\n  for(int i=0; i&lt;N; i++){\n    c[i] = a[i]*b[i];\n  }\n  // Write A to the output buffer\n  __output_buffer__.write&lt;int16_t&gt;(0, N / 16, c);\n}\n</code></pre> <p>Now, it's time to implement the algorithm in the level 1 model. The level 1 model should consists a set of function call of simulation request of the code segments stored in folder <code>pasm</code>. In this example, we only need 1 code segment. Therefore, the level 1 model is very simple.</p> <pre><code>void model_l1(){\n  simulate_code_segment(0);\n}\n</code></pre> <p>The level 1 model is not complete without the proto-assembly code and its constraint file. We need to write the proto-assembly code in <code>pasm/0.pasm</code>:</p> <p>Syntax Highlighting</p> <p>We highly recommend to install the vscode extension for syntax highlighting of all languages used by the SiLago project. The extension is not published on vscode marketplace since it's still in alpha quality. However, you can download and install it from VSIX package available on github.</p> <pre><code>epoch &lt;rb0&gt; {\n    cell (x=0, y=0) {\n        rop &lt;route0r&gt; (slot=0, port=2){\n            route (slot=0, option=0, sr=0, source=2, target= 0b010000000)\n        }\n\n        rop &lt;input_r&gt; (slot=1, port=0){\n            dsu (slot=1, port=0, init_addr=0)\n            rep (slot=1, port=0, level=0, iter=2, step=1, delay=0)\n        }\n\n        rop &lt;input_w&gt; (slot=1, port=2){\n            dsu (slot=1, port=2, init_addr=0)\n            rep (slot=1, port=2, iter=2, step=1, delay=0)\n        }\n\n        rop &lt;read_ab&gt; (slot=2, port=3){\n            dsu (slot=2, port=3, init_addr=0)\n            rep (slot=2, port=3, iter=2, step=1, delay=0)\n        }\n    }\n\n    cell (x=1, y=0) {\n        rop &lt;route1wr&gt; (slot=0, port=2){\n            route (slot=0, option=0, sr=1, source=1, target= 0b0000000000000110)\n            route (slot=0, option=0, sr=0, source=3, target= 0b010000000)\n        }\n\n        rop &lt;write_a&gt; (slot=1, port=2){\n            dsu (slot=1, port=2, init_addr=0)\n            rep (slot=1, port=2, iter=1, step=1, delay=t1)\n        }\n\n        rop &lt;write_b&gt; ( slot=2, port=2){\n            dsu (slot=2, port=2, init_addr=0)\n            rep (slot=2, port=2, iter=1, step=1, delay=t1)\n        }\n\n        rop &lt;swb&gt; ( slot=0, port=0){\n            swb (slot=0, option=0, channel=4, source=1, target=4)\n            swb (slot=0, option=0, channel=5, source=1, target=5)\n            swb (slot=0, option=0, channel=3, source=4, target=3)\n        }\n\n        rop &lt;read_a_seq&gt; ( slot=1, port=1){\n            dsu (slot=1, port=1, init_addr=0)\n            rep (slot=1, port=1, iter=16, step=1, delay=0)\n        }\n\n        rop &lt;read_b_seq&gt; ( slot=2, port=1){\n            dsu (slot=2, port=1, init_addr=0)\n            rep (slot=2, port=1, iter=16, step=1, delay=0)\n        }\n\n        rop &lt;write_c_seq&gt; ( slot=3, port=0){\n            dsu (slot=3, port=0, init_addr=0)\n            rep (slot=3, port=0, iter=16, step=1, delay=0)\n        }\n\n        rop &lt;compute&gt; ( slot=4, port=0){\n            dpu (slot=4, mode=1)\n        }\n\n        rop &lt;read_c&gt; ( slot=3, port=3){\n            dsu (slot=3, port=3, init_addr=0)\n            rep (slot=3, port=3, iter=1, step=1, delay=0)\n        }\n    }\n\n    cell (x=2, y=0) {\n        rop &lt;route2w&gt; ( slot=0, port=2){\n            route (slot=0, option=0, sr=1, source=1, target= 0b0000000000000100)\n        }\n\n        rop &lt;write_c&gt; ( slot=2, port=2){\n            dsu (slot=2, port=2, init_addr=0)\n            rep (slot=2, port=2, iter=1, step=1, delay=0)\n        }\n\n        rop &lt;output_r&gt; (slot=1, port=3){\n            dsu (slot=1, port=3, init_addr=0)\n            rep (slot=1, port=3, iter=1, step=1, delay=0)\n        }\n\n        rop &lt;output_w&gt; (slot=1, port=1){\n            dsu (slot=1, port=1, init_addr=0)\n            rep (slot=1, port=1, iter=1, step=1, delay=0)\n        }\n    }\n}\n</code></pre> <p>The constraint file that work with the proto-assembly file is stored in <code>pasm/0.cstr</code>:</p> <pre><code>epoch &lt;rb0&gt; {\n    linear ( input_r == input_w )\n    linear ( route0r &lt; read_ab )\n    linear ( route1wr &lt; write_a )\n    linear ( route1wr &lt; write_b )\n    linear ( read_ab.e0[0] == write_a.e0[0] - 1 )\n    linear ( read_ab.e0[1] == write_b.e0[0] - 1 )\n    linear ( write_a &lt; read_a_seq )\n    linear ( write_b &lt; read_b_seq )\n    linear ( swb &lt; read_a_seq )\n    linear ( read_a_seq == read_b_seq )\n    linear ( read_a_seq + 1 &gt; compute )\n    linear ( write_c_seq == read_a_seq + 2 )\n\n    linear ( compute != route1wr )\n    linear ( compute != swb )\n\n    linear ( read_c.e0[0] &gt; write_c_seq.e0[15] )\n\n    linear ( write_c == read_c + 1 )\n    linear ( output_r &gt; write_c )\n    linear ( output_r == output_w )\n}\n</code></pre> <p>Please check the programming guide for more information about the proto-assembly and constraint file.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/Tutorial_DRRA/#simulation-and-verification","title":"Simulation and Verification","text":"<p>To simulate the algorithm, simply run:</p> <pre><code>./run.sh\n</code></pre> <p>If the output shows the simulation is successful, then the algorithm is correct.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.0/","title":"Isa 4.0","text":"<p>Note</p> <p>The slot number will decide which data port it configures.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.0/#instruction-format","title":"Instruction Format","text":"<p>Instructions are 32-bit wide. The MSB indicates whether it's a control instruction or a data instruction. [0]: control; [1]: data; The rest of the bits are used to encode the instruction content. For data instructions, the first 4 bits in the instruction content are used to indicate the slot number. The rest of the bits are used to encode the instruction content.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.0/#control-instructions","title":"Control Instructions","text":"Field Position Width Description instr_code [31, 28] 4 Instruction code. The MSB indicates whether it's a control instruction or a data instruction. [0]: control; [1]: data; instr_content [27, 0] 27 The content of the instruction. The meaning of this field depends on the instruction type and instruction code."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.0/#0000-wait","title":"0000 WAIT","text":"Field Position Width Default Value Description instr_code [31, 28] 4 0 Instruction code for WAIT mode [27, 27] 1 0 Wait mode: [0]: wait for a number of cycles; [1]: wait for the completion of task in slot X, X is defined by the cycle field using 1-hot encoding; cycle [26, 0] 28 0 Number of cycles. If cycle=0, then the WAIT instruction will wait forever. Or the sensitive slots in case the instruction mode is 1."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.0/#0001-act","title":"0001 ACT","text":"Field Position Width Default Value Description instr_code [31, 28] 4 1 Instruction code for ACT ports [27, 12] 16 0 1-hot encoded ports that need to be activated. There are 64 ports in total, but only 16 can be activated at the same time. The ports are filtered by the mode and parameter field. mode [11, 8] 4 0 Filter mode: [0]: Continues ports start from slot X; [1] All port X in each slot; [2]: the predefined 64-bit activation code in internal activation memory location X. param [7, 0] 8 0 The parameter for the filter mode."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.0/#0010-calc","title":"0010 CALC","text":"Field Position Width Default Value Description instr_code [31, 28] 4 2 Instruction code for CALC mode [27, 24] 4 0 Calculation mode [0]:idle; [1]:add; [2]:sub; [3]:shift_r; [4]:shift_l; [5]:mult; [6]:div; [7]:mod; operand1_sd [23, 23] 1 0 Is the first operand static or dynamic? [0]:s; [1]:d; operand1 [22, 14] 9 0 First operand. operand2_sd [13, 13] 1 0 Is the second operand static or dynamic? [0]:s; [1]:d; operand2 [12, 4] 9 0 Second operand. result [3, 0] 4 0 The RACCU register to store the result."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.0/#0011-loop","title":"0011 LOOP","text":"Field Position Width Default Value Description instr_code [31, 28] 4 3 Instruction code for LOOP loopid [27, 26] 2 0 The id of the loop manager slot. endpc [25, 19] 7 0 The PC where loop ends. It's relative to the current PC. start_sd [18, 18] 1 0 Is the start static or dynamic? [0]:s; [1]:d; start [17, 12] 6 0 The start of iterator. iter [11, 6] 6 0 The number of iteration. step [5, 0] 6 1 The iteration step."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.0/#0100-brn","title":"0100 BRN","text":"Field Position Width Default Value Description instr_code [31, 28] 4 4 Instruction code for BRN mode [27, 25] 3 0 The branch mode: [0]: always; [1]: equal; [2]: not_equal; [3]: greater; [4]: less; [5]: greater_equal; [6]: less_equal; pc [24, 18] 7 0 The PC to jump to in case the condition is true. The PC is relative to the current PC. slot [17, 14] 4 0 The slot that will provide the flags."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.0/#data-instructions","title":"Data Instructions","text":"Field Position Width Description instr_code [31, 28] 4 Instruction code. The MSB indicates whether it's a control instruction or a data instruction. [0]: control; [1]: data; slot [27, 24] 4 The slot number. instr_content [23, 0] 24 The content of the instruction. The meaning of this field depends on the instruction type and instruction code. <p>Note</p> <p>When instruction code start with \"111\", the instruction contains a field that need to be replaced by RACCU registers if the filed is marked \"dynamic\".</p> Slot Type Supported Instructions Register File MASK DSU, REP SRAM Block MASK, DSU, REP IO Block MASK, DSU, REP DPU DPU, REP"},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.0/#1000-rep","title":"1000 REP","text":"<p>This instruction is accepted by the following slots:</p> <ul> <li>swb</li> <li>iosram</li> <li>dpu</li> <li>rf</li> <li>sram</li> </ul> Field Position Width Default Value Description instr_code [31, 28] 4 8 Instruction code for REP slot [27, 24] 4 N/A Slot number. port [23, 21] 2 0 The port number. [0]: write narrow; [1]: read narrow; [2]: write wide; [3]: read wide; level [20, 17] 4 0 The level of the REP instruction. [0]: inner most level, [15]: outer most level. iter [16, 11] 6 0 iteration - 1. step [10, 5] 6 0 iteration step. This field is only useful when paired with REFI/SRAM instructions. delay [5, 0] 6 0 Repetition delay."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.0/#1001-repx","title":"1001 REPX","text":"<p>This instruction is accepted by the following slots:</p> <ul> <li>swb</li> <li>iosram</li> <li>dpu</li> <li>rf</li> <li>sram</li> </ul> Field Position Width Default Value Description instr_code [31, 28] 4 9 Instruction code for REPX. Configure the higher 6-bit of each field in the REP instruction. slot [27, 24] 4 N/A Slot number. port [23, 21] 2 0 The port number. [0]: write narrow; [1]: read narrow; [2]: write wide; [3]: read wide; level [20, 17] 4 0 The level of the REP instruction. [0]: inner most level, [15]: outer most level. iter [16, 11] 6 0 iteration - 1. step [10, 5] 6 0 iteration step. This field is only useful when paired with REFI/SRAM instructions. delay [5, 0] 6 0 Repetition delay."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.0/#1010-mask","title":"1010 MASK","text":"<p>This instruction is accepted by the following slots:</p> <ul> <li>iosram</li> <li>rf</li> <li>sram</li> </ul> Field Position Width Default Value Description instr_code [31, 28] 4 10 Instruction code for MASK slot [27, 24] 4 N/A Slot number. chunk [23, 21] 3 0 Mask chunk of 16 elements. If each element is 16-bit, only 1 chunk is needed. If each element is 8-bit, 2 chunks are needed. If each element is 4-bit, 4 chunks are needed. If each element is 2-bit, 8 chunks are needed. mask [20, 5] 16 0 The mask of 16-elements. If mask-bit is 0, then the corresponding element is useful and will be written to destination memory block. If mask-bit is 1, then the corresponding element is not useful and will be ignored."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.0/#1010-fsm","title":"1010 FSM","text":"<p>This instruction is accepted by the following slots:</p> <ul> <li>swb</li> <li>dpu</li> </ul> Field Position Width Default Value Description instr_code [31, 28] 4 10 Instruction code for FSM slot [27, 24] 4 N/A Slot number. port [23, 21] 3 0 The port number. [0]: write narrow; [1]: write narrow; [2]: write wide; [3]: read wide; delay_0 [20, 14] 7 0 The delay between state 0 and 1. delay_1 [13, 7] 7 0 The delay between state 1 and 2. delay_2 [6, 0] 7 0 The delay between state 2 and 3."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.0/#1011-dpu","title":"1011 DPU","text":"<p>This instruction is accepted by the following slots:</p> <ul> <li>dpu</li> </ul> Field Position Width Default Value Description instr_code [31, 28] 4 11 Instruction code for DPU slot [27, 24] 4 N/A Slot number. option [23, 22] 2 0 Programmable FSM states. Max 4 states. mode [21, 17] 5 0 The DPU mode. [0]:idle; [1]:add; [2]:sum_acc; [3]:add_const; [4]:subt; [5]:subt_abs; [6]:mode_6; [7]:mult; [8]:mult_add; [9]:mult_const; [10]:mac; [11]:ld_ir; [12]:axpy; [13]:max_min_acc; [14]:max_min_const; [15]:mode_15; [16]:max_min; [17]:shift_l; [18]:shift_r; [19]:sigm; [20]:tanhyp; [21]:expon; [22]:lk_relu; [23]:relu; [24]:div; [25]:acc_softmax; [26]:div_softmax; [27]:ld_acc; [28]:scale_dw; [29]:scale_up; [30]:mac_inter; [31]:mode_31; immediate [16, 1] 16 0 The immediate field used by some DPU modes."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.0/#1100-swb","title":"1100 SWB","text":"<p>This instruction is accepted by the following slots:</p> <ul> <li>swb</li> </ul> Field Position Width Default Value Description instr_code [31, 28] 4 12 Instruction code for SWB slot [27, 24] 4 N/A Slot number. option [23, 22] 2 0 Programmable FSM states. Max 4 states. channel [21, 18] 4 0 Bus channel. Note: if the SWB is implemented by a crossbar, the channel is always equals to the target slot. source [17, 14] 4 0 Source slot. target [13, 10] 4 0 Target slot"},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.0/#1101-route","title":"1101 ROUTE","text":"<p>This instruction is accepted by the following slots:</p> <ul> <li>swb</li> </ul> Field Position Width Default Value Description instr_code [31, 28] 4 13 Instruction code for ROUTE slot [27, 24] 4 N/A Slot number. option [23, 22] 2 0 Programmable FSM states. Max 4 states. sr [21, 21] 1 0 Send or receive. [0]: send; [1]: receive; source [20, 17] 4 0 1-hot encoded direction: E/N/W/S. If it's a receive instruction, the direction can only have 1 bit set to 1. target [16, 1] 16 0 1-hot encoded slot number. If it's a send instruction, the slot can only have 1 bit set to 1."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.0/#1110-dsu","title":"1110 DSU","text":"<p>This instruction is accepted by the following slots:</p> <ul> <li>iosram</li> <li>rf</li> <li>sram</li> </ul> Field Position Width Default Value Description instr_code [31, 28] 4 14 Instruction code for DSU slot [27, 24] 4 N/A Slot number. init_addr_sd [23, 23] 1 0 Is init_addr static or dynamic? [0]:s; [1]:d; init_addr [22, 7] 16 0 Initial address. port [6, 5] 2 0 The port number. [0]: write_narrow; [1]: read_narrow; [2]: write_wide; [3]: read_wide; If it's applied to IO, then [0]: read from IO to SRAM; [1]: write from SRAM to IO;"},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.1/","title":"Isa 4.1","text":""},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.1/#instruction-format","title":"Instruction Format","text":"<p>Instructions are 32-bit wide. The MSB indicates whether it's a control instruction or a resource instruction. [0]: control; [1]: resource; The first 4-bit (bit 32~28) is the instruction code. The rest of the bits are used to encode the instruction content. For resource instructions, bit 27~24 in the instruction content are used to indicate the slot number. The rest of the bits are used to encode the instruction content.</p>"},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.1/#control-instructions","title":"Control Instructions","text":"Field Position Width Description instr_code [31, 28] 4 Instruction code. The MSB indicates whether it's a control instruction or a resource instruction. [0]: control; [1]: data; instr_content [27, 0] 27 The content of the instruction. The meaning of this field depends on the instruction type and instruction code."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.1/#0000-halt","title":"0000 halt","text":"Field Position Width Default Value Description instr_code [31, 28] 4 0 Instruction code for halt. The halt instruction will stop the execution of the controller."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.1/#0001-wait","title":"0001 wait","text":"Field Position Width Default Value Description instr_code [31, 28] 4 1 Instruction code for wait mode [27, 27] 1 0 Wait mode: [0]: wait for a number of cycles; [1]: wait for the completion of task in slot X, X is defined by the cycle field using 1-hot encoding; cycle [26, 0] 28 0 if mode is 0, the wait instruction waits for cycle extra cycles excluding the current cycle used for the wait instruction. If mode is 1, it waits for the sensitive slots defined by 1-hot encoded cycle."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.1/#0010-act","title":"0010 act","text":"<p>Note</p> <p>Mode 2 is not supported for now.</p> Field Position Width Default Value Description instr_code [31, 28] 4 2 Instruction code for act ports [27, 12] 16 0 1-hot encoded ports that need to be activated. There are 64 ports in total, but only 16 can be activated at the same time. The ports are filtered by the mode and parameter field. mode [11, 8] 4 0 Filter mode: [0]: Continues ports start from slot X; [1] All port X in each slot; [2]: the predefined 64-bit activation code in internal activation memory location X. param [7, 0] 8 0 The parameter for the filter mode."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.1/#0011-calc","title":"0011 calc","text":"Field Position Width Default Value Description instr_code [31, 28] 4 3 Instruction code for CALC mode [27, 24] 4 0 Calculation mode. [0]:idle; [1]:add; [2]:sub; [3]:lls; [4]:lrs; [5]:mul; [6]:div; [7]:mod; [8]:bit-and; [9]:bit-or; [10]:bit-inv; [11]:bit-xor; [17]:eq; [18]:ne; [19]:gt; [20]:ge; [21]:lt; [22]:le; [32]:and; [33]:or; [34]:not; operand1 [23, 20] 4 0 First operand. operand2_sd [19, 19] 1 0 Is the second operand static or dynamic? [0]:s; [1]:d; operand2 [18, 11] 8 0 Second operand. result [10, 7] 4 0 The register to store the result. If it's scalar operation, the result is stored in the scalar register. If it's logic operations, the result is stored in the bool register."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.1/#0100-brn","title":"0100 brn","text":"Field Position Width Default Value Description instr_code [31, 28] 4 4 Instruction code for brn reg [27, 24] 4 0 The bool register to check target_true [23, 15] 9 0 The relative pc offset if the bool register is true. target_false [14, 6] 9 0 The relative pc offset if the bool register is false."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.1/#resource-instructions","title":"Resource Instructions","text":"Field Position Width Description instr_code [31, 28] 4 Instruction code. The MSB indicates whether it's a control instruction or a resource instruction. [0]: control; [1]: data; slot [27, 24] 4 The slot number. instr_content [23, 0] 24 The content of the instruction. The meaning of this field depends on the instruction type and instruction code. <p>Note</p> <p>When instruction code start with \"111\", the instruction contains a field that need to be replaced by RACCU registers if the filed is marked \"dynamic\".</p> Slot Type Supported Instructions Register File DSU, REP, REPX SRAM Block DSU, REP, REPX IO Block DSU, REP, REPX DPU DPU, REP, REPX, FSM"},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.1/#1000-rep","title":"1000 rep","text":"<p>This instruction is accepted by the following slots:</p> <ul> <li>swb</li> <li>iosram</li> <li>dpu</li> <li>rf</li> <li>sram</li> </ul> Field Position Width Default Value Description instr_code [31, 28] 4 8 Instruction code for REP slot [27, 24] 4 N/A Slot number. port [23, 21] 2 0 The port number. [0]: write narrow; [1]: read narrow; [2]: write wide; [3]: read wide; level [20, 17] 4 0 The level of the REP instruction. [0]: inner most level, [15]: outer most level. iter [16, 11] 6 0 iteration - 1. step [10, 5] 6 0 iteration step. This field is only useful when paired with REFI/SRAM instructions. delay [5, 0] 6 0 Repetition delay."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.1/#1001-repx","title":"1001 repx","text":"<p>This instruction is accepted by the following slots:</p> <ul> <li>swb</li> <li>iosram</li> <li>dpu</li> <li>rf</li> <li>sram</li> </ul> Field Position Width Default Value Description instr_code [31, 28] 4 9 Instruction code for REPX. Configure the higher 6-bit of each field in the REP instruction. slot [27, 24] 4 N/A Slot number. port [23, 21] 2 0 The port number. [0]: write narrow; [1]: read narrow; [2]: write wide; [3]: read wide; level [20, 17] 4 0 The level of the REP instruction. [0]: inner most level, [15]: outer most level. iter [16, 11] 6 0 iteration - 1. step [10, 5] 6 0 iteration step. This field is only useful when paired with REFI/SRAM instructions. delay [5, 0] 6 0 Repetition delay."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.1/#1010-fsm","title":"1010 fsm","text":"<p>This instruction is accepted by the following slots:</p> <ul> <li>swb</li> <li>dpu</li> </ul> Field Position Width Default Value Description instr_code [31, 28] 4 10 Instruction code for FSM slot [27, 24] 4 N/A Slot number. port [23, 21] 3 0 The port number. [0]: write narrow; [1]: write narrow; [2]: write wide; [3]: read wide; delay_0 [20, 14] 7 0 The delay between state 0 and 1. delay_1 [13, 7] 7 0 The delay between state 1 and 2. delay_2 [6, 0] 7 0 The delay between state 2 and 3."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.1/#1011-dpu","title":"1011 dpu","text":"<p>This instruction is accepted by the following slots:</p> <ul> <li>dpu</li> </ul> Field Position Width Default Value Description instr_code [31, 28] 4 11 Instruction code for DPU slot [27, 24] 4 N/A Slot number. option [23, 22] 2 0 Programmable FSM states. Max 4 states. mode [21, 17] 5 0 The DPU mode. [0]:idle; [1]:add; [2]:sum_acc; [3]:add_const; [4]:subt; [5]:subt_abs; [6]:mode_6; [7]:mult; [8]:mac; [9]:mult_const; [10]:accumulate; [11]:ld_ir; [12]:axpy; [13]:max_min_acc; [14]:max_min_const; [15]:mode_15; [16]:max_min; [17]:shift_l; [18]:shift_r; [19]:sigm; [20]:tanhyp; [21]:expon; [22]:lk_relu; [23]:relu; [24]:div; [25]:acc_softmax; [26]:div_softmax; [27]:ld_acc; [28]:scale_dw; [29]:scale_up; [30]:mac_inter; [31]:mode_31; immediate [16, 1] 16 0 The immediate field used by some DPU modes."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.1/#1100-swb","title":"1100 swb","text":"<p>This instruction is accepted by the following slots:</p> <ul> <li>swb</li> </ul> Field Position Width Default Value Description instr_code [31, 28] 4 12 Instruction code for SWB slot [27, 24] 4 N/A Slot number. option [23, 22] 2 0 Programmable FSM states. Max 4 states. channel [21, 18] 4 0 Bus channel. Note: if the SWB is implemented by a crossbar, the channel is always equals to the target slot. source [17, 14] 4 0 Source slot. target [13, 10] 4 0 Target slot"},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.1/#1101-route","title":"1101 route","text":"<p>This instruction is accepted by the following slots:</p> <ul> <li>swb</li> </ul> Field Position Width Default Value Description instr_code [31, 28] 4 13 Instruction code for ROUTE slot [27, 24] 4 N/A Slot number. option [23, 22] 2 0 Programmable FSM states. Max 4 states. sr [21, 21] 1 0 Send or receive. [0]: send; [1]: receive; source [20, 17] 4 0 1-hot encoded direction: E/N/W/S. If it's a receive instruction, the direction can only have 1 bit set to 1. target [16, 1] 16 0 1-hot encoded slot number. If it's a send instruction, the slot can only have 1 bit set to 1."},{"location":"Docs/ToolChain/Vesyla-suite/v4/InstructionSet/isa_4.1/#1110-dsu","title":"1110 dsu","text":"<p>This instruction is accepted by the following slots:</p> <ul> <li>iosram</li> <li>rf</li> <li>sram</li> </ul> Field Position Width Default Value Description instr_code [31, 28] 4 14 Instruction code for DSU slot [27, 24] 4 N/A Slot number. init_addr_sd [23, 23] 1 0 Is init_addr static or dynamic? [0]:s; [1]:d; init_addr [22, 7] 16 0 Initial address. port [6, 5] 2 0 The port number. [0]: write_narrow; [1]: read_narrow; [2]: write_wide; [3]: read_wide; If it's applied to IO, then [0]: read from IO to SRAM; [1]: write from SRAM to IO;"},{"location":"Guideline/Mkdocs-tutorial/","title":"MkDocs Tutorial","text":"<p>This tutorial will teach you how to use MkDocs to edit SiLagoDoc.</p>"},{"location":"Guideline/Mkdocs-tutorial/#what-is-mkdocs","title":"What is MkDocs?","text":"<p>MkDocs is a fast, simple and downright gorgeous static site generator that's geared towards building project documentation. Documentation source files are written in Markdown, and configured with a single YAML configuration file.</p> <p>MkDocs is based on python. The SiLagoDoc uses python 3.</p>"},{"location":"Guideline/Mkdocs-tutorial/#how-to-install-mkdocs","title":"How to install MkDocs?","text":"<p>Like all python packages, you can install MkDocs and its theme via pip.</p> <pre><code>pip install mkdocs mkdocs-material\n</code></pre>"},{"location":"Guideline/Mkdocs-tutorial/#how-to-use-mkdocs","title":"How to use MkDocs?","text":""},{"location":"Guideline/Mkdocs-tutorial/#clone-silagodoc-repo","title":"Clone SiLagoDoc repo","text":"<p>Use the following command:</p> <pre><code>git clone git@github.com:silagokth/SiLagoDoc.git\n</code></pre>"},{"location":"Guideline/Mkdocs-tutorial/#check-the-modification","title":"Check the modification","text":"<p>Note</p> <p>The render result is just on your local machine. It hasn't been commited to the server yet.</p> <p>Use the the follwing command:</p> <p><pre><code>cd SiLagoDoc\nmkdocs serve\n</code></pre> Now you can view the SiLagoDoc on your browser via the url: http://127.0.0.1:8000. The site will be automatically refreshed when you save your changes.</p>"},{"location":"Guideline/Mkdocs-tutorial/#automatically-deploy-the-site","title":"Automatically deploy the site","text":"<p>By simply commit your change to the repository, the site will be automatically updated. It might take several minutes.</p>"},{"location":"Guideline/Mkdocs-tutorial/#manually-build-and-deploy-the-site","title":"Manually Build and deploy the site","text":"<p>Warning</p> <p>SiLagoDoc has been configured with continous integration. You should not use this step to manually deploy the site. You should instead directly commit your source code to github and let it automatically generate the site.</p> <p>Once you are satisfied with the modification, you can build the site using the command:</p> <pre><code>mkdocs build\n</code></pre> <p>You will notice that a folder called site has been created. This site can then be deployed to the server.</p> <p>SiLagoDoc uses github pages to host the site. So you can use the following command to deploy:</p> <pre><code>mkdocs gh-deploy\n</code></pre>"},{"location":"Guideline/Mkdocs-tutorial/#how-to-write-documentation","title":"How to write documentation?","text":""},{"location":"Guideline/Mkdocs-tutorial/#add-a-page","title":"Add a page","text":"<p>You can add a documentation page in /docs. Some files already exist under the directory. There are three folders: /docs/About, /docs/Guideline, and /docs/Docs. Choose the correct folder to add your page. The documentation page uses Markdown format. The page file should have appendix of \".md\".</p> <p>Once a page is added, you should also update the configuration file to make it available on the navagation bar. The configuation file is: /mkdocs.yaml.</p>"},{"location":"Guideline/Mkdocs-tutorial/#edit-a-page","title":"Edit a page","text":"<p>You can edit a page and commit the change to github repo. Please see Markdown syntax.</p> <p>You can also directly edit a page through the website. Each page has a pencil icon on the top-right corner. You can click the icon, and you shall be directed to the github source code editing interface. You can just edit the file and save the change. Since SiLagoDoc has the continuous integration, your change will be automatically build and deploy to the website. It might take several minuts to refresh the site.</p>"},{"location":"Guideline/Mkdocs-tutorial/#delete-a-page","title":"Delete a page","text":"<p>Just remove the Markdown file and remove the corresponding entry in /mkdocs.yaml.</p>"},{"location":"Guideline/Mkdocs-tutorial/#theme-and-advanced-features","title":"Theme and advanced features","text":"<p>SiLagoDoc uses material theme for MkDocs. Besides the looks, the material theme also provides some extra features.</p> <p>The complete list of supported extensions can be found Here.</p>"},{"location":"Guideline/Style-guide-VHDL/","title":"Style guide for VHDL RTL","text":""},{"location":"Guideline/Style-guide-VHDL/#file-header","title":"File Header","text":"<p>Each file in the SiLago project has to contain a header that includes the copyright, license, author and change log information. The header should have the following form:</p> <pre><code>-------------------------------------------------------\n--! @file &lt;name of the file&gt;\n--! @brief &lt;Brief description of the file&gt;\n--! @details &lt;Detail description of the file (optional)&gt;\n--! @author &lt;Author\u2019s Name&gt;\n--! @version &lt;Version&gt;\n--! @date &lt;Date of last edit&gt;\n--! @bug &lt;Known Bugs (\u201cNONE\u201d if there are no bugs)&gt;\n--! @todo &lt;Todo, create one \u201c--! @todo\u201d for every todo&gt;\n--! @copyright GNU Public License [GPL-3.0].\n-------------------------------------------------------\n---------------- Copyright (c) notice -----------------------------------------\n--\n-- The VHDL code, the logic and concepts described in this file constitute\n-- the intellectual property of the authors listed below, who are affiliated\n-- to KTH(Kungliga Tekniska H\u00f6gskolan), School of EECS, Kista.\n-- Any unauthorised use, copy or distribution is strictly prohibited.\n-- Any authorised use, copy or distribution should carry this copyright notice\n-- unaltered.\n-------------------------------------------------------------------------------\n-- Title      : &lt;Title of the Entity or Package&gt;\n-- Project    : &lt;Project that file belongs to (e.g. SiLago, eBrain, etc)&gt;\n-------------------------------------------------------------------------------\n-- File       : &lt;name of the file&gt;\n-- Library    : &lt;Name of the library that this file should be compiled in&gt;\n-- Author     : &lt;Author\u2019s Name&gt;\n-- Company    : KTH\n-- Created    : &lt;Date of creation&gt;\n-- Last update: &lt;Date of last edit&gt;\n-- Platform   : SiLago\n-- Standard   : VHDL'08\n-------------------------------------------------------------------------------\n-- Copyright (c) &lt;year of creation&gt;\n-------------------------------------------------------------------------------\n-- Contact    : &lt;Main contact person eg. Dimitrios Stathis &lt;stathis@kth.se&gt;&gt;\n-------------------------------------------------------------------------------\n-- Revisions  :\n-- Date        Version  Author                  Description\n-- 2020-12-07  1.0      &lt;Authors Name&gt;          &lt;description&gt;\n-------------------------------------------------------------------------------\n\n--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#\n--                                                                         #\n--This file is part of SiLago.                                             #\n--                                                                         #\n--    SiLago platform source code is distributed freely: you can           #\n--    redistribute it and/or modify it under the terms of the GNU          #\n--    General Public License as published by the Free Software Foundation, #\n--    either version 3 of the License, or (at your option) any             #\n--    later version.                                                       #\n--                                                                         #\n--    SiLago is distributed in the hope that it will be useful,            #\n--    but WITHOUT ANY WARRANTY; without even the implied warranty of       #\n--    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        #\n--    GNU General Public License for more details.                         #\n--                                                                         #\n--    You should have received a copy of the GNU General Public License    #\n--    along with SiLago.  If not, see &lt;https://www.gnu.org/licenses/&gt;.     #\n--                                                                         #\n--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#\n</code></pre>"},{"location":"Guideline/Style-guide-VHDL/#vscode-snippet","title":"VSCODE Snippet","text":"<p>This is the snippet code for vs-code. You can modify the code and add it as a snippet in your favorite editor.</p> <pre><code>\"vhdl_notice\": {\n        \"scope\": \"vhdl\",\n        \"prefix\": \"note\",\n        \"body\": [\n            \"-------------------------------------------------------\",\n            \"--! @file $TM_FILENAME\",\n            \"--! @brief ${1:UnitX}\",\n            \"--! @details \",\n            \"--! @author ${3:Dimitrios Stathis}\",\n            \"--! @version 1.0\",\n            \"--! @date $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE\",\n            \"--! @bug NONE\",\n            \"--! @todo NONE\",\n            \"--! @copyright  GNU Public License [GPL-3.0].\",\n            \"-------------------------------------------------------\",\n            \"---------------- Copyright (c) notice -----------------------------------------\",\n            \"--\",\n            \"-- The VHDL code, the logic and concepts described in this file constitute\",\n            \"-- the intellectual property of the authors listed below, who are affiliated\",\n            \"-- to KTH(Kungliga Tekniska H\u00f6gskolan), School of EECS, Kista.\",\n            \"-- Any unauthorised use, copy or distribution is strictly prohibited.\",\n            \"-- Any authorised use, copy or distribution should carry this copyright notice\",\n            \"-- unaltered.\",\n            \"-------------------------------------------------------------------------------\",\n            \"-- Title      : ${1:UnitX}\",\n            \"-- Project    : ${2:SiLago}\",\n            \"-------------------------------------------------------------------------------\",\n            \"-- File       : $TM_FILENAME\",\n            \"-- Library    : ${4:work}$\"\n            \"-- Author     : ${3:Dimitrios Stathis}\",\n            \"-- Company    : KTH\",\n            \"-- Created    : $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE\",\n            \"-- Last update: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE\",\n            \"-- Platform   : ${2:SiLago}\",\n            \"-- Standard   : VHDL'08\",\n            \"-------------------------------------------------------------------------------\",\n            \"-- Copyright (c) $CURRENT_YEAR\",\n            \"-------------------------------------------------------------------------------\",\n            \"-- Contact    : ${3:Dimitrios Stathis} ${4:&lt;stathis@kth.se&gt;}\",\n            \"-------------------------------------------------------------------------------\",\n            \"-- Revisions  :\",\n            \"-- Date        Version  Author                  Description\",\n            \"-- $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE  1.0      ${3:Dimitrios Stathis}      Created\",\n            \"-------------------------------------------------------------------------------\",\n            \"\",\n            \"--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#\",\n            \"--                                                                         #\",\n            \"--This file is part of ${2:SiLago}.                                             #\",\n            \"--                                                                         #\",\n            \"--    ${2:SiLago} platform source code is distributed freely: you can           #\",\n            \"--    redistribute it and/or modify it under the terms of the GNU          #\",\n            \"--    General Public License as published by the Free Software Foundation, #\",\n            \"--    either version 3 of the License, or (at your option) any             #\",\n            \"--    later version.                                                       #\",\n            \"--                                                                         #\",\n            \"--    ${2:SiLago} is distributed in the hope that it will be useful,            #\",\n            \"--    but WITHOUT ANY WARRANTY; without even the implied warranty of       #\",\n            \"--    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        #\",\n            \"--    GNU General Public License for more details.                         #\",\n            \"--                                                                         #\",\n            \"--    You should have received a copy of the GNU General Public License    #\",\n            \"--    along with ${2:SiLago}.  If not, see &lt;https://www.gnu.org/licenses/&gt;.     #\",\n            \"--                                                                         #\",\n            \"--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#\",\n</code></pre>"},{"location":"Guideline/Style-guide-VHDL/#style-and-formatting","title":"Style and Formatting","text":"<ol> <li>Tabs and indentation               :<ul> <li>Each indentation and tab should be 2 spaces. Remember to change the settings of your editor so that it adds 2 space characters when pressing tab, and not a \u2018tab\u2019 character.</li> </ul> </li> <li>Keywords                              :<ul> <li>All VHDL keywords, such as <code>signal</code>, <code>variable</code>, etc., should be in lower case.</li> </ul> </li> <li>=, &lt;=, =&gt;, :, and :=                :<ul> <li>All VHDL operands should be aligned as best as possible.</li> </ul> </li> <li>Constant\u2019s name                   :<ul> <li>The names of all constants should be capitalized.</li> </ul> </li> <li>Signal\u2019s &amp; variable\u2019s name      :<ul> <li>A Signal/Variable\u2019s name should be low-case. This also applies to acronyms, such as drra, dpu, agu, etc. Only exceptions are macros, such as DesignWare blocks (DW_add, DW_tap...), or SRAMs, etc. The name should be descriptive and multiple words should be separated with \u2018_\u2019.</li> </ul> </li> <li>Type\u2019s name                         :<ul> <li>A type or subtype name should be in low-case letters and end with the suffix _ty. For example conf_ty.</li> </ul> </li> <li>Special suffix for signal names :<ul> <li>When a signal is active on a negative level (for example a negative triggered reset) use the suffix _n. For example rst_n.</li> </ul> </li> <li>Entity\u2019s name                     :<ul> <li>The name of the entity should be the same as the name of the file and low-case.</li> </ul> </li> <li>Architecture\u2019s name                 :<ul> <li>The name of the architecture should be the name of the entity with the suffix <code>_beh</code>, <code>_beh</code> for behavioral or structural style.</li> </ul> </li> <li>ENTITY                              :<ul> <li>When defying an entity the GENERIC and PORT should always start in a new line. The declaration of the signals and generics should also start in a new line. For example:</li> </ul> </li> </ol> <pre><code>ENTITY &lt;NAME&gt; IS\n  GENERIC (\n    width : NATURAL := 8 --! Input width (N)\n  );\n  PORT (\n    in_a : IN STD_LOGIC_VECTOR(width - 1 DOWNTO 0);\n    in_b : IN STD_LOGIC_VECTOR(width - 1 DOWNTO 0);\n    conf : IN STD_LOGIC;\n    out  : OUT STD_LOGIC_VECTOR(2 * width - 1 DOWNTO 0)\n  );\n</code></pre> <ol> <li>IF - THEN \u2026 ELSE \u2026 END  :<ul> <li>IF - THEN \u2026 ELSE statements should always start in a new line and comments should be added in the previous line, before the condition. Always leave an empty line before and after the code block for readability. For example:</li> </ul> </li> </ol> <pre><code>-- This if statement checks condition A, if True it does code A\nIF condition A THEN\n\n    Code A\n\n-- IF condition B is true it does code B\nELSIF condition B THEN\n\n    Code B\n\n-- In other case do code other\nELSE\n\n    Code other\n\nEND;\n</code></pre> <ol> <li>CASE, FOR, etc.         :<ul> <li>Use the same guide as IF.</li> </ul> </li> <li>WHEN \u2026 ELSE         :<ul> <li>When using WHEN \u2026 ELSE there should be a new line after the ELSE. For example:</li> </ul> </li> </ol> <pre><code>-- Description comment\n&lt;signal&gt; &lt;= '1' WHEN &lt;condition&gt; ELSE\n    '0';\n</code></pre> <ol> <li>IF/FOR \u2026 GENERATE       :<ul> <li>Generate statements should always have a descriptive name.</li> </ul> </li> <li>PORT MAPS           :<ul> <li>When instantiating a component, the GENERIC/PORT MAP should always start in a new line and the port/generic connection should also start in a new line. The component should always have a descriptive name starting with U_. Also, it is recommended to instantiate using ENTITY instead of COMPONENT. Before the installation there should be a comment to describe the component. For example:</li> </ul> </li> </ol> <pre><code>--! This component is doing something\nDUT : ENTITY work.conf_mul_Beh\n    GENERIC MAP(\n      width =&gt; bit_width\n    )\n    PORT MAP(\n      in_a =&gt; STD_LOGIC_VECTOR(inst_a),\n      in_b =&gt; STD_LOGIC_VECTOR(inst_b),\n      conf =&gt; conf,\n      prod =&gt; prod\n    );\n</code></pre> <ol> <li>ASSERTIONS          :<ul> <li>ASSERT, REPORT and SEVERITY should always start in a new line.</li> </ul> </li> <li>There should be a maximum of 1 empty line between code segments and comments should be directly above or next to the code that they comment.</li> </ol>"},{"location":"Guideline/Style-guide-VHDL/#coding-style","title":"Coding style","text":"<p>Each entity should implement a specific function of the design. It is not recommended to have large entities that implement complex functions. We recommend that when describing a complex function, you use one entity for each FSM of the design and a separate entity for each register files, data computation, etc.</p>"},{"location":"Guideline/Style-guide-VHDL/#libraries","title":"Libraries","text":"<p>For all VHDL files always use <code>numeric_std</code> library and do not use <code>std_logic_arith</code>, <code>std_logic_signed</code>, or <code>std_logic_unsigned</code>.</p>"},{"location":"Guideline/Style-guide-VHDL/#clocking","title":"Clocking","text":"<p>Always use the <code>rising_edge</code> or <code>falling_edge</code> for checking the clock edge and not <code>clk=\u20191\u2019 and clk\u2019event</code>.</p>"},{"location":"Guideline/Style-guide-VHDL/#fsm-description","title":"FSM description","text":"<p>When describing in VHDL it is recommended that you use a two-process design. In the two process design each ARCHITECTURE has two processes. The first process is a clocked process and registers the state of the FSM and any other signal that is required. The second process is combinatorial, and it is used to describe the FSM, using a CASE statement. When writing the combinatorial process the designer needs to be careful to include all the required signals in the sensitivity list and make sure that no latches are generated. While debugging, the ALL keyword can be used in the sensitivity list to make sure that the behavior of the process is correct. To avoid any latches, all signals that are edited inside the combinatorial process should be assigned a default value in the beginning of the process (before the case statement).</p> <p>Alternatively, a single process design can be used. In a single process design, only one process is required in the entity. The process is clocked and it both describes the FSM and registers its state. The single process design should be used with care since it can only describe registered FSMs (i.e. the outputs of the FSM are always registered).</p>"},{"location":"Guideline/Style-guide-VHDL/#commenting-and-documentation","title":"COMMENTING AND DOCUMENTATION","text":"<p>Commenting in RTL is important for you as a designer, and for the people taking over your code. It is important to remember that RTL is not programming, when you code in RTL you describe something real. So you should add descriptions before your entities or modules and your architecture that describe what exactly your entity, module or architecture is meant to implement. If you can not describe it in words, then you can not implement it. In the following examples we follow the Doxygen commenting style, but this is not necessary.</p>"},{"location":"Guideline/Style-guide-VHDL/#entities","title":"Entities","text":"<p>Each entity should have a brief and possible a detail description. The brief description should explain the basic function of the component. The detail description should describe its interface, such as special relation between signals, and a more detail view of its functionality. For example: <pre><code>--! This is a reconfigurable multiplier. It can operate in different fixed point precision.\n\n--! The input of the multiplier is a N-bit bit stream. The stream can be treated as a N-bit signed\n--! number, two N/2-bit signed numbers, or four N/4-bit signed numbers. The output is a 2N-bit bit stream.\n--! The output is splitted in one, two, or four, depending on the configuration.\nENTITY conf_mul_Beh IS\n  GENERIC (\n    width : NATURAL := 8 --! Input width (N)\n  );\n  PORT (\n    in_a : IN STD_LOGIC_VECTOR(width - 1 DOWNTO 0);       --! Input A, N-bit\n    in_b : IN STD_LOGIC_VECTOR(width - 1 DOWNTO 0);       --! Input B, N-bit\n    conf : IN STD_LOGIC;                                  --! Configuration bits, define\n    prod : OUT STD_LOGIC_VECTOR(2 * width - 1 DOWNTO 0)   --! Product output, 2N-bit\n  );\nEND ENTITY conf_mul_Beh;\n</code></pre></p>"},{"location":"Guideline/Style-guide-VHDL/#inoutsignalsvariablesgenerics","title":"IN/OUT/SIGNALS/VARIABLES/GENERICS","text":"<p>All signals, variables, generics, etc. should include a description comment after its definition, see the code above.</p>"},{"location":"Guideline/Style-guide-VHDL/#architectures","title":"Architectures","text":"<p>All architectures should have possible a brief and mandatory a detail description. The descriptions should describe the architectural details of the implementation, for example if it is a one or two process design etc. For example:</p> <pre><code>--! @brief This is the architecture of a reconfigurable multiplier (16-bit)\n--! @details In this version we are using a shift and ADD architecture instead of the\n--! conventional array multiplier, the multiplication is decomposed in to 4 smaller\n--! multipliers. The products of the smaller multiplication are shifted and then added\n--! to generate the final result. A sign extension is used to switch between the two modes\nARCHITECTURE rtl OF conf_mul_Beh IS\n\n  CONSTANT width2 : NATURAL := divUp(width, 2); --! Constant value for Width/2\n  SIGNAL temp_a1 : signed(width2 - 1 DOWNTO 0); --! MSBs of A\n  SIGNAL temp_a0 : signed(width2 DOWNTO 0);     --! LSBs of A\n\nBEGIN\n</code></pre>"},{"location":"Guideline/Style-guide-VHDL/#processes","title":"Processes","text":"<p>Complex processes should have a description of what they are trying to implement</p> <pre><code>--! This process checks if the loop should be executed (i.e. if  number of iterations &gt;0 )\n    zero_loop : PROCESS (instr, config)\n    BEGIN\n\n        &lt;CODE BLOCK&gt;\n\n    END PROCESS zero_loop;\n</code></pre>"},{"location":"Guideline/Style-guide-VHDL/#naming-convention","title":"Naming convention","text":"<p>Keep the naming of your objects clear and descriptive. When multiple words are used in a name they should be seperated by <code>_</code>.</p> <p>Avoid using names like north, south, east and west. Instead use names top, bottom, left and right. </p>"},{"location":"Guideline/Style-guide-VHDL/#variables-signals-and-constants","title":"Variables, Signals and Constants","text":"<p>All variables, signals and constnats should use clear and descriptive names. They should also have a comment describing what the do in their definition.</p> <p>Constants should use all capital letters, and variables and singals small letters.</p>"},{"location":"Guideline/Style-guide-VHDL/#entities-files-functions-and-architectures","title":"Entities, Files, Functions and Architectures","text":"<p>Entities should have descriptive names, but simple and short. Each entity should be in one single file and followed by its architecture. The file name should be the same as the entity. The architecture name should be descriptive of the style, for example behavioral or structural. </p> <p>Functions should have clear descriptive names, it is ok if they are long.</p>"},{"location":"Guideline/Style-guide-VHDL/#other-usefull-toolsplugins","title":"OTHER USEFULL TOOLS/PLUGINS","text":""},{"location":"Guideline/Style-guide-VHDL/#vscode","title":"VSCODE:","text":""},{"location":"Guideline/Style-guide-VHDL/#vhdl-specific","title":"VHDL specific","text":"<ul> <li> <p>https://marketplace.visualstudio.com/items?itemName=rjyoung.vscode-modern-vhdl-support : Highlight, Snippets and some autocompletion.</p> </li> <li> <p>https://marketplace.visualstudio.com/items?itemName=Vinrobot.vhdl-formatter : VHDL formatter</p> </li> </ul>"},{"location":"Guideline/Style-guide-VHDL/#language-servers","title":"Language servers:","text":"<ul> <li> <p>https://marketplace.visualstudio.com/items?itemName=hbohlin.vhdl-ls : Good but it has some small issues.</p> </li> <li> <p>https://marketplace.visualstudio.com/items?itemName=vhdl-tool.vhdl-tool : Good and multiplatform, free as of now (2023)</p> </li> <li> <p>https://marketplace.visualstudio.com/items?itemName=ViDE-Software.v4pvhdlforprofessionals : Extremely good, it requires a license. Does not work with modern-VHDL plugin.</p> </li> </ul>"},{"location":"Guideline/Style-guide-VHDL/#productivity-plugins","title":"Productivity plugins","text":"<ul> <li> <p>https://marketplace.visualstudio.com/items?itemName=dkundel.vscode-new-file : Advance functions for creating new files.</p> </li> <li> <p>https://marketplace.visualstudio.com/items?itemName=bladnman.auto-align : Auto align</p> </li> <li> <p>https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow : Colors the indentation.</p> </li> <li> <p>https://marketplace.visualstudio.com/items?itemName=adammaras.overtype : Enables overtype using INS button.</p> </li> <li> <p>https://marketplace.visualstudio.com/items?itemName=2gua.rainbow-brackets : Colors the brackets</p> </li> <li> <p>https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker : Spell checker for your code and comments</p> </li> </ul>"},{"location":"Guideline/Style-guide-VHDL/#shortcut-keys-and-emulation","title":"Shortcut keys and emulation","text":"<ul> <li> <p>https://marketplace.visualstudio.com/items?itemName=hiro-sun.vscode-emacs : Emacs keymap</p> </li> <li> <p>https://marketplace.visualstudio.com/items?itemName=vscodevim.vim : Vim emulator</p> </li> </ul>"},{"location":"Guideline/Style-guide-Verilog/","title":"Style guide for Verilog and SystemVerilog RTL","text":"<p>The coding guides are splited into three parts:</p> <ul> <li>Naming conventions</li> <li>Coding style </li> <li>Inline documentation</li> </ul>"},{"location":"Guideline/Style-guide-Verilog/#naming-conventions","title":"Naming conventions","text":""},{"location":"Guideline/Style-guide-Verilog/#capitalization","title":"Capitalization","text":"<p>All signal/variables and module names must be written in lower case. This includes acronyms and abbreviations such as <code>sram</code>, <code>dpu</code>, <code>drra</code>, etc. All constants and parameters must be written in upper case. The following example shows how to use capitalization: <pre><code>// Bad\nmodule My_Module (\n    input Clk,\n    input Rst,\n    input [width-1:0] DataInput,\n    output [width-1:0] RESULt\n);\n\n// Good\nmodule my_module (\n    input              clk,\n    input              rst,\n    input  [WIDTH-1:0] data,\n    output [WIDTH-1:0] result\n);\n</code></pre> The only exception to this rule are macros that are originally written in upper case and thus shouldn't be changed. For example DesignWare/ChipWare, SRAM macros, etc. </p>"},{"location":"Guideline/Style-guide-Verilog/#naming","title":"Naming","text":"<p>Signals, modules, parameters and all design elements should be named with descriptive names. Try to avoid abbreviations unless for extremely common names, such as <code>clk</code>, <code>rst_n</code>, <code>ack</code>, etc. Remember that abreviations are not always clear. For example, addr could mean address or <code>adder</code>. The over-use of abbreviations can make the code difficult to read and understand, especially for people that are not familiar with the code. The following example shows how to use descriptive names: <pre><code>// Bad\nlogic din;\nlogic dout;\nlogic re;\nlogic we;\nlogic raddr;\n\n// Good\nlogic data_in;\nlogic data_out;\nlogic read_enable;\nlogic write_enable;\nlogic read_address;\n</code></pre></p>"},{"location":"Guideline/Style-guide-Verilog/#sufixes","title":"Sufixes","text":"<p>Some types of signals/ports have a standard sufix. They should be used whenever possible. The following table shows the standard sufixes:</p> Type Sufix Instances <code>_inst</code> Clock signals <code>_clk</code> Reset signals <code>_rst</code> Enable signals <code>_en</code> Active low signals <code>_n</code> Register signals <code>_reg</code> Struct <code>_st</code>"},{"location":"Guideline/Style-guide-Verilog/#prefixes","title":"Prefixes","text":"<p>Some types of labels have a standard prefix. They should be used whenever possible. The following table shows the standard prefixes:</p> Block Label <code>always_comb</code> blocks <code>comb_</code> <code>always_ff</code> blocks <code>ff_</code>"},{"location":"Guideline/Style-guide-Verilog/#coding-style","title":"Coding style","text":"<p>The style is the way to write the code. It is important to follow the same style across all files and projects. This helps people that might be unfamiliar with the code to navigate through it. The style is defined by the following rules:</p>"},{"location":"Guideline/Style-guide-Verilog/#indentation","title":"Indentation","text":"<p>The indentation is done with 4 spaces. No tabs are allowed. Modify your editor settings to use 4 spaces when pressing the tab key. </p>"},{"location":"Guideline/Style-guide-Verilog/#vim","title":"Vim","text":"<p>Add the following lines to your <code>.vimrc</code> file: <pre><code>set tabstop=4\nset shiftwidth=4\nset expandtab\n</code></pre></p>"},{"location":"Guideline/Style-guide-Verilog/#emacs","title":"Emacs","text":"<p>Add the following lines to your <code>.emacs</code> file: <pre><code>(setq-default indent-tabs-mode nil)\n(setq-default tab-width 4)\n(setq indent-line-function 'insert-tab)\n</code></pre></p>"},{"location":"Guideline/Style-guide-Verilog/#visual-studio-code","title":"Visual Studio Code","text":"<p>Add the following lines to your <code>settings.json</code> file: <pre><code>\"editor.tabSize\": 4,\n\"editor.insertSpaces\": true,\n</code></pre></p>"},{"location":"Guideline/Style-guide-Verilog/#gedit","title":"Gedit","text":"<p>Add the following lines to your <code>.profile</code> file: <pre><code>export GEDIT_TAB_WIDTH=4\nexport GEDIT_REPLACE_TABS=1\n</code></pre></p>"},{"location":"Guideline/Style-guide-Verilog/#other-editors","title":"Other editors","text":"<p>Please refer to the editor documentation to find out how to change the indentation settings.</p>"},{"location":"Guideline/Style-guide-Verilog/#line-length","title":"Line length","text":"<p>The line length should be limited to a reasonable number of characters. The historically recommended maximum line length is 80 characters.  Nowadays with big computer screens 80 characters is usually too small. A good compromise is to limit the line length to 120 characters. This is not a hard limit, but it should be used as a guideline. If a line is too long, it should be split into multiple lines. The line should be split at a logical point, for example, after a comma or an operator. The following example shows how to split a line: <pre><code>// Bad\nassign result = (a + b) * (c + d) * (e + f) * (g + h) * (i + j) * (k + l) * (m + n) * (o + p) * (q + r) * (s + t) * (u + v) * (w + x) * (y + z);\n\n// Good\nassign result = (a + b) * (c + d) * (e + f) * (g + h) * (i + j) * (k + l) *\n                (m + n) * (o + p) * (q + r) * (s + t) * (u + v) * (w + x) *\n                (y + z);\n</code></pre> Some exceptions for this rule are allowed. For example, long strings or long comments can be longer than 80 characters. For example paths to standard cell libraries, long names for macros, etc. In general you won't need to read and understand those lines, so it does not matter if they are longer than 80 characters.</p>"},{"location":"Guideline/Style-guide-Verilog/#spaces","title":"Spaces","text":"<p>Spaces should be used to improve readability. Spaces should be used after commas, semicolons, operators, etc. The following example shows how to use spaces: <pre><code>// Bad\nassign result=(a+b)*(c+d);\n\n// Good\nassign result = (a + b) * (c + d);\n</code></pre></p>"},{"location":"Guideline/Style-guide-Verilog/#alignment","title":"Alignment","text":"<p>Alignment should be used to improve readability. The following example shows how to use alignment: <pre><code>// Bad\nassign result = (a + b) * (c + d);\nassign result2 = (a + b) * (c + d);\nassign result10 = (a + b) * (c + d);\n\n// Good\nassign result   = (a + b) * (c + d);\nassign result2  = (a + b) * (c + d);\nassign result10 = (a + b) * (c + d);\n</code></pre></p> <p>For module declarations, each port should be in a new line and aligned. The following example shows how to align module ports: <pre><code>// Bad\nmodule my_module (input clk, input rst, input [7:0] data, output reg [7:0] result);\n\n// Good\nmodule my_module (\n    input       clk,\n    input       rst,\n    input [7:0] data,\n    output reg  [7:0] result\n);\n</code></pre></p> <p>For module instantiations, each port and parameter should also be in a new line and aligned. The following example shows how to align module ports and parameters:</p> <pre><code>// Bad\nmy_module #(WIDTH = 4, DEPTH = 5) my_module_inst (.clk(clk), .rst(rst), .data(data), .result(result));\n\n// Good\nmy_module #(\n    .WIDTH(4),\n    .DEPTH(5)\n) my_module_inst (\n    .clk(clk),\n    .rst(rst),\n    .data(data),\n    .result(result)\n);\n</code></pre>"},{"location":"Guideline/Style-guide-Verilog/#automatic-styler","title":"Automatic styler","text":"<p>It is recomended to use a tool to automatically format the code. This will save you time and will ensure that the code is always formatted in the same way. The following tools are recomended:</p> <ul> <li>TerosHDL is a VS Code extension that provides styling, linting, documentation generation, etc.</li> <li>svlangserver is a language server for SystemVerilog. It provides styling, linting, code completion, etc. It can be used with any editor that supports language servers, such as VS Code, Vim, Emacs, etc.</li> <li>verible is a SystemVerilog formatter. It can be used as a standalone tool or called from other tools, such as TerosHDL or svlangserver.</li> </ul>"},{"location":"Guideline/Style-guide-Verilog/#inline-documentation","title":"Inline documentation","text":"<p>Inline documentation is used to describe the design. It is important to document the design to make it easier to understand. The following rules should be followed when writing the documentation:</p> <ul> <li>The documentation should be written in a way that is easy to understand by people that are not familiar with the design.</li> <li>The documentation should be written in English.</li> <li>Ports, parameters should be documented. I.e. all inputs and outputs of a module should be documented.</li> <li>Internal signals that are self-explanatory do not need to be documented.</li> </ul> <p>The inline comments can then be used to automatically generate documentation for the designs. For this project we use TerosHDL documentation generator, which can be used as part of the VS Code extension or in standalone mode using the python package.</p> <p>To add documentation to a design use <code>//!</code> as the comment character. Comments that start with <code>//!</code> will be parsed by the documentation generator. Comments with <code>//</code> can be used for \"local\" explanations that should not be reflected in the global documentation.</p> <p>Comments should be added at the begining of the module, before the ports and parameters. A decription of the module should be priovided before the module starts. Additional information can be included in the module description, such as fsm or timing diagrams with wavedrom, etc. The following example shows how to document a module: <pre><code>//! Implements the storage section of the register file\n//! \n//! Multiple register_row instances are created according to the\n//! &lt;register_page.REGISTER_FILE_DEPTH&gt; parameter.\n//! \n//! Timing diagram:\n//! This is an example of a read transaction\n//! {signal: [\n//!  {name: 'clk', wave: 'p.....|...'},\n//!  {name: 'dat', wave: 'x.345x|=.x', data: ['head', 'body', 'tail', 'data']},\n//!  {name: 'req', wave: '0.1..0|1.0'},\n//!  {},\n//!  {name: 'ack', wave: '1..01.|01.'}\n//! ]}\n\n\nmodule register_page #(\n    //! Width of the data words\n    parameter DATA_WIDTH = 16,\n    //! Width of the blocks, connection between register file and memory\n    parameter BLOCK_WIDTH = 256,\n    //! Number of words\n    parameter REGISTER_FILE_DEPTH = 64,\n    //! Number of read ports\n    parameter NUMBER_OF_READ_PORTS = 2,\n    //! Number of input ports\n    parameter NUMBER_OF_WRITE_PORTS = 1,\n    /* Local parameters */\n    //! Length of the address of a word\n    parameter WORD_ADDRESS_WIDTH = $clog2(REGISTER_FILE_DEPTH),\n    //! Number of blocks accessed by the wide port\n    parameter NUMBER_OF_BLOCKS = (DATA_WIDTH * REGISTER_FILE_DEPTH) / BLOCK_WIDTH,\n    //! Number of words in a block\n    parameter BLOCK_DEPTH = BLOCK_WIDTH / DATA_WIDTH,\n    //! Length of the address of a block\n    parameter BLOCK_ADDRESS_WIDTH = $clog2(NUMBER_OF_BLOCKS)\n) (\n    //! Asynchronous active low reset\n    input logic rst_n,\n    //! Clock signal\n    input logic clk,\n\n    /* Word access signals */\n    //! Array of write addresses for word access, one for each write port\n    input  logic [WORD_ADDRESS_WIDTH-1:0] write_address[NUMBER_OF_WRITE_PORTS-1:0],\n    //! Array of read addresses for word access, one for each read port\n    input  logic [WORD_ADDRESS_WIDTH-1:0] read_address [ NUMBER_OF_READ_PORTS-1:0],\n    //! Data input for word access, one word for each read port\n    input  logic [        DATA_WIDTH-1:0] data_in      [NUMBER_OF_WRITE_PORTS-1:0],\n    //! Data output for word access, one word for each write port\n    output logic [        DATA_WIDTH-1:0] data_out     [ NUMBER_OF_READ_PORTS-1:0],\n    //! Read enable flag, one bit for each read port\n    input  logic                          read_enable  [ NUMBER_OF_READ_PORTS-1:0],\n    //! Write enable flab, one bit for each write port\n    input  logic                          write_enable [NUMBER_OF_WRITE_PORTS-1:0],\n\n    /* Block access signals */\n    //! Read address for block access\n    input  logic [BLOCK_ADDRESS_WIDTH-1:0] block_read_address,\n    //! Write address for block access\n    input  logic [BLOCK_ADDRESS_WIDTH-1:0] block_write_address,\n    //! Data input for block access\n    input  logic [        BLOCK_WIDTH-1:0] block_data_in,\n    //! Data output for block access\n    output logic [        BLOCK_WIDTH-1:0] block_data_out,\n    //! Block read enable flag\n    //! '0' -&gt; Row access mode (depending on read_enable flags)\n    //! '1' -&gt; Block access mode\n    input  logic                           block_read_enable,\n    //! Block write enable flag\n    //! - &lt;0&gt; -&gt; Row access mode (depending on write_enable flags)\n    //! - '1' -&gt; Block access mode\n    input  logic                           block_write_enable\n);\n\nendmodule;\n</code></pre></p> <p>This code will generate the following documentation: </p>"},{"location":"Guideline/Style-guide-cpp/","title":"C++ Style Guide","text":""},{"location":"Guideline/Style-guide-cpp/#basics","title":"Basics","text":"<p>In general, all C++ code should follow the LLVM Style.</p> <p>The preferred editor for C++ program is Visual Studio Code. It works on all major operating systems.</p>"},{"location":"Guideline/Style-guide-cpp/#package-organization","title":"Package Organization","text":"<p>The package should be organized in the following way:</p> <pre><code>ROOT_DIR/\n  +--README.md\n  +--LICENSE.md\n  +--CMakeLists.txt\n  +--config/\n      +--[some files]\n  +--src/\n      +--[some files]\n  +--test/\n      +--[some files]\n  +--build/\n      +--[some files]\n</code></pre>"},{"location":"Guideline/Style-guide-cpp/#naming-convention","title":"Naming Convention","text":"<p>Each class <code>Foo</code> is defined by a header file <code>Foo.hpp</code> and a source file <code>Foo.cpp</code>. Class name will uses capital letters to disdinguish each words. For example, <code>FooBar</code> is a valid class name.</p> <p>Example</p> <pre><code>    class FooBar {\n        ...\n    };\n</code></pre> <p>Each header file will have a gardian macro. The gardian marcro will be the logic path of the header file. The macro should be in upper case letters and seperated by underscore symbol (<code>_</code>). It should also begin and end with double underscore symbols (<code>__</code>).</p> <p>Example</p> <pre><code>#ifndef __PRIMARY_NAMESPACE_SECONDARY_NAMESPACE_FOO_BAR_HPP__\n#define __PRIMARY_NAMESPACE_SECONDARY_NAMESPACE_FOO_BAR_HPP__\n...\n#endif // __PRIMARY_NAMESPACE_SECONDARY_NAMESPACE_FOO_BAR_HPP__\n</code></pre> <p>One should use hierarchical namespaces if required. There is no limitation on the level of namespace nor the amount of namespaces in each level. Name space should be all lower case letters. When enclose a piece of code with hierarchical namespaces, write them in seperate bracks.</p> <p>Note</p> <p>You shouldn't put indentation space for namespaces.</p> <p>Example</p> <pre><code>namespace foo{\nnamespace bar{\n...\n}\n}\n</code></pre> <p>Macro names in general should be in all upper case letters and seperated by underscore symbol.</p> <p>Example</p> <pre><code>#define MACRO_ONE 1\n#define MACRO_TWO 2\n</code></pre> <p>Function names in general should be in all lower case letters and seperated by underscore symbol.</p> <p>Example</p> <pre><code>int FooBar::foo_bar(){\n    ...\n}\n</code></pre> <p>Variable names should be in all lower case letters and seperated by underscore symbol. If the variable is a private or protected variable in a class, it should also start with an underscore symbol. Public variables should not start with underscore symbol. If the variable is the input argument of a function, it should also end with an underscore symbol.</p> <p>Example</p> <pre><code>    class FooBar {\n    private:\n        int _var_1;\n    public:\n        float var_2;\n    public:\n        void func_1(int arg_1_, int arg_2_);\n    };\n</code></pre> <p>There is no rule to name temporary variables. As long as the variable name does not confuse readers, it can be accepted. However, there are some tradition of naming temporary variables one should follow. For example, <code>i</code>, <code>j</code>, <code>k</code> are usually reserved for loop iterators.</p> <p>Example</p> <pre><code>    int func_1(){\n        int a;\n        for(int i=0; i&lt;5; i++){\n            int b = 2;\n            int a = a+i;\n        }\n        return a;\n    }\n</code></pre>"}]}